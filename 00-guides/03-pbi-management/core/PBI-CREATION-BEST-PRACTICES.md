# PBI作成ベストプラクティスガイド (PBI Creation Best Practices Guide)

## 📋 ドキュメント情報

| 項目 | 内容 |
|------|------|
| **ドキュメント名** | PBI作成ベストプラクティスガイド |
| **バージョン** | 1.0.0 |
| **最終更新日** | 2025-11-17 |
| **対象読者** | 自律的AIエージェント、開発チーム、プロジェクトマネージャー、プロダクトオーナー |
| **目的** | 高品質なPBI（Product Backlog Item）を作成するための実践的なガイドラインとベストプラクティスを提供 |

---

## 📖 目次

1. [はじめに](#はじめに)
2. [PBI作成の基本原則](#pbi作成の基本原則)
3. [INVEST原則の詳細](#invest原則の詳細)
4. [PBIタイプ別作成ガイドライン](#pbiタイプ別作成ガイドライン)
5. [ユーザーストーリーの書き方](#ユーザーストーリーの書き方)
6. [受け入れ基準（Acceptance Criteria）の定義方法](#受け入れ基準acceptance-criteriaの定義方法)
7. [技術的制約・前提条件の記載](#技術的制約前提条件の記載)
8. [見積もりとポイント付け](#見積もりとポイント付け)
9. [チェックリスト：レビュー前の確認事項](#チェックリストレビュー前の確認事項)
10. [よくある失敗パターンと対策](#よくある失敗パターンと対策)
11. [実例集（Good/Bad Examples）](#実例集goodbad-examples)
12. [AIエージェント向けガイダンス](#aiエージェント向けガイダンス)
13. [関連ドキュメント](#関連ドキュメント)

---

## はじめに

### このガイドの目的

高品質なPBI（Product Backlog Item）の作成は、効率的なアジャイル開発の基盤です。このガイドは、以下を提供します：

- **実践的な作成方法**: 具体的な書き方とテンプレート
- **品質基準**: INVEST原則に基づく評価基準
- **タイプ別ガイド**: 8つのPBIタイプそれぞれの作成方法
- **失敗パターン回避**: よくある間違いと対策
- **実例集**: Good/Bad Exampleで学ぶ実践的な書き方

### 対象となるPBIタイプ

本ガイドでは、以下の**8つのPBIタイプ**を扱います：

| ID | タイプ名 | 略称 | 主な用途 |
|----|---------|------|---------|
| 1 | 新規プロジェクト立ち上げ | **NPI** | プロジェクト全体の初期構築 |
| 2 | 新規機能開発 | **NFD** | 新しいビジネス機能・ユースケースの追加 |
| 3 | 既存機能追加・改修 | **ENH** | 既存機能の拡張・改善 |
| 4 | バグ修正 | **BUG** | 不具合の修正 |
| 5 | リファクタリング | **REF** | コード品質改善（機能変更なし） |
| 6 | 設計変更・アーキテクチャ改善 | **ARC** | 根本的な設計・アーキテクチャの見直し |
| 7 | 緊急修正 | **HOT** | 24時間以内の緊急対応 |
| 8 | 実験的機能 | **POC** | 技術検証・概念実証 |

> **📘 タイプ判定の詳細**: PBIタイプの判定方法については、[PBI-TYPE-JUDGMENT-GUIDE.md](../core/PBI-TYPE-JUDGMENT-GUIDE.md) を参照してください。

### ガイドの使い方

1. **新規PBI作成時**: まず[基本原則](#pbi作成の基本原則)と[INVEST原則](#invest原則の詳細)を確認
2. **タイプ別作成**: 該当する[PBIタイプ別ガイドライン](#pbiタイプ別作成ガイドライン)を参照
3. **品質確認**: [チェックリスト](#チェックリストレビュー前の確認事項)で作成したPBIを検証
4. **実例から学ぶ**: [実例集](#実例集goodbad-examples)でGood/Bad Exampleを比較

---

## PBI作成の基本原則

### 1. 明確な価値の提供

すべてのPBIは、**ビジネス価値**または**技術的価値**を明確に示す必要があります。

#### ✅ Good Practice
```
明確な価値: 「ユーザーが商品を素早く検索できるようにすることで、購入率を向上させる」
```

#### ❌ Bad Practice
```
不明確: 「検索機能を追加する」← なぜ必要なのか不明
```

### 2. ステークホルダーの視点

PBIは、**誰のため**に、**何を**実現するのかを明確にします。

#### 主要なステークホルダー
- **エンドユーザー**: 実際にシステムを使用する人
- **ビジネスオーナー**: ビジネス目標を持つ人
- **開発チーム**: 実装する技術者
- **運用チーム**: システムを保守・運用する人

### 3. 完結性と独立性

各PBIは、可能な限り**独立して完結**できるようにします。

#### チェックポイント
- ✅ 他のPBIに依存せずに価値を提供できるか？
- ✅ 単独でテスト・デプロイ可能か？
- ✅ 明確な開始点と終了点があるか？

### 4. 適切な粒度

PBIは、**1スプリント以内**（通常1-2週間）で完了できる粒度が理想です。

#### 粒度の目安

| サイズ | ストーリーポイント | 期間目安 | 適切性 |
|--------|-----------------|---------|--------|
| Extra Small | 1-2 | 1-2日 | ✅ 最適 |
| Small | 3-5 | 3-5日 | ✅ 良好 |
| Medium | 8 | 1週間 | ⚠️ 分割検討 |
| Large | 13 | 2週間 | ❌ 分割必須 |
| Extra Large | 21+ | 2週間以上 | ❌ Epic化して分割 |

> **📘 分割方法の詳細**: 大きすぎるPBIの分割方法については、[PBI-SPLITTING-GUIDE.md](../guides/PBI-SPLITTING-GUIDE.md)（別途作成予定）を参照してください。

### 5. 検証可能性

PBIの完了条件は、**客観的に検証可能**である必要があります。

#### ✅ 検証可能な表現
```
- ユーザーが5秒以内に検索結果を取得できる
- エラー発生時にログが記録される
- APIが200ステータスコードを返す
```

#### ❌ 検証不可能な表現
```
- 使いやすいUIを提供する ← 主観的
- パフォーマンスを改善する ← 基準不明
- バグを修正する ← 範囲不明確
```

---

## INVEST原則の詳細

INVEST原則は、高品質なPBI作成のための6つの基準です。

### I - Independent（独立性）

#### 定義
他のPBIに依存せず、独立して実装・テスト・デプロイが可能である。

#### チェックポイント
- ✅ このPBIは他のPBIが完了していなくても着手できるか？
- ✅ 他のPBIと並行して開発できるか？
- ✅ 依存関係が最小化されているか？

#### 依存性の扱い方

**許容できる依存**:
- インフラ・基盤の整備（例：データベースセットアップ）
- 共通ライブラリ・フレームワークの選定

**避けるべき依存**:
- 特定の画面が完成していないと作業できない
- 他チームの作業完了待ち

#### 実例

**✅ Good: 独立性が高い**
```
PBI-001: ユーザー登録API実装
PBI-002: ログインAPI実装
→ 並行して開発可能
```

**❌ Bad: 依存性が強い**
```
PBI-001: ユーザー登録画面のHTML作成
PBI-002: ユーザー登録画面のCSS適用（PBI-001に依存）
PBI-003: ユーザー登録画面のJavaScript実装（PBI-001,002に依存）
→ 順次実行しかできない（分割が不適切）
```

**改善例**:
```
PBI-001: ユーザー登録画面の完成（HTML/CSS/JS含む）
→ 1つのPBIにまとめて独立性を確保
```

---

### N - Negotiable（交渉可能性）

#### 定義
実装の詳細は固定せず、開発チームとプロダクトオーナーが対話しながら調整できる。

#### チェックポイント
- ✅ 「何を」達成するかは明確だが、「どのように」は柔軟か？
- ✅ 実装方法の選択肢が残されているか？
- ✅ スコープ調整の余地があるか？

#### 固定すべきもの vs 交渉可能なもの

**固定すべき（Non-Negotiable）**:
- ✅ ビジネス目標・価値
- ✅ 最低限の受け入れ基準
- ✅ セキュリティ・コンプライアンス要件

**交渉可能（Negotiable）**:
- 🔄 実装技術の選択
- 🔄 UI/UXの詳細デザイン
- 🔄 パフォーマンス目標値（範囲内で）
- 🔄 優先順位の高い機能から段階リリース

#### 実例

**✅ Good: 交渉の余地がある**
```
タイトル: ユーザーが商品検索できる機能

記述:
「ユーザーとして、キーワードで商品を検索したい。
なぜなら、欲しい商品を素早く見つけたいから。」

受け入れ基準:
- ユーザーがキーワードを入力できる
- 関連商品が表示される
- 検索結果が5秒以内に表示される

技術的制約:
- 既存のElasticsearchを活用すること

実装の自由度:
- 検索アルゴリズムの詳細は開発チームに委ねる
- UIデザインはUXチームと相談
```

**❌ Bad: 実装が固定されすぎ**
```
タイトル: 商品検索機能

記述:
「ReactのuseStateフックを使って検索ボックスを実装し、
Elasticsearchのmatch_phraseクエリで検索する。
検索ボタンは青色、フォントサイズは16pxにする。」

→ 実装方法が固定されており、技術的な改善提案ができない
```

---

### V - Valuable（価値がある）

#### 定義
ステークホルダー（ユーザー、ビジネス、技術チーム）にとって明確な価値を提供する。

#### 価値の種類

| 価値タイプ | 説明 | 例 |
|----------|------|-----|
| **ビジネス価値** | 売上・顧客満足度向上 | 「購入率を10%向上させる」 |
| **ユーザー価値** | ユーザー体験の改善 | 「操作時間を30秒短縮」 |
| **技術的価値** | 保守性・拡張性向上 | 「デプロイ時間を50%削減」 |
| **リスク軽減** | セキュリティ・安定性向上 | 「データ漏洩リスクを排除」 |

#### チェックポイント
- ✅ このPBIが完了すると、誰がどんな恩恵を受けるか？
- ✅ 価値が定量的に測定できるか？
- ✅ なぜ今このPBIが必要なのか？

#### 実例

**✅ Good: 価値が明確**
```
タイトル: パスワードリセット機能の実装

価値:
「ユーザーがパスワードを忘れた際、自分で再設定できるようにすることで、
カスタマーサポートへの問い合わせを月間50件削減し、
ユーザーの待ち時間をゼロにする。」

ビジネス価値: サポートコスト削減（約10万円/月）
ユーザー価値: 即座にアカウント回復可能
```

**❌ Bad: 価値が不明確**
```
タイトル: パスワードリセット機能の実装

記述:
「パスワードリセット機能を追加する。」

→ なぜ必要なのか、誰が恩恵を受けるのか不明
```

---

### E - Estimable（見積もり可能）

#### 定義
開発チームが作業量を合理的に見積もれるだけの情報が含まれている。

#### 見積もりを困難にする要因

| 要因 | 問題 | 解決策 |
|------|------|--------|
| **要件の曖昧さ** | 何を作るか不明確 | 受け入れ基準を具体化 |
| **技術的不確実性** | 実装方法が未知 | Spike/POCで調査 |
| **依存関係の複雑さ** | 影響範囲が不明 | 技術調査で依存を明確化 |
| **スコープが大きすぎ** | 全体像が把握困難 | PBIを分割 |

#### チェックポイント
- ✅ 開発チームが「何を作るか」を理解できるか？
- ✅ 必要な技術情報が提供されているか？
- ✅ 不確実性が許容範囲内か？

#### 実例

**✅ Good: 見積もり可能**
```
タイトル: ユーザー登録API実装

受け入れ基準:
- POST /api/users でユーザー登録できる
- メールアドレス・パスワードをバリデーション
- 重複登録を防ぐ（メールアドレス一意制約）
- パスワードはbcryptでハッシュ化

技術情報:
- 使用フレームワーク: Express.js
- データベース: PostgreSQL（既存）
- 認証方式: JWT（既存実装を参考）

見積もり: 3-5ストーリーポイント（2-3日）
```

**❌ Bad: 見積もり不可能**
```
タイトル: ユーザー管理機能の実装

記述:
「ユーザー関連の機能を実装する。」

→ 範囲が広すぎて見積もり不可能
→ どの機能が含まれるか不明
```

**Spike例: 技術的不確実性が高い場合**
```
タイトル: [SPIKE] リアルタイム通知の実装方法調査

目的:
WebSocketとServer-Sent Events（SSE）のどちらが
当社のユースケースに適しているかを調査する。

調査項目:
- 各技術の実装難易度
- スケーラビリティ（1万同時接続時）
- 既存インフラとの互換性
- 運用コスト

成果物:
- 技術選定レポート（2-3ページ）
- 簡易プロトタイプ（概念実証）

タイムボックス: 2日
```

---

### S - Small（小さい）

#### 定義
1スプリント（通常1-2週間）以内に完了できる適切なサイズである。

#### サイズの目安

**理想的なサイズ**:
- 📊 **ストーリーポイント**: 3-5ポイント
- ⏱️ **期間**: 2-5日
- 👥 **担当者**: 1-2名

**大きすぎる場合のサイン**:
- ⚠️ 8ポイント以上
- ⚠️ 1週間以上かかる
- ⚠️ 3名以上必要
- ⚠️ 複数のサブシステムに跨る

#### 分割の判断基準

```
PBIサイズの判断フローチャート:

見積もりが8ポイント以上？
  ├─ YES → 分割を検討
  │         ├─ 機能で分割できるか？
  │         ├─ レイヤーで分割できるか？
  │         └─ 段階リリースできるか？
  └─ NO → そのまま進行
```

#### 実例

**✅ Good: 適切なサイズ**
```
PBI-101: ユーザー登録API実装
見積もり: 5ポイント（3日）

受け入れ基準:
- POST /api/users でユーザー登録
- バリデーション実装
- 単体テスト・統合テスト作成
```

**❌ Bad: 大きすぎる**
```
PBI-999: ユーザー管理機能の完全実装
見積もり: 21ポイント（2週間以上）

含まれる機能:
- ユーザー登録
- ログイン
- プロフィール編集
- パスワードリセット
- 権限管理
- アカウント削除

→ 6つのPBIに分割すべき
```

**改善例: 適切に分割**
```
Epic: ユーザー管理機能

├─ PBI-101: ユーザー登録API（5ポイント）
├─ PBI-102: ログインAPI（3ポイント）
├─ PBI-103: プロフィール編集API（5ポイント）
├─ PBI-104: パスワードリセット機能（5ポイント）
├─ PBI-105: 権限管理機能（8ポイント）
└─ PBI-106: アカウント削除機能（3ポイント）

合計: 29ポイント → 6スプリントに分散可能
```

---

### T - Testable（テスト可能）

#### 定義
PBIの完了を客観的に検証できる明確なテスト基準が存在する。

#### テスト可能性の3要素

1. **明確な受け入れ基準**: 何をもって「完了」とするか
2. **検証方法**: どうやってテストするか
3. **合格基準**: どの状態なら合格か

#### チェックポイント
- ✅ 受け入れ基準がすべて検証可能か？
- ✅ テストシナリオが書けるか？
- ✅ 自動テストを作成できるか？

#### 実例

**✅ Good: テスト可能**
```
タイトル: 商品検索API実装

受け入れ基準:
1. ✅ キーワードで商品を検索できる
   - テスト: GET /api/products?q=laptop
   - 期待: 200 OK、商品リストを返す
   
2. ✅ 検索結果が5秒以内に返る
   - テスト: 1000件のデータで負荷テスト
   - 期待: 95%ile レスポンスタイム < 5秒
   
3. ✅ 存在しないキーワードの場合、空配列を返す
   - テスト: GET /api/products?q=nonexistent123
   - 期待: 200 OK、[]（空配列）

4. ✅ 不正なパラメータの場合、400エラーを返す
   - テスト: GET /api/products?q=
   - 期待: 400 Bad Request、エラーメッセージ
```

**❌ Bad: テスト不可能**
```
タイトル: 商品検索機能

受け入れ基準:
- 使いやすい検索機能を提供する ← 主観的、測定不可能
- パフォーマンスを改善する ← 基準値なし
- エラーハンドリングを実装する ← 範囲不明確
```

---

## PBIタイプ別作成ガイドライン

### タイプ1: NPI - 新規プロジェクト立ち上げ

#### 定義
ゼロから新しいプロジェクト・システムを立ち上げる作業。

#### 特徴
- 📦 プロジェクト構造がまだ存在しない
- 🏗️ 技術スタック・アーキテクチャを選定する
- 📋 全Phase（0→1→2→3→4→5→6）を実施
- ⏱️ 通常2-4週間以上

#### 必須記載項目

| 項目 | 説明 | 例 |
|------|------|-----|
| **プロジェクト名** | 明確な識別名 | "ECサイト構築プロジェクト" |
| **ビジネス目標** | 何を達成するか | "月間1万件の注文処理" |
| **技術要件** | 使用技術の制約 | "React, Node.js, PostgreSQL" |
| **スケジュール** | マイルストーン | "3ヶ月でMVPリリース" |
| **リソース** | 必要な人員・予算 | "開発者3名、予算500万円" |

#### 作成テンプレート

```markdown
# PBI: [プロジェクト名] - 新規プロジェクト立ち上げ

## タイプ
**NPI** (New Project Initialization)

## ビジネス背景・目的
[なぜこのプロジェクトが必要なのか]

- **ビジネス目標**: 
- **対象ユーザー**: 
- **期待される成果**: 

## スコープ
### 含まれるもの
- [ ] 項目1
- [ ] 項目2

### 含まれないもの（将来検討）
- [ ] 項目A
- [ ] 項目B

## 技術要件
- **言語・フレームワーク**: 
- **データベース**: 
- **インフラ**: 
- **外部サービス**: 

## 受け入れ基準
- [ ] プロジェクト構造が作成されている
- [ ] CI/CDパイプラインが動作する
- [ ] 基本的なCRUD操作が実装されている
- [ ] ドキュメントが整備されている

## 制約条件
- **期限**: 
- **予算**: 
- **技術制約**: 

## 依存関係
- [ ] インフラ環境の準備
- [ ] アカウント・権限の取得

## 見積もり
- **ストーリーポイント**: 
- **期間**: 
```

#### 実例: Good Example

```markdown
# PBI-001: オンライン予約システム - 新規プロジェクト立ち上げ

## タイプ
**NPI** (New Project Initialization)

## ビジネス背景・目的
現在、電話とメールのみで受け付けている予約を、
24時間オンラインで受け付けられるようにする。

- **ビジネス目標**: 予約受付業務を50%削減、顧客満足度向上
- **対象ユーザー**: 一般ユーザー（月間500名想定）
- **期待される成果**: 月間200件のオンライン予約

## スコープ
### 含まれるもの（MVP）
- [x] ユーザー登録・ログイン機能
- [x] 空き状況確認機能
- [x] 予約作成・キャンセル機能
- [x] メール通知機能
- [x] 管理者向け予約管理画面

### 含まれないもの（将来検討）
- [ ] 決済機能（Phase 2で検討）
- [ ] スマホアプリ（Web版が軌道に乗ってから）
- [ ] 多言語対応

## 技術要件
- **フロントエンド**: React 18, TypeScript
- **バックエンド**: Node.js 18, Express, TypeScript
- **データベース**: PostgreSQL 15
- **インフラ**: AWS (EC2, RDS, S3)
- **CI/CD**: GitHub Actions

## 受け入れ基準
- [x] プロジェクト構造が作成され、GitHubリポジトリにpush済み
- [x] ローカル開発環境で起動できる（docker-compose）
- [x] CI/CDパイプラインが動作し、自動テストが通る
- [x] 基本的なCRUD APIが実装されている
- [x] README、アーキテクチャ図が作成されている
- [x] 開発環境にデプロイ成功

## 制約条件
- **期限**: 3ヶ月後（2025-02-17）にMVPリリース
- **予算**: 開発費500万円以内
- **技術制約**: 既存のAWS環境を活用すること

## 依存関係
- [x] AWS環境のセットアップ（インフラチームに依頼済み）
- [x] GitHub Organizationへのアクセス権取得
- [ ] ドメイン名の取得（営業部と調整中）

## 見積もり
- **ストーリーポイント**: 40ポイント（Epic）
- **期間**: 4週間（Phase 1まで完了）
- **担当**: フロントエンド2名、バックエンド2名

## 関連ドキュメント
- [ビジネス要件書](link)
- [技術選定書](link)
```

---

### タイプ2: NFD - 新規機能開発

#### 定義
既存プロジェクトに新しいビジネス機能・ユースケースを追加する作業。

#### 特徴
- 🏗️ プロジェクト構造は既に存在
- ✨ 新しいユーザーストーリー・ユースケースを追加
- 📋 Phase 0→2→3→4→5を実施（Phase 1はスキップ）
- ⏱️ 通常1-2週間

#### 必須記載項目

| 項目 | 説明 | 例 |
|------|------|-----|
| **ユーザーストーリー** | 誰が何をしたいか | "買い物客として、お気に入り登録したい" |
| **ビジネス価値** | なぜ必要か | "リピート率15%向上" |
| **受け入れ基準** | 完了の定義 | "お気に入り追加・削除・一覧表示" |
| **技術的考慮事項** | 実装上の注意点 | "既存のユーザーテーブルと連携" |

#### 作成テンプレート

```markdown
# PBI: [機能名] - 新規機能開発

## タイプ
**NFD** (New Feature Development)

## ユーザーストーリー
**として**: [ユーザータイプ]
**〜したい**: [やりたいこと]
**なぜなら**: [理由・目的]

## ビジネス価値
- **定量的目標**: 
- **対象ユーザー**: 
- **優先度**: 

## 受け入れ基準
- [ ] 機能要件1
- [ ] 機能要件2
- [ ] 非機能要件（パフォーマンス等）

## 技術的考慮事項
- **既存システムへの影響**: 
- **データモデル変更**: 
- **API設計**: 

## UIモックアップ・デザイン
[リンクまたは説明]

## 見積もり
- **ストーリーポイント**: 
- **期間**: 
```

#### 実例: Good Example

```markdown
# PBI-205: お気に入り商品登録機能 - 新規機能開発

## タイプ
**NFD** (New Feature Development)

## ユーザーストーリー
**として**: 買い物客
**〜したい**: 気になる商品をお気に入りに登録して後で見返したい
**なぜなら**: すぐに購入を決められない商品を記録しておき、比較検討したいから

## ビジネス価値
- **定量的目標**: 
  - お気に入り機能利用ユーザーのリピート率を15%向上
  - 平均購入単価を10%向上（比較検討による）
- **対象ユーザー**: 登録済みユーザー（月間2000名想定）
- **優先度**: High（次回スプリントで実装）

## 受け入れ基準
### 機能要件
- [x] 商品詳細画面に"お気に入り"ボタンが表示される
- [x] ボタンクリックでお気に入りに追加/削除できる
- [x] マイページにお気に入り一覧が表示される
- [x] お気に入り商品が削除された場合、一覧から自動削除される
- [x] お気に入り数の上限は100件

### 非機能要件
- [x] お気に入り追加/削除のレスポンスタイムが1秒以内
- [x] お気に入り一覧の表示が2秒以内（50件表示時）
- [x] 楽観的UIで即座にフィードバック

### テスト要件
- [x] 単体テスト: カバレッジ80%以上
- [x] 統合テスト: お気に入りCRUD操作
- [x] E2Eテスト: ユーザーフロー全体

## 技術的考慮事項
- **データモデル変更**: 
  - 新テーブル`favorites`作成（user_id, product_id, created_at）
  - ユニーク制約: (user_id, product_id)
  
- **API設計**: 
  - POST /api/favorites （お気に入り追加）
  - DELETE /api/favorites/:id （削除）
  - GET /api/favorites （一覧取得）
  
- **既存システムへの影響**: 
  - 商品削除時、関連するお気に入りも削除（CASCADE）
  - 既存の商品APIに`is_favorited`フィールド追加

## UIモックアップ
- [商品詳細画面モック](link)
- [お気に入り一覧画面モック](link)

## 見積もり
- **ストーリーポイント**: 5ポイント
- **期間**: 3日
- **担当**: フロントエンド1名、バックエンド1名

## 関連PBI
- PBI-206: お気に入り商品のメール通知（次スプリント）
```

#### 実例: Bad Example

```markdown
# PBI-999: お気に入り機能

## 説明
お気に入り機能を追加する。

## 受け入れ基準
- お気に入りができる
- 一覧が見れる

## 見積もり
不明
```

**問題点**:
- ❌ ユーザーストーリーがない（誰のため？なぜ？）
- ❌ 受け入れ基準が曖昧（"できる"の定義不明）
- ❌ 技術情報がない
- ❌ ビジネス価値が不明
- ❌ 見積もり不可能

---

### タイプ3: ENH - 既存機能追加・改修

#### 定義
既存機能の拡張・改善。新しいユースケースは追加しない。

#### 特徴
- 🔧 既存機能を強化・改善
- 📊 パフォーマンス改善、UI改善等
- 📋 Phase 0→2→3→4→5を実施
- ⏱️ 通常3-7日

#### NFDとの違い

| 観点 | ENH（既存機能改修） | NFD（新規機能開発） |
|------|------------------|-------------------|
| **ユースケース** | 既存ユースケース内 | 新しいユースケース |
| **データモデル** | 既存モデルを維持 | 新テーブル追加あり |
| **API** | 既存APIの拡張 | 新APIエンドポイント |
| **例** | 検索精度向上 | お気に入り機能追加 |

#### 作成テンプレート

```markdown
# PBI: [機能名] - 既存機能改修

## タイプ
**ENH** (Enhancement / Modification)

## 改善対象
**既存機能**: [対象機能名]
**現状の問題**: [何が問題か]
**改善内容**: [どう改善するか]

## ビジネス価値
- **改善される指標**: 
- **対象ユーザー**: 

## 受け入れ基準
- [ ] 改善要件1
- [ ] 改善要件2
- [ ] 既存機能が正常動作すること

## 影響範囲
- **変更対象**: 
- **影響を受ける機能**: 
- **後方互換性**: 

## 見積もり
- **ストーリーポイント**: 
- **期間**: 
```

#### 実例: Good Example

```markdown
# PBI-312: 商品検索のパフォーマンス改善

## タイプ
**ENH** (Enhancement / Modification)

## 改善対象
**既存機能**: 商品検索機能
**現状の問題**: 
- 検索結果表示に平均8秒かかる（目標: 3秒以内）
- データ量増加（10万件→50万件）により遅延が顕著
- ユーザーからの苦情が月10件以上

**改善内容**: 
- Elasticsearchのインデックス最適化
- クエリのチューニング
- キャッシュ層の追加（Redis）

## ビジネス価値
- **改善される指標**: 
  - 検索レスポンスタイム: 8秒 → 3秒以内
  - 直帰率: 30% → 20%に改善予測
- **対象ユーザー**: 全ユーザー（月間5000検索）

## 受け入れ基準
### パフォーマンス要件
- [x] 検索レスポンスタイムが3秒以内（95%ile）
- [x] 50万件のデータで負荷テスト実施
- [x] 同時100ユーザーでも性能維持

### 機能要件
- [x] 既存の検索機能が全て正常動作
- [x] 検索結果の順序・内容が変わらない
- [x] フィルタリング機能が正常動作

### 運用要件
- [x] Elasticsearchインデックス更新手順書作成
- [x] Redisキャッシュクリア手順書作成
- [x] モニタリングダッシュボード更新

## 技術的改善内容
1. **Elasticsearchインデックス最適化**
   - フィールドマッピングの見直し
   - アナライザーの最適化
   
2. **クエリチューニング**
   - 不要なフィールド取得を削減
   - ページネーションの改善
   
3. **キャッシュ層追加**
   - 人気検索キーワードをRedisにキャッシュ（TTL: 1時間）
   - キャッシュヒット率目標: 60%

## 影響範囲
- **変更対象**: 
  - `searchService.ts`
  - `elasticsearch/mapping.json`
  - 新規: `cacheService.ts`
  
- **影響を受ける機能**: 
  - 商品検索API（GET /api/products/search）
  - 検索結果画面
  
- **後方互換性**: 
  - APIの入出力は変更なし
  - 既存のフロントエンドコード変更不要

## テスト計画
- [x] パフォーマンステスト（JMeter）
- [x] 回帰テスト（既存機能）
- [x] キャッシュの整合性テスト

## ロールバック計画
- Elasticsearchのインデックス設定をバックアップ
- Redis無効化時も動作するフラグ設定

## 見積もり
- **ストーリーポイント**: 5ポイント
- **期間**: 4日
- **担当**: バックエンド2名
```

---

### タイプ4: BUG - バグ修正

#### 定義
既存機能の不具合を修正する作業。

#### 特徴
- 🐛 仕様と実装の乖離を解消
- 🔧 機能追加はしない（修正のみ）
- 📋 Phase 0（簡易版）→3→4を実施
- ⏱️ 通常1-3日

#### 必須記載項目

| 項目 | 説明 | 必須度 |
|------|------|--------|
| **再現手順** | バグの再現方法 | ✅ 必須 |
| **期待される動作** | 正しい動作 | ✅ 必須 |
| **実際の動作** | 現在の誤った動作 | ✅ 必須 |
| **影響範囲** | 誰が/いつ影響を受けるか | ✅ 必須 |
| **重大度** | Critical/High/Medium/Low | ✅ 必須 |

#### 作成テンプレート

```markdown
# PBI: [バグ内容] - バグ修正

## タイプ
**BUG** (Bug Fix)

## 重大度
[Critical / High / Medium / Low]

## バグ説明
**概要**: [バグの簡潔な説明]

## 再現手順
1. [ステップ1]
2. [ステップ2]
3. [ステップ3]

## 期待される動作
[正しい動作の説明]

## 実際の動作
[現在の誤った動作]

## 影響範囲
- **影響を受けるユーザー**: 
- **発生頻度**: 
- **ビジネスへの影響**: 

## 原因（判明している場合）
[バグの原因]

## 修正方針
[どのように修正するか]

## 受け入れ基準
- [ ] バグが修正され、期待通りに動作する
- [ ] 再現手順でバグが発生しない
- [ ] 既存機能に影響がない（回帰テスト）
- [ ] 単体テスト追加（再発防止）

## 見積もり
- **ストーリーポイント**: 
- **期間**: 
```

#### 実例: Good Example

```markdown
# PBI-450: ログイン時にセッションが即座に切れるバグ

## タイプ
**BUG** (Bug Fix)

## 重大度
**Critical** - ユーザーがログインできない

## バグ説明
**概要**: ログイン成功後、即座にセッションが切れてログアウトされる

## 再現手順
1. ログイン画面でメールアドレス・パスワードを入力
2. "ログイン"ボタンをクリック
3. ログイン成功メッセージが表示される
4. 3秒後、自動的にログアウトされ、再度ログイン画面にリダイレクト

**環境**: 
- ブラウザ: Chrome 120, Safari 17
- OS: Windows, macOS
- 発生開始: 2025-11-15（デプロイ後）

## 期待される動作
ログイン成功後、セッションが維持され、マイページに遷移する。
セッションは24時間有効（設定値）。

## 実際の動作
ログイン成功後、約3秒でセッションが切れ、ログイン画面に戻る。

## 影響範囲
- **影響を受けるユーザー**: 全ユーザー（100%）
- **発生頻度**: 毎回（100%再現）
- **ビジネスへの影響**: 
  - ログインできないため、サービス利用不可
  - サポート問い合わせ急増（30件/日）
  - 緊急対応が必要

## 原因
2025-11-15のデプロイで、セッションCookieのドメイン設定が誤っていた。

```javascript
// 誤った設定（2025-11-15デプロイ）
res.cookie('sessionId', token, {
  domain: 'localhost',  // ← 本番環境で'localhost'が設定されている
  maxAge: 86400000
});

// 正しい設定
res.cookie('sessionId', token, {
  domain: process.env.COOKIE_DOMAIN,  // 環境変数から取得
  maxAge: 86400000
});
```

## 修正方針
1. `authController.ts`のCookieドメイン設定を修正
2. 環境変数`COOKIE_DOMAIN`を使用
3. 単体テスト追加（Cookie設定の検証）

## 受け入れ基準
- [x] ログイン後、セッションが24時間維持される
- [x] 再現手順でバグが発生しない
- [x] 開発環境・本番環境の両方で動作確認
- [x] 単体テスト追加（Cookie設定の検証）
- [x] E2Eテスト追加（ログイン→ページ遷移→ログイン状態維持）

## ロールバック計画
前回のデプロイ（2025-11-14）にロールバック可能。

## 見積もり
- **ストーリーポイント**: 2ポイント
- **期間**: 2時間（緊急対応）
- **担当**: バックエンドエンジニア1名

## 再発防止策
- デプロイ前のステージング環境での動作確認を徹底
- Cookie設定の単体テストを必須化
```

---

### タイプ5: REF - リファクタリング

#### 定義
コードの内部構造を改善し、可読性・保守性を向上させる。機能変更は一切しない。

#### 特徴
- 🔧 外部から見た動作は変わらない
- 📚 コード品質の向上（可読性・保守性・拡張性）
- 📋 Phase 0→3→4を実施（Phase 2, 5はスキップ）
- ⏱️ 通常1-5日

#### 必須記載項目

| 項目 | 説明 | 例 |
|------|------|-----|
| **対象コード** | リファクタリング対象 | "UserService.ts" |
| **現在の問題** | コードの問題点 | "500行の関数、重複コード多数" |
| **改善内容** | 具体的な改善方法 | "関数分割、共通化" |
| **リスク** | 変更による影響 | "既存機能への影響なし" |

#### リファクタリングの判定基準

**REFとして扱う**:
- ✅ 機能・振る舞いが一切変わらない
- ✅ テストケースが変更不要（既存テストが通る）
- ✅ APIの入出力が同じ

**ENH/ARCとして扱う**:
- ❌ 機能が追加・変更される
- ❌ パフォーマンスが大きく変わる
- ❌ アーキテクチャが根本的に変わる

#### 作成テンプレート

```markdown
# PBI: [対象] - リファクタリング

## タイプ
**REF** (Refactoring)

## リファクタリング対象
**ファイル/モジュール**: [対象のコード]
**行数**: [現在の行数]

## 現在の問題
- [ ] 問題1
- [ ] 問題2
- [ ] 問題3

## 改善内容
- [ ] 改善策1
- [ ] 改善策2
- [ ] 改善策3

## 受け入れ基準
- [ ] 全ての既存テストが通る
- [ ] コードカバレッジが低下しない
- [ ] 機能・振る舞いが変わらない
- [ ] コード品質メトリクスが改善
  - [ ] Cyclomatic Complexity: [現在] → [目標]
  - [ ] Code Duplication: [現在] → [目標]

## リスク管理
- **リスク**: [潜在的なリスク]
- **軽減策**: [リスク軽減方法]
- **ロールバック**: [問題発生時の対応]

## 見積もり
- **ストーリーポイント**: 
- **期間**: 
```

#### 実例: Good Example

```markdown
# PBI-520: UserServiceのリファクタリング

## タイプ
**REF** (Refactoring)

## リファクタリング対象
**ファイル/モジュール**: `src/services/UserService.ts`
**行数**: 850行 → 300行（目標）

## 現在の問題
- [x] 1つのクラスが850行と長大
- [x] `createUser`メソッドが200行（責務過多）
- [x] 重複コードが5箇所以上
- [x] 単体テストが困難（モック作成が複雑）
- [x] Cyclomatic Complexity: 25（目標: 10以下）

## 改善内容
### 1. クラス分割
```
UserService (850行)
  ↓
UserService (150行) - 公開インターフェース
UserValidator (100行) - バリデーション
UserRepository (50行) - データアクセス
```

### 2. メソッド分割
```typescript
// Before: 200行の巨大メソッド
async createUser(data) {
  // バリデーション 50行
  // DB挿入 30行
  // メール送信 40行
  // ログ記録 20行
  // ...
}

// After: 責務ごとに分割
async createUser(data) {
  await this.validator.validate(data);
  const user = await this.repository.create(data);
  await this.emailService.sendWelcome(user);
  this.logger.info('User created', user.id);
  return user;
}
```

### 3. 共通処理の抽出
- エラーハンドリングをデコレータに抽出
- ログ記録を共通ユーティリティに抽出

## 受け入れ基準
### 機能要件（変更なし）
- [x] 全ての既存テストが通る（70件）
- [x] E2Eテストが通る
- [x] 機能・振る舞いが一切変わらない

### コード品質改善
- [x] ファイル行数: 850行 → 300行以下
- [x] 最大メソッド行数: 200行 → 50行以下
- [x] Cyclomatic Complexity: 25 → 10以下
- [x] Code Duplication: 15% → 5%以下
- [x] テストカバレッジ: 60% → 80%以上

### ドキュメント
- [x] クラス図更新
- [x] JSDoc追加
- [x] README更新

## リスク管理
- **リスク**: リファクタリング中のバグ混入
- **軽減策**: 
  - 既存テストを全て維持・実行
  - 小さい単位で変更・コミット
  - コードレビューを必須化
- **ロールバック**: Git revertで即座に戻せる

## テスト戦略
- [x] 既存の単体テスト70件を全て維持
- [x] 新しいクラスに対して単体テスト追加
- [x] リファクタリング前後でE2Eテスト実行
- [x] パフォーマンステスト（劣化しないこと）

## 見積もり
- **ストーリーポイント**: 5ポイント
- **期間**: 3日
- **担当**: バックエンド1名

## 段階的実施計画
Day 1: Validator分離 + テスト
Day 2: Repository分離 + テスト
Day 3: メソッド分割 + 最終テスト
```

---

### タイプ6: ARC - 設計変更・アーキテクチャ改善

#### 定義
システムの根本的な設計・アーキテクチャを見直す大規模な変更。

#### 特徴
- 🏛️ アーキテクチャの根本的な変更
- 📐 設計パターン・技術スタックの変更
- 📋 Phase 0→2→3→4→5を実施
- ⏱️ 通常1-3週間

#### ARC vs REF vs ENHの違い

| 観点 | REF | ENH | ARC |
|------|-----|-----|-----|
| **機能変更** | なし | あり | なし or あり |
| **アーキテクチャ変更** | なし | 局所的 | 根本的 |
| **影響範囲** | 限定的 | 中規模 | システム全体 |
| **期間** | 1-5日 | 3-7日 | 1-3週間 |
| **例** | 関数分割 | 新機能追加 | マイクロサービス化 |

#### 必須記載項目

| 項目 | 説明 | 必須度 |
|------|------|--------|
| **現在のアーキテクチャ** | 現状の設計 | ✅ 必須 |
| **問題点** | なぜ変更が必要か | ✅ 必須 |
| **新しいアーキテクチャ** | 変更後の設計 | ✅ 必須 |
| **移行計画** | 段階的移行方法 | ✅ 必須 |
| **ROI分析** | 投資対効果 | ⚠️ 推奨 |

#### 作成テンプレート

```markdown
# PBI: [システム名] - アーキテクチャ改善

## タイプ
**ARC** (Architecture Improvement)

## 現在のアーキテクチャ
**概要**: [現在の設計]
**問題点**: 
- [ ] 問題1
- [ ] 問題2

## 新しいアーキテクチャ
**概要**: [新しい設計]
**利点**: 
- [ ] 利点1
- [ ] 利点2

## 移行計画
### Phase 1: [内容]
### Phase 2: [内容]
### Phase 3: [内容]

## ROI分析
**投資**: [開発工数・コスト]
**リターン**: [期待される効果]

## 受け入れ基準
- [ ] 新アーキテクチャが動作する
- [ ] 既存機能が全て正常動作
- [ ] パフォーマンス基準達成
- [ ] ドキュメント更新

## リスク管理
- **リスク**: 
- **軽減策**: 
- **ロールバック計画**: 

## 見積もり
- **ストーリーポイント**: 
- **期間**: 
```

#### 実例: Good Example

```markdown
# PBI-700: モノリシックからマイクロサービスへの移行（ユーザー管理）

## タイプ
**ARC** (Architecture Improvement)

## ビジネス背景
現在のモノリシックアーキテクチャでは、以下の問題が発生：
- デプロイに1時間かかる（目標: 10分以内）
- 1つのバグで全システムダウン
- 開発チーム間の競合が頻発
- スケーリングが非効率（全体をスケールする必要）

## 現在のアーキテクチャ
```
[モノリシックアプリケーション]
├─ ユーザー管理
├─ 商品管理
├─ 注文管理
└─ 決済処理

データベース: 単一のPostgreSQL
デプロイ: 全体を一括デプロイ
```

**問題点**:
- [x] 全体デプロイで1時間かかる
- [x] ユーザー管理の障害が全システムに影響
- [x] 開発チームの作業が衝突（merge conflict頻発）
- [x] スケーリングが非効率

## 新しいアーキテクチャ
```
[API Gateway]
    ├─ [ユーザーサービス] ← 今回の対象
    │   └─ Users DB (PostgreSQL)
    ├─ [商品サービス]
    │   └─ Products DB
    ├─ [注文サービス]
    │   └─ Orders DB
    └─ [決済サービス]
        └─ Payments DB

各サービス: 独立したNode.jsアプリ
通信: REST API + イベント駆動（Kafka）
```

**利点**:
- [x] ユーザーサービスのみ10分でデプロイ可能
- [x] 独立した障害分離
- [x] チーム間の独立開発
- [x] サービス単位でスケーリング

## スコープ（今回のPBI）
### 含まれるもの
- [x] ユーザーサービスの分離（第1フェーズ）
- [x] API Gatewayの構築
- [x] データベース分離（Users DB）
- [x] CI/CDパイプライン構築

### 含まれないもの（将来のPBI）
- [ ] 商品サービス分離（Phase 2）
- [ ] 注文サービス分離（Phase 3）
- [ ] 決済サービス分離（Phase 4）

## 移行計画（段階的移行）

### Week 1: インフラ準備
- [x] API Gateway構築（Kong使用）
- [x] ユーザーサービス用のインフラ準備
- [x] Users DBの複製（初期データコピー）

### Week 2: ユーザーサービス開発
- [x] ユーザーサービスの実装
- [x] API Gatewayとの統合
- [x] データ同期機構の実装（段階移行期間中）

### Week 3: 並行稼働・検証
- [x] Strangler Figパターンで段階移行
  - 読み取りAPIから順次切り替え
  - 書き込みAPIは最後に切り替え
- [x] モニタリング・ログ確認
- [x] パフォーマンス測定

### Week 4: 完全移行
- [x] 全APIをユーザーサービスに切り替え
- [x] モノリスからユーザー管理コード削除
- [x] データベース分離完了

## ROI分析
### 投資（コスト）
- **開発工数**: 4週間（エンジニア3名）
- **インフラコスト**: +月5万円（新サービス分）
- **合計投資**: 約300万円

### リターン（効果）
- **デプロイ時間短縮**: 1時間 → 10分（85%削減）
- **開発速度向上**: マージコンフリクト50%減
- **障害影響範囲**: 全体 → ユーザー機能のみ
- **スケーリング効率**: コスト30%削減

**投資回収期間**: 6ヶ月

## 受け入れ基準
### 機能要件
- [x] ユーザーサービスが独立して動作
- [x] API Gatewayでルーティング成功
- [x] 既存のユーザー機能が全て正常動作

### 非機能要件
- [x] レスポンスタイム: 現状と同等以上
- [x] 可用性: 99.9%維持
- [x] デプロイ時間: 10分以内

### ドキュメント
- [x] アーキテクチャ図更新
- [x] API仕様書作成
- [x] 運用手順書作成

## リスク管理
### リスク1: データ同期の不整合
- **軽減策**: 
  - 段階移行期間中、双方向同期を実装
  - データ整合性チェックツールを用意
- **ロールバック**: API Gatewayのルーティングをモノリスに戻す

### リスク2: パフォーマンス劣化
- **軽減策**: 
  - 事前に負荷テスト実施
  - CDNキャッシュ活用
- **ロールバック**: 即座に旧システムに戻せる

## テスト計画
- [x] 単体テスト: 各サービス80%カバレッジ
- [x] 統合テスト: サービス間通信
- [x] E2Eテスト: ユーザーフロー全体
- [x] 負荷テスト: 1000同時接続
- [x] カオステスト: 障害注入テスト

## モニタリング
- [x] APM導入（DataDog）
- [x] ログ集約（ELK Stack）
- [x] アラート設定
- [x] ダッシュボード作成

## 見積もり
- **ストーリーポイント**: 34ポイント（Epic）
- **期間**: 4週間
- **担当**: バックエンド2名、インフラ1名

## 関連PBI
- PBI-701: 商品サービス分離（Phase 2）
- PBI-702: 注文サービス分離（Phase 3）
```

---

### タイプ7: HOT - 緊急修正

#### 定義
24時間以内に対応が必要な緊急性の高い修正。

#### 特徴
- 🚨 緊急性が極めて高い（24時間以内）
- ⚡ 簡略化されたプロセス
- 📋 Phase 0（簡易）→3→4（簡易）→5を実施
- ⏱️ 数時間～24時間

#### HOT vs BUGの違い

| 観点 | BUG | HOT |
|------|-----|-----|
| **緊急度** | 通常 | 極めて高い |
| **対応期限** | 数日～1週間 | 24時間以内 |
| **影響度** | 限定的 | ビジネスクリティカル |
| **プロセス** | 通常フロー | 簡略化フロー |
| **例** | 表示崩れ | 決済機能停止 |

#### 必須記載項目

| 項目 | 説明 | 必須度 |
|------|------|--------|
| **緊急度の理由** | なぜ緊急対応が必要か | ✅ 必須 |
| **ビジネスインパクト** | 放置した場合の損失 | ✅ 必須 |
| **対応期限** | いつまでに修正が必要か | ✅ 必須 |
| **暫定対応** | 緊急回避策 | ⚠️ あれば記載 |

#### 作成テンプレート

```markdown
# PBI: [緊急対応内容] - 緊急修正

## タイプ
**HOT** (Hotfix)

## 緊急度
**Critical** - 即時対応が必要

## 問題の概要
[何が起きているか]

## ビジネスインパクト
- **影響を受けるユーザー**: 
- **損失**: 
- **対応期限**: 

## 再現手順
1. [ステップ1]
2. [ステップ2]

## 暫定対応（実施済み）
[すでに実施した応急処置]

## 恒久対応（このPBIで実施）
[根本的な修正内容]

## 受け入れ基準
- [ ] 問題が解消される
- [ ] 再現しない
- [ ] 監視アラート設定

## 見積もり
- **期間**: [X時間以内]
```

#### 実例: Good Example

```markdown
# PBI-999: 決済API障害 - 緊急修正

## タイプ
**HOT** (Hotfix)

## 緊急度
**Critical** - 即時対応が必要（4時間以内）

## 問題の概要
2025-11-17 14:00より、決済APIが全て500エラーを返し、
ユーザーが商品を購入できない状態。

**発生時刻**: 2025-11-17 14:00 JST
**検知**: モニタリングアラート + ユーザー問い合わせ急増
**現在の状況**: 全ての決済が失敗中

## ビジネスインパクト
- **影響を受けるユーザー**: 全購入ユーザー（100%）
- **損失**: 
  - 売上損失: 約100万円/時間
  - ブランドイメージ低下
  - カスタマーサポート負荷増大
- **対応期限**: 2025-11-17 18:00（4時間以内）

## 再現手順
1. 商品をカートに追加
2. 購入画面で決済情報入力
3. 「購入する」ボタンをクリック
4. 500 Internal Server Errorが表示される

## 原因
サードパーティ決済API（Stripe）への接続が、
API Key期限切れにより失敗している。

```
Error: Invalid API Key
at StripeClient.makeRequest (stripe.ts:45)
```

**根本原因**: 
- API Keyの有効期限が2025-11-17で切れていた
- 期限切れの事前通知を見逃していた

## 暫定対応（実施済み - 14:30）
✅ 一時的にサイトをメンテナンスモードに変更
✅ ユーザーに謝罪メッセージ表示
✅ カスタマーサポートに状況共有

## 恒久対応（このPBIで実施）
### 1. 即時対応（1時間以内）
- [x] 新しいAPI Keyを取得
- [x] 環境変数を更新
- [x] アプリケーション再起動
- [x] 決済機能の動作確認

### 2. 再発防止策（4時間以内）
- [x] API Key期限切れの監視アラート設定
- [x] 期限30日前に自動通知
- [x] ドキュメントに期限管理手順を追加

## 受け入れ基準
### 即時対応
- [x] 決済APIが正常に動作する
- [x] ユーザーが購入を完了できる
- [x] 500エラーが発生しない

### 再発防止
- [x] API Key期限切れ監視が動作する
- [x] アラートが正しく通知される
- [x] 運用手順書が更新されている

## テスト
- [x] 決済フロー全体のE2Eテスト
- [x] 各決済手段での動作確認
  - [x] クレジットカード
  - [x] PayPal
  - [x] コンビニ払い

## ロールバック計画
問題が解決しない場合:
1. 旧API Key（期限切れ）に戻す
2. Stripeサポートに問い合わせ
3. 代替決済手段の検討

## 対応タイムライン
- **14:00** - 障害発生・検知
- **14:10** - 原因特定
- **14:30** - 暫定対応（メンテナンスモード）
- **15:00** - 新API Key取得・適用（目標）
- **15:30** - 動作確認・本番復旧（目標）
- **18:00** - 再発防止策完了（目標）

## 事後対応（別PBI作成予定）
- [ ] 根本原因分析レポート作成
- [ ] 再発防止策の詳細レビュー
- [ ] 同様のリスクがないか全APIで調査

## 見積もり
- **ストーリーポイント**: 2ポイント
- **期間**: 4時間以内
- **担当**: バックエンドリード1名、DevOps 1名

## コミュニケーション
- ✅ 経営陣に状況報告済み
- ✅ カスタマーサポートに情報共有済み
- ✅ ユーザーにメンテナンス通知済み
- [ ] 復旧後、ユーザーに謝罪・報告メール送信
```

---

### タイプ8: POC - 実験的機能

#### 定義
技術検証・概念実証（Proof of Concept）のための実験的な実装。

#### 特徴
- 🔬 技術的な実現可能性を検証
- 📊 本番投入前の実験
- 📋 Phase 0（簡易）→3を実施（Phase 4以降は省略可）
- ⏱️ タイムボックス化（通常1-5日）

#### POCの目的

| 目的 | 説明 | 例 |
|------|------|-----|
| **技術検証** | 新技術が使えるか確認 | "GraphQL導入の検証" |
| **性能検証** | 目標性能が達成できるか | "リアルタイム通信の性能" |
| **実現可能性検証** | 要件が実現可能か | "AIによる画像認識精度" |
| **比較検討** | 複数技術の比較 | "React vs Vue.js" |

#### 必須記載項目

| 項目 | 説明 | 必須度 |
|------|------|--------|
| **検証目的** | 何を検証するか | ✅ 必須 |
| **成功基準** | どうなれば成功か | ✅ 必須 |
| **タイムボックス** | 期限 | ✅ 必須 |
| **成果物** | 何を作るか | ✅ 必須 |

#### 作成テンプレート

```markdown
# PBI: [POC] [検証内容] - 実験的機能

## タイプ
**POC** (Spike / Proof of Concept)

## 検証目的
[何を検証するか]

## ビジネス背景
[なぜこの検証が必要か]

## 検証項目
- [ ] 検証項目1
- [ ] 検証項目2
- [ ] 検証項目3

## 成功基準
- [ ] 基準1
- [ ] 基準2

## タイムボックス
**期限**: [X日]
**理由**: [なぜこの期限か]

## 成果物
- [ ] レポート
- [ ] プロトタイプ
- [ ] 技術選定書

## 次のアクション
- **成功した場合**: [本実装のPBI作成]
- **失敗した場合**: [代替案の検討]

## 見積もり
- **期間**: 
```

#### 実例: Good Example

```markdown
# PBI-850: [POC] WebSocketによるリアルタイム通知の検証

## タイプ
**POC** (Spike / Proof of Concept)

## 検証目的
WebSocketを使用したリアルタイム通知機能の技術的実現可能性を検証する。

具体的には:
1. WebSocket接続の安定性（1万同時接続）
2. メッセージ配信のレイテンシ（100ms以内）
3. 既存インフラとの互換性
4. 運用コスト

## ビジネス背景
現在のポーリング方式（30秒ごとに取得）では、
リアルタイム性が低く、ユーザー体験が悪い。

**ビジネス目標**:
- 通知の即時性向上（30秒 → 1秒以内）
- サーバー負荷削減（不要なリクエスト削減）
- ユーザーエンゲージメント向上

## 検証項目
### 1. 技術的実現可能性
- [x] WebSocket接続の確立
- [x] 認証・セッション管理
- [x] メッセージブロードキャスト

### 2. パフォーマンス
- [x] 1万同時接続の処理
- [x] メッセージ配信レイテンシ計測
- [x] サーバーリソース使用量

### 3. インフラ互換性
- [x] AWS Application Load Balancer対応
- [x] オートスケーリング対応
- [x] 既存モニタリングツール統合

### 4. 代替技術との比較
- [x] WebSocket vs Server-Sent Events (SSE)
- [x] Socket.io vs native WebSocket
- [x] コスト比較

## 成功基準
### 必須要件（Must Have）
- [x] 1万同時接続で安定動作
- [x] メッセージ配信レイテンシ < 100ms
- [x] CPU使用率 < 70%
- [x] メモリ使用量 < 4GB

### 望ましい要件（Nice to Have）
- [x] 3万同時接続対応
- [x] フェイルオーバー機構
- [x] メッセージ永続化

## タイムボックス
**期限**: 3日（2025-11-20まで）
**理由**: 
- 次スプリントで実装判断が必要
- 代替案検討の時間確保

## 検証環境
- **サーバー**: AWS EC2 (t3.medium)
- **クライアント**: 負荷テストツール（Artillery）
- **モニタリング**: CloudWatch

## 成果物
### 1. 技術検証レポート（2-3ページ）
- [x] 検証結果サマリー
- [x] パフォーマンスデータ
- [x] 技術的課題・制約
- [x] 推奨事項

### 2. プロトタイプ
- [x] WebSocketサーバー実装
- [x] シンプルなクライアント実装
- [x] 負荷テストスクリプト

### 3. 技術選定書
- [x] WebSocket vs SSE比較表
- [x] Socket.io vs native比較表
- [x] コスト試算

## 検証結果（完了後記入）

### パフォーマンス結果
```
同時接続数: 10,000
メッセージ配信レイテンシ:
  - 平均: 45ms ✅
  - 95%ile: 85ms ✅
  - 99%ile: 120ms ⚠️（目標100ms）

リソース使用量:
  - CPU: 55% ✅
  - メモリ: 3.2GB ✅
  - ネットワーク: 50Mbps
```

### 技術的課題
1. **スケーリング**: 
   - 1サーバーで1万接続まで
   - 3万接続には3サーバー必要
   
2. **セッション管理**: 
   - Redis導入が必須
   - コスト: +月3万円

3. **フェイルオーバー**: 
   - 接続中断時の再接続ロジック必要

### 推奨事項
✅ **WebSocket導入を推奨**
- パフォーマンス目標を達成
- ユーザー体験大幅改善
- サーバー負荷削減（ポーリング廃止）

**技術選択**: Socket.io（native WebSocketより簡単）

**追加コスト**: 
- Redis: 月3万円
- サーバー増強: 月5万円
- 合計: 月8万円（許容範囲内）

## 次のアクション
### 成功した場合（✅ 該当）
- [x] NFDとして本実装PBIを作成
  - PBI-851: WebSocket通知機能実装（フロントエンド）
  - PBI-852: WebSocket通知機能実装（バックエンド）
  
### 失敗した場合
- [ ] Server-Sent Events (SSE)で再検証
- [ ] ポーリング方式の最適化を検討

## 見積もり
- **ストーリーポイント**: 3ポイント
- **期間**: 3日（タイムボックス厳守）
- **担当**: バックエンド1名
```

---
## ユーザーストーリーの書き方

### ユーザーストーリーとは

ユーザーストーリーは、**ユーザーの視点**から機能を説明する短い文章です。

#### 基本フォーマット

```
【として】: [ユーザータイプ]
【〜したい】: [やりたいこと]
【なぜなら】: [理由・目的]
```

### 優れたユーザーストーリーの特徴

| 特徴 | 説明 | 例 |
|------|------|-----|
| **ユーザー中心** | 技術ではなくユーザー視点 | ❌"APIを追加" ✅"商品を検索したい" |
| **簡潔** | 1-2文で表現 | 詳細は受け入れ基準で |
| **理由明確** | WHYが含まれる | なぜその機能が必要か |
| **対話のきっかけ** | 詳細は対話で決める | 仕様を全て書かない |

### ユーザータイプの特定

#### 主要なユーザータイプ

| ユーザータイプ | 説明 | ストーリー例 |
|------------|------|------------|
| **エンドユーザー** | 実際にシステムを使う人 | "買い物客として" |
| **管理者** | システムを管理する人 | "店舗管理者として" |
| **開発者** | APIを使う開発者 | "API利用者として" |
| **システム** | 自動処理 | "システムとして" |

#### ペルソナの活用

より具体的なユーザー像を定義：

```markdown
## ペルソナ: 田中さん（40代、主婦）
- 週1回ネットショッピング
- スマホ中心、パソコンは苦手
- 時間がないので素早く買いたい
```

### 実例集

#### ✅ Good Example 1: ECサイト
```markdown
**として**: 買い物客
**〜したい**: キーワードで商品を検索したい
**なぜなら**: 欲しい商品を素早く見つけたいから
```

#### ✅ Good Example 2: 管理者機能
```markdown
**として**: 店舗管理者
**〜したい**: 在庫切れの商品を一覧で確認したい
**なぜなら**: 発注漏れを防ぎたいから
```

#### ✅ Good Example 3: システム機能
```markdown
**として**: システム
**〜したい**: 毎日深夜1時に在庫データを同期したい
**なぜなら**: 翌朝の営業開始時に最新データを提供するため
```

#### ❌ Bad Example 1: 技術中心
```markdown
**として**: 開発者
**〜したい**: ElasticsearchのAPIを実装したい
**なぜなら**: 検索機能が必要だから

問題点:
- ユーザー視点ではなく技術視点
- エンドユーザーの価値が不明
```

改善版:
```markdown
**として**: 買い物客
**〜したい**: 商品名や説明文から商品を検索したい
**なぜなら**: 欲しい商品を素早く見つけたいから

技術的補足:
- Elasticsearchを使用して実装予定
```

#### ❌ Bad Example 2: 詳細すぎる
```markdown
**として**: ユーザー
**〜したい**: React Hooksを使った検索フォームで、
入力値をdebounceし、Elasticsearchに送信して
結果を非同期で取得し、ページネーションで表示したい
**なぜなら**: 検索したいから

問題点:
- 実装詳細を含みすぎ
- 交渉の余地がない
```

改善版:
```markdown
**として**: 買い物客
**〜したい**: キーワードで商品を検索し、結果を見たい
**なぜなら**: 欲しい商品を素早く見つけたいから

技術的要件は受け入れ基準で定義
```

### PBIタイプ別のユーザーストーリー

#### NFD（新規機能開発）の場合
```markdown
**として**: [ユーザータイプ]
**〜したい**: [新しい価値・体験]
**なぜなら**: [達成したい目的]
```

#### ENH（既存機能改修）の場合
```markdown
**として**: [ユーザータイプ]
**〜したい**: [現状の改善]
**なぜなら**: [現状の不満・課題]
```

#### BUG（バグ修正）の場合
```markdown
ユーザーストーリーは不要
→ 再現手順と期待動作を明確に記載
```

#### REF（リファクタリング）の場合
```markdown
**として**: 開発チーム
**〜したい**: [コードの改善]
**なぜなら**: [保守性・拡張性向上]
```

---

## 受け入れ基準（Acceptance Criteria）の定義方法

### 受け入れ基準とは

**受け入れ基準**は、PBIが「完了」と判断される具体的な条件です。

#### 基本原則
- ✅ **テスト可能**: 客観的に検証できる
- ✅ **明確**: 曖昧さがない
- ✅ **完全**: 全ての要件を網羅
- ✅ **独立**: 他の条件と重複しない

### 受け入れ基準の書き方

#### フォーマット1: チェックリスト形式（推奨）

```markdown
## 受け入れ基準
- [ ] 条件1が満たされる
- [ ] 条件2が満たされる
- [ ] 条件3が満たされる
```

#### フォーマット2: Given-When-Then形式

```markdown
## 受け入れ基準

### シナリオ1: 正常系
**Given** (前提条件): ユーザーがログイン済み
**When** (操作): 検索ボックスに「laptop」と入力
**Then** (期待結果): 関連商品が表示される

### シナリオ2: 異常系
**Given**: ユーザーがログイン済み
**When**: 存在しないキーワード「xyz123」を入力
**Then**: 「該当する商品が見つかりません」と表示される
```

### 受け入れ基準の分類

#### 1. 機能要件（Functional Requirements）

```markdown
## 機能要件
- [ ] ユーザーが商品を検索できる
- [ ] 検索結果が一覧表示される
- [ ] 各商品に画像・価格・名前が表示される
- [ ] ページネーション機能がある（20件/ページ）
```

#### 2. 非機能要件（Non-Functional Requirements）

```markdown
## 非機能要件
### パフォーマンス
- [ ] 検索結果が3秒以内に表示される
- [ ] 1000件のデータで動作する

### ユーザビリティ
- [ ] モバイルデバイスで操作しやすい
- [ ] キーボードショートカット対応（Enter で検索）

### セキュリティ
- [ ] SQLインジェクション対策済み
- [ ] XSS対策済み

### アクセシビリティ
- [ ] スクリーンリーダー対応
- [ ] キーボードのみで操作可能
```

#### 3. テスト要件

```markdown
## テスト要件
- [ ] 単体テスト: カバレッジ80%以上
- [ ] 統合テスト: API全エンドポイント
- [ ] E2Eテスト: ユーザーフロー全体
- [ ] パフォーマンステスト: 100同時ユーザー
```

#### 4. ドキュメント要件

```markdown
## ドキュメント要件
- [ ] API仕様書更新
- [ ] README更新
- [ ] ユーザーマニュアル作成
```

### 実例: 受け入れ基準の完全版

```markdown
# PBI-300: 商品検索機能

## 受け入れ基準

### 機能要件
#### 検索機能
- [x] ユーザーが検索ボックスにキーワードを入力できる
- [x] 「検索」ボタンをクリックで検索実行
- [x] Enterキーでも検索実行可能

#### 検索結果表示
- [x] 検索結果が一覧表示される
- [x] 各商品カードに以下が表示される:
  - [x] 商品画像（200x200px）
  - [x] 商品名
  - [x] 価格
  - [x] 在庫状況（在庫あり/なし）
- [x] 20件/ページでページネーション

#### エッジケース
- [x] 検索結果が0件の場合、「該当する商品が見つかりません」と表示
- [x] キーワードが空の場合、全商品を表示
- [x] 検索中はローディングインジケーターを表示

### 非機能要件
#### パフォーマンス
- [x] 検索結果が3秒以内に表示される（95%ile）
- [x] 10,000件のデータで正常動作
- [x] 100同時ユーザーで動作

#### ユーザビリティ
- [x] デスクトップ・タブレット・スマホで最適表示
- [x] キーボードのみで操作可能
- [x] 検索履歴が保存される（直近5件）

#### セキュリティ
- [x] SQLインジェクション対策済み
- [x] XSS対策済み（サニタイズ実装）
- [x] レート制限: 100リクエスト/分/ユーザー

#### アクセシビリティ
- [x] WCAG 2.1 Level AA準拠
- [x] スクリーンリーダー対応
- [x] フォーカスインジケーター表示

### API要件
- [x] GET /api/products/search?q={keyword}&page={page}
- [x] レスポンス形式: JSON
- [x] ステータスコード: 
  - [x] 200: 成功
  - [x] 400: 不正なパラメータ
  - [x] 429: レート制限超過
  - [x] 500: サーバーエラー

### テスト要件
- [x] 単体テスト: 
  - [x] SearchService: 90%カバレッジ
  - [x] SearchController: 80%カバレッジ
- [x] 統合テスト: 
  - [x] API正常系・異常系
- [x] E2Eテスト: 
  - [x] 検索フロー全体
  - [x] ページネーション
  - [x] エラーハンドリング
- [x] パフォーマンステスト: 
  - [x] 100同時ユーザー
  - [x] 負荷テストレポート作成

### ドキュメント要件
- [x] API仕様書更新（OpenAPI 3.0）
- [x] README更新（検索機能の説明）
- [x] ユーザーマニュアル作成
```

### よくある失敗パターン

#### ❌ Bad Example 1: 曖昧な表現
```markdown
- [ ] 使いやすいUIを提供する ← 測定不可能
- [ ] パフォーマンスを改善する ← 基準なし
- [ ] バグを修正する ← 範囲不明確
```

#### ✅ Good Example: 具体的な表現
```markdown
- [x] 検索結果が3秒以内に表示される
- [x] モバイルで親指で操作しやすいボタンサイズ（44x44px以上）
- [x] #BUG-123で報告された決済エラーが発生しない
```

---

## 技術的制約・前提条件の記載

### 技術的制約とは

PBIの実装において守るべき**技術的なルール・制約**です。

### 記載すべき情報

#### 1. 技術スタック

```markdown
## 技術的制約
### 使用技術
- **フロントエンド**: React 18, TypeScript 5
- **バックエンド**: Node.js 18, Express
- **データベース**: PostgreSQL 15
- **キャッシュ**: Redis 7
```

#### 2. 既存システムとの連携

```markdown
### 既存システム連携
- **ユーザー認証**: 既存のJWT認証を使用
- **商品データ**: 既存の`products`テーブルを参照
- **API Gateway**: 既存のKong経由でアクセス
```

#### 3. パフォーマンス要件

```markdown
### パフォーマンス要件
- **レスポンスタイム**: 95%ile < 3秒
- **同時接続数**: 1,000ユーザー
- **データ量**: 100万件まで対応
```

#### 4. セキュリティ要件

```markdown
### セキュリティ要件
- **認証**: OAuth 2.0必須
- **データ暗号化**: TLS 1.3
- **個人情報**: GDPR準拠
```

#### 5. 環境・インフラ

```markdown
### 環境・インフラ
- **クラウド**: AWS
- **リージョン**: ap-northeast-1（東京）
- **CI/CD**: GitHub Actions
```

### 前提条件の記載

```markdown
## 前提条件
### 完了している必要があるPBI
- [x] PBI-100: ユーザー認証基盤（完了）
- [x] PBI-150: データベース移行（完了）
- [ ] PBI-200: API Gateway構築（進行中）← ブロッカー

### 必要なリソース
- [ ] AWSアカウントへのアクセス権
- [ ] 外部APIキー取得（Stripe）
- [ ] デザインモックアップ（Figma）

### 技術的依存
- Elasticsearch 8.x がインストール済み
- Redis Clusterが動作中
```

---

## 見積もりとポイント付け

### ストーリーポイントとは

**ストーリーポイント**は、PBIの作業量を相対的に表す単位です。

#### 時間見積もりとの違い

| 時間見積もり | ストーリーポイント |
|------------|------------------|
| 絶対的（3日） | 相対的（5ポイント） |
| 個人差が大きい | チーム平均 |
| 見積もりミスが目立つ | 長期では正確 |

### フィボナッチ数列の使用

**推奨スケール**: 1, 2, 3, 5, 8, 13, 21, 40, 100

| ポイント | 難易度 | 期間目安 | 例 |
|---------|-------|---------|-----|
| **1** | 非常に簡単 | 1-2時間 | 文言修正、設定変更 |
| **2** | 簡単 | 半日 | 簡単なAPI追加 |
| **3** | 小規模 | 1日 | 1画面の実装 |
| **5** | 中規模 | 2-3日 | CRUD API一式 |
| **8** | やや大規模 | 4-5日 | 複雑な機能 |
| **13** | 大規模 | 1-2週間 | 分割を検討 |
| **21+** | 超大規模 | 2週間以上 | Epic化して分割 |

### 見積もりの基準

#### 考慮すべき要素

1. **複雑度**: ロジックの複雑さ
2. **不確実性**: 未知の技術・要件
3. **作業量**: 実装・テスト・ドキュメント
4. **依存関係**: 他PBIとの依存
5. **リスク**: 潜在的な問題

#### プランニングポーカー

チーム全員で見積もる手法：

```
1. PBIの説明を聞く
2. 各自がポイントカードを選ぶ
3. 一斉にカードを公開
4. 差異がある場合、議論
5. 合意するまで繰り返す
```

### 実例: 見積もりの根拠

#### Example 1: 3ポイント
```markdown
## 見積もり
**ストーリーポイント**: 3ポイント
**期間**: 1日

**根拠**:
- シンプルなCRUD API（既存パターン踏襲）
- データモデルは既存テーブル活用
- 単体テスト・統合テストのみ（E2E不要）
- 不確実性: 低
```

#### Example 2: 8ポイント
```markdown
## 見積もり
**ストーリーポイント**: 8ポイント
**期間**: 5日

**根拠**:
- 複雑なビジネスロジック（在庫引き当て）
- 複数テーブルのトランザクション処理
- パフォーマンスチューニング必要
- E2Eテスト含む
- 不確実性: 中（在庫ロジック未経験）
```

#### Example 3: 13ポイント（分割検討）
```markdown
## 見積もり
**ストーリーポイント**: 13ポイント
**期間**: 2週間

**根拠**:
- 新しい技術スタック（WebSocket初）
- 複数サービスに跨る変更
- 負荷テスト必須
- ドキュメント大量
- 不確実性: 高

**推奨**: 
分割して5ポイント+8ポイントに
```

---

## チェックリスト：レビュー前の確認事項

### PBI作成完了時のチェックリスト

#### 基本情報
- [ ] タイトルが明確で検索しやすい
- [ ] PBIタイプが正しく設定されている（NPI/NFD/ENH/BUG/REF/ARC/HOT/POC）
- [ ] 優先度が設定されている（High/Medium/Low）
- [ ] 担当者・担当チームが明確

#### 内容の質
- [ ] ユーザーストーリーが記載されている（該当タイプの場合）
- [ ] ビジネス価値が明確に説明されている
- [ ] 受け入れ基準が具体的で検証可能
- [ ] 技術的制約・前提条件が明記されている
- [ ] 依存関係が特定されている

#### INVEST原則チェック
- [ ] **I**ndependent: 他のPBIから独立している
- [ ] **N**egotiable: 実装方法に柔軟性がある
- [ ] **V**aluable: ステークホルダーに価値を提供
- [ ] **E**stimable: チームが見積もり可能
- [ ] **S**mall: 1スプリント以内に完了できる
- [ ] **T**estable: 客観的にテスト可能

#### 技術情報
- [ ] 使用技術・ライブラリが明記されている
- [ ] API仕様が定義されている（該当する場合）
- [ ] データモデル変更が記載されている（該当する場合）
- [ ] セキュリティ要件が確認されている
- [ ] パフォーマンス要件が定義されている

#### テスト・品質
- [ ] テスト要件が明確（単体/統合/E2E）
- [ ] テストカバレッジ目標が設定されている
- [ ] 非機能要件が定義されている
- [ ] リスクとその軽減策が記載されている

#### ドキュメント
- [ ] 必要なドキュメント更新が記載されている
- [ ] UI/UXモックアップがある（該当する場合）
- [ ] アーキテクチャ図がある（該当する場合）

#### 見積もり
- [ ] ストーリーポイントが設定されている
- [ ] 見積もりの根拠が説明されている
- [ ] 期間目安が記載されている

#### レビュー
- [ ] プロダクトオーナーのレビュー済み
- [ ] 技術リードのレビュー済み
- [ ] チームメンバーの質問に回答済み

---
## よくある失敗パターンと対策

### 失敗パターン1: スコープが大きすぎる

#### 問題
```markdown
# PBI-999: ECサイト全体の構築

## 内容
ECサイトを構築する

## 見積もり
不明
```

#### 問題点
- ❌ スコープが広すぎて見積もり不可能
- ❌ 1スプリントで完了不可能
- ❌ 進捗が測定できない

#### 対策
**Epic化して分割**:
```markdown
Epic: ECサイト構築
├─ PBI-001: ユーザー登録・ログイン機能（5P）
├─ PBI-002: 商品一覧・検索機能（8P）
├─ PBI-003: カート機能（5P）
├─ PBI-004: 決済機能（13P → さらに分割）
└─ PBI-005: 注文履歴機能（5P）
```

---

### 失敗パターン2: 受け入れ基準が曖昧

#### 問題
```markdown
## 受け入れ基準
- [ ] 使いやすい画面を作る
- [ ] パフォーマンスを改善する
- [ ] バグを修正する
```

#### 問題点
- ❌ 主観的で測定不可能
- ❌ 完了の判断ができない
- ❌ テスト方法が不明

#### 対策
**具体的・測定可能な基準**:
```markdown
## 受け入れ基準
- [x] 検索結果が3秒以内に表示される（95%ile）
- [x] モバイルでボタンサイズ44x44px以上
- [x] #BUG-123の決済エラーが再現しない
```

---

### 失敗パターン3: 技術的な詳細を含みすぎる

#### 問題
```markdown
# PBI-500: 商品検索機能

## 内容
ElasticsearchのFuzzy Queryを使用し、
React HooksでuseStateとuseEffectを実装し、
debounceを500msで設定して...
```

#### 問題点
- ❌ 実装方法が固定されすぎ
- ❌ 技術的な改善提案ができない
- ❌ ユーザー価値が見えない

#### 対策
**WHATとWHYを重視、HOWは柔軟に**:
```markdown
# PBI-500: 商品検索機能

## ユーザーストーリー
**として**: 買い物客
**〜したい**: キーワードで商品を検索したい
**なぜなら**: 欲しい商品を素早く見つけたいから

## 受け入れ基準
- [x] キーワード入力で商品検索
- [x] 検索結果が3秒以内に表示
- [x] 曖昧検索対応（typo許容）

## 技術的補足
- Elasticsearch使用推奨（既存インフラ）
- 実装方法は開発チームに委ねる
```

---

### 失敗パターン4: ビジネス価値が不明

#### 問題
```markdown
# PBI-600: データベースインデックス追加

## 内容
productsテーブルにインデックスを追加する
```

#### 問題点
- ❌ なぜ必要なのか不明
- ❌ 優先順位が判断できない
- ❌ ステークホルダーが理解できない

#### 対策
**ビジネス価値を明確に**:
```markdown
# PBI-600: 商品検索パフォーマンス改善

## ビジネス背景
現在、商品検索に平均8秒かかっており、
ユーザーの30%が検索を中断している。

## ビジネス価値
- 検索時間: 8秒 → 2秒に短縮
- 直帰率: 30% → 10%に改善
- 売上影響: 月間50万円の機会損失を回避

## 技術的実施内容
- productsテーブルにインデックス追加
- クエリ最適化
```

---

### 失敗パターン5: 依存関係が考慮されていない

#### 問題
```markdown
# PBI-700: 決済機能実装

## 前提条件
特になし
```

実際には、ユーザー認証、カート機能、商品マスタが必要。

#### 問題点
- ❌ 着手できない
- ❌ スケジュール遅延
- ❌ チームの作業がブロックされる

#### 対策
**依存関係を明確化**:
```markdown
# PBI-700: 決済機能実装

## 依存関係
### ブロッカー（完了必須）
- [x] PBI-100: ユーザー認証基盤（完了）
- [ ] PBI-650: カート機能（進行中）← ブロッカー
- [x] PBI-200: 商品マスタ（完了）

### 外部依存
- [ ] Stripe APIキー取得（営業部に依頼中）
- [ ] 決済フロー承認（法務部レビュー待ち）

## リスク
- PBI-650が遅延した場合、本PBIも遅延
- 軽減策: PBI-650の進捗を毎日確認
```

---

### 失敗パターン6: テスト要件が欠如

#### 問題
```markdown
# PBI-800: 新規API実装

## 受け入れ基準
- [ ] APIが動作する
```

#### 問題点
- ❌ どこまでテストするか不明
- ❌ 品質基準がない
- ❌ 本番リリース後にバグ頻発

#### 対策
**テスト要件を明確化**:
```markdown
# PBI-800: 新規API実装

## 受け入れ基準
### 機能要件
- [x] POST /api/orders でAPIが動作

### テスト要件
- [x] 単体テスト: カバレッジ80%以上
- [x] 統合テスト: 
  - [x] 正常系: 注文作成成功
  - [x] 異常系: バリデーションエラー
  - [x] 異常系: 在庫不足エラー
- [x] E2Eテスト: ユーザーフロー全体
- [x] 負荷テスト: 100同時リクエスト

### コードレビュー
- [x] セキュリティレビュー完了
- [x] パフォーマンスレビュー完了
```

---

### 失敗パターン7: 非機能要件の見落とし

#### 問題
```markdown
# PBI-900: ファイルアップロード機能

## 受け入れ基準
- [ ] ファイルをアップロードできる
```

#### 問題点
- ❌ ファイルサイズ制限なし → サーバーダウン
- ❌ セキュリティ考慮なし → 脆弱性
- ❌ エラーハンドリングなし → ユーザー混乱

#### 対策
**非機能要件を含める**:
```markdown
# PBI-900: ファイルアップロード機能

## 受け入れ基準
### 機能要件
- [x] ユーザーがファイルをアップロードできる

### 非機能要件
#### セキュリティ
- [x] ファイルタイプ制限（画像のみ: jpg, png, gif）
- [x] ファイルサイズ制限（最大10MB）
- [x] ウイルススキャン実施
- [x] アップロード先は専用ストレージ（S3）

#### パフォーマンス
- [x] アップロード時間: 10MB/5秒以内
- [x] プログレスバー表示

#### エラーハンドリング
- [x] ファイルサイズ超過時: エラーメッセージ表示
- [x] 不正なファイルタイプ: エラーメッセージ表示
- [x] ネットワークエラー: リトライ機能

#### ユーザビリティ
- [x] ドラッグ&ドロップ対応
- [x] アップロード中はキャンセル可能
- [x] モバイルでも操作しやすい
```

---

## 実例集（Good/Bad Examples）

### ケース1: 新規機能開発（NFD）

#### ❌ Bad Example
```markdown
# PBI-X01: お気に入り機能

お気に入り機能を追加する。

見積もり: 不明
```

#### ✅ Good Example
```markdown
# PBI-205: お気に入り商品登録機能

## タイプ
NFD (New Feature Development)

## ユーザーストーリー
**として**: 買い物客
**〜したい**: 気になる商品をお気に入りに登録して後で見返したい
**なぜなら**: すぐに購入を決められない商品を記録しておき、比較検討したいから

## ビジネス価値
- リピート率15%向上（類似サイトの実績）
- 平均購入単価10%向上（比較検討による）

## 受け入れ基準
- [x] 商品詳細画面に「お気に入り」ボタン表示
- [x] ボタンクリックでお気に入り追加/削除
- [x] マイページにお気に入り一覧表示
- [x] お気に入り上限100件

## 技術的考慮事項
- 新テーブル`favorites`作成
- API: POST/DELETE /api/favorites

## 見積もり
5ポイント（3日）
```

---

### ケース2: バグ修正（BUG）

#### ❌ Bad Example
```markdown
# PBI-X02: ログインバグ

ログインができない。

直す。
```

#### ✅ Good Example
```markdown
# PBI-450: ログイン時にセッションが即座に切れるバグ

## タイプ
BUG (Bug Fix)

## 重大度
Critical - ユーザーがログインできない

## 再現手順
1. ログイン画面でメールアドレス・パスワード入力
2. 「ログイン」ボタンクリック
3. ログイン成功メッセージ表示
4. 3秒後、自動的にログアウトされる

## 期待される動作
ログイン後、セッションが24時間維持される。

## 実際の動作
3秒でセッションが切れる。

## 影響範囲
- 全ユーザー（100%）
- 発生頻度: 毎回（100%再現）

## 原因
Cookie domainの設定ミス

## 受け入れ基準
- [x] ログイン後、24時間セッション維持
- [x] 再現手順でバグが発生しない
- [x] 単体テスト追加

## 見積もり
2ポイント（2時間）
```

---

### ケース3: リファクタリング（REF）

#### ❌ Bad Example
```markdown
# PBI-X03: コード整理

コードをきれいにする。
```

#### ✅ Good Example
```markdown
# PBI-520: UserServiceのリファクタリング

## タイプ
REF (Refactoring)

## リファクタリング対象
`src/services/UserService.ts`（850行）

## 現在の問題
- 1クラスが850行と長大
- createUserメソッドが200行
- 重複コード5箇所以上
- Cyclomatic Complexity: 25

## 改善内容
- クラス分割（3クラスに）
- メソッド分割（50行以下に）
- 共通処理抽出

## 受け入れ基準
- [x] 全既存テストが通る
- [x] ファイル行数: 300行以下
- [x] Cyclomatic Complexity: 10以下
- [x] Code Duplication: 5%以下

## 見積もり
5ポイント（3日）
```

---

### ケース4: 緊急修正（HOT）

#### ❌ Bad Example
```markdown
# PBI-X04: 緊急対応

決済が動かない。早く直す。
```

#### ✅ Good Example
```markdown
# PBI-999: 決済API障害 - 緊急修正

## タイプ
HOT (Hotfix)

## 緊急度
Critical - 4時間以内対応必須

## 問題の概要
2025-11-17 14:00より決済API全て500エラー。
ユーザーが購入不可。

## ビジネスインパクト
- 売上損失: 100万円/時間
- 影響ユーザー: 全員（100%）
- 対応期限: 18:00（4時間以内）

## 原因
Stripe API Key期限切れ

## 暫定対応（実施済み）
✅ メンテナンスモード表示

## 恒久対応
- [x] 新API Key取得・設定
- [x] 期限切れ監視アラート設定

## 見積もり
2ポイント（4時間以内）
```

---

## AIエージェント向けガイダンス

### このセクションの目的

自律的AIエージェント（Devin、Cursor等）が、このガイドを効果的に活用し、
高品質なPBIを作成できるようにするための指針です。

---

### 1. PBI作成時の推論フロー

AIエージェントは、以下の順序でPBIを作成してください：

#### Step 1: タイプ判定
```
入力: PBIの概要説明
↓
[PBI-TYPE-JUDGMENT-GUIDE.md]を参照
↓
出力: PBIタイプ（NPI/NFD/ENH/BUG/REF/ARC/HOT/POC）
```

#### Step 2: テンプレート選択
```
PBIタイプに応じた作成テンプレートを選択
↓
[本ガイドのタイプ別作成ガイドライン]を参照
```

#### Step 3: INVEST原則チェック
```
作成したPBIが以下を満たすか確認:
- Independent (独立性)
- Negotiable (交渉可能性)
- Valuable (価値)
- Estimable (見積もり可能)
- Small (適切なサイズ)
- Testable (テスト可能)
```

#### Step 4: 完成度チェック
```
[チェックリスト：レビュー前の確認事項]で検証
↓
不足項目があれば補完
```

---

### 2. AIエージェント向けPBI作成プロンプト

以下のプロンプトをAIエージェントの内部処理で使用してください：

```
# PBI作成プロンプト

## 入力情報
- ユーザーからの要求: {user_request}
- プロジェクトコンテキスト: {project_context}

## タスク
以下の手順でPBIを作成してください：

### 1. タイプ判定
[PBI-TYPE-JUDGMENT-GUIDE.md]の判定基準に基づき、
8つのタイプから最適なものを選択してください。

判定理由も明記してください。

### 2. ユーザーストーリー作成（該当タイプの場合）
- 誰のため（として）
- 何をしたい（〜したい）
- なぜ（なぜなら）

を明確にしてください。

### 3. 受け入れ基準定義
- 機能要件
- 非機能要件
- テスト要件
- ドキュメント要件

を具体的・測定可能に定義してください。

### 4. 技術的考慮事項
- 使用技術
- 既存システムとの連携
- パフォーマンス要件
- セキュリティ要件

を明記してください。

### 5. 見積もり
- ストーリーポイント
- 期間目安
- 見積もり根拠

を提供してください。

### 6. INVEST原則チェック
作成したPBIが全ての原則を満たすか確認してください。

### 7. 出力
作成したPBIをMarkdown形式で出力してください。
```

---

### 3. よくあるAI判断ミスと対策

#### ミス1: タイプ判定の誤り

**問題**:
「パフォーマンス改善」を常にENHと判定してしまう。

**対策**:
```
パフォーマンス改善の判定フロー:
1. 機能追加がある？
   YES → ENH
   NO → 次へ
   
2. アーキテクチャ変更がある？
   YES → ARC
   NO → 次へ
   
3. コードのみの改善？
   YES → REF
```

#### ミス2: 受け入れ基準が曖昧

**問題**:
「使いやすい」「速い」など測定不可能な表現を使用。

**対策**:
```
曖昧な表現検出パターン:
- "使いやすい" → "ボタンサイズ44x44px以上"
- "速い" → "レスポンスタイム3秒以内"
- "安定" → "稼働率99.9%以上"

全ての受け入れ基準に数値・測定方法を含めてください。
```

#### ミス3: スコープが大きすぎる

**問題**:
13ポイント以上のPBIを作成してしまう。

**対策**:
```
見積もりチェック:
1. 8ポイント以上？
   → 分割を提案
   
2. 13ポイント以上？
   → 必ず分割（Epic化）
   
分割方法:
- 機能別分割
- レイヤー別分割（UI/API/DB）
- 段階リリース（MVP → 拡張）
```

---

### 4. AI自己チェックリスト

PBI作成後、以下を自動チェックしてください：

```yaml
自己チェックリスト:
  タイプ判定:
    - [ ] 8つのタイプから選択されている
    - [ ] 判定根拠が明確
  
  ユーザーストーリー:
    - [ ] 「として」「〜したい」「なぜなら」が揃っている
    - [ ] ユーザー視点である（技術視点でない）
  
  受け入れ基準:
    - [ ] 全て測定可能
    - [ ] 曖昧な表現がない（"使いやすい"等）
    - [ ] テスト方法が明確
  
  技術情報:
    - [ ] 使用技術が明記されている
    - [ ] セキュリティ要件が含まれている
    - [ ] パフォーマンス基準がある
  
  見積もり:
    - [ ] 8ポイント以下（それ以上なら分割提案）
    - [ ] 見積もり根拠が説明されている
  
  INVEST原則:
    - [ ] 独立性: 他PBIから独立
    - [ ] 交渉可能性: 実装方法が固定されていない
    - [ ] 価値: ビジネス価値が明確
    - [ ] 見積もり可能: 技術情報が十分
    - [ ] 小さい: 1スプリント以内
    - [ ] テスト可能: 検証方法が明確
```

---

### 5. AIによる自動改善提案

PBI作成後、AIは以下の改善提案を行ってください：

```
改善提案プロンプト:

作成したPBIを分析し、以下の観点で改善提案を行ってください:

1. **明確性の改善**
   - 曖昧な表現を具体化
   - 数値基準の追加

2. **完全性の改善**
   - 不足している受け入れ基準
   - 見落としている非機能要件

3. **分割の提案**
   - スコープが大きすぎる場合の分割案

4. **リスクの指摘**
   - 潜在的なリスク
   - 軽減策の提案

5. **ベストプラクティス適用**
   - 類似PBIの成功パターン適用
```

---

## 関連ドキュメント

### 必読ドキュメント

| ドキュメント名 | 目的 | リンク |
|-------------|------|-------|
| **PBI-TYPE-JUDGMENT-GUIDE.md** | PBIタイプの判定方法 | [Link](../core/PBI-TYPE-JUDGMENT-GUIDE.md) |
| **AI-MASTER-WORKFLOW-GUIDE.md** | 開発ワークフロー全体 | [Link](../../02-ai-guides/AI-MASTER-WORKFLOW-GUIDE.md) |
| **PBI-TEMPLATE-CATALOG.md** | テンプレート集 | [Link](../templates-prompts/PBI-TEMPLATE-CATALOG.md)（作成予定） |

### 参考ドキュメント

| ドキュメント名 | 目的 | リンク |
|-------------|------|-------|
| **PBI-SPLITTING-GUIDE.md** | PBI分割方法 | [Link](../guides/PBI-SPLITTING-GUIDE.md)（作成予定） |
| **PBI-JIRA-MANAGEMENT-GUIDE.md** | JIRA運用方法 | [Link](../guides/PBI-JIRA-MANAGEMENT-GUIDE.md)（作成予定） |
| **PBI-PRIORITIZATION-GUIDE.md** | 優先順位付け | [Link](../core/PBI-PRIORITIZATION-GUIDE.md)（作成予定） |
| **AI-PRE-WORK-CHECKLIST.md** | PBI受領時チェック | [Link](../../02-ai-guides/AI-PRE-WORK-CHECKLIST.md) |

### 関連する標準ドキュメント

- **01-strategy-pbi-matrix.md**: PBIタイプ別テスト要件
- **AI-DELIVERABLE-REFERENCE-GUIDE.md**: PBIタイプ別成果物参照

---

## まとめ

### 重要ポイント

1. **INVEST原則を守る**: 高品質なPBIの基盤
2. **ユーザー価値を明確に**: なぜ必要かを説明
3. **具体的・測定可能に**: 曖昧な表現を避ける
4. **適切なサイズに**: 8ポイント以下を目指す
5. **タイプ別ガイドに従う**: 8つのタイプそれぞれに最適な書き方

### 次のステップ

1. **テンプレート活用**: [PBI-TEMPLATE-CATALOG.md](../templates-prompts/PBI-TEMPLATE-CATALOG.md)を参照（作成予定）
2. **実例から学ぶ**: 過去の優れたPBIを参考にする
3. **チームレビュー**: 作成したPBIをチームでレビュー
4. **継続的改善**: フィードバックを元に改善

---

**Document Version**: 1.0.0  
**Last Updated**: 2025-11-17  
**Maintained By**: Engineering Leadership Team
