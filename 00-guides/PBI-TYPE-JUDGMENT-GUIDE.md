# PBIタイプ判定ガイド (PBI Type Judgment Guide)

## 📋 ドキュメント情報

| 項目 | 内容 |
|------|------|
| **ドキュメント名** | PBIタイプ判定ガイド |
| **バージョン** | 1.0.0 |
| **最終更新日** | 2025-11-14 |
| **対象読者** | 自律的AIエージェント、開発チーム、プロジェクトマネージャー |
| **目的** | PBI（Product Backlog Item）のタイプを正確に判定し、適切な開発プロセスを選択するための詳細ガイド |

---

## 📖 目次

1. [はじめに](#はじめに)
2. [8つのPBIタイプ概要](#8つのpbiタイプ概要)
3. [各タイプの詳細判定基準](#各タイプの詳細判定基準)
4. [境界ケース判定ルール](#境界ケース判定ルール)
5. [判定フローチャート](#判定フローチャート)
6. [AIエージェント向け判定プロンプト](#aiエージェント向け判定プロンプト)
7. [よくある質問](#よくある質問)

---

## はじめに

### このガイドの目的

PBIのタイプを正確に判定することは、適切な開発プロセスとPhaseの選択に不可欠です。このガイドは、以下を提供します：

- **明確な判定基準**: 各PBIタイプの具体的な判定基準
- **境界ケースの解決**: 曖昧な状況での判定ルール
- **体系的な判定手順**: ステップバイステップのフローチャート
- **AI支援**: 自律的AIエージェントが使用できる判定プロンプト

### 対象となるPBIタイプ

本ガイドでは、以下の**8つのPBIタイプ**を定義しています：

1. **NPI** - 新規プロジェクト立ち上げ (New Project Initialization)
2. **NFD** - 新規機能開発 (New Feature Development)
3. **ENH** - 既存機能追加・改修 (Enhancement / Modification)
4. **BUG** - バグ修正 (Bug Fix)
5. **REF** - リファクタリング (Refactoring)
6. **ARC** - 設計変更・アーキテクチャ改善 (Architecture Improvement)
7. **HOT** - 緊急修正 (Hotfix)
8. **POC** - 実験的機能 (Spike / POC)

---

## 8つのPBIタイプ概要

### タイプ一覧表

| ID | タイプ名 | 略称 | Phase経路 | 特徴 |
|----|---------|------|-----------|------|
| 1 | 新規プロジェクト立ち上げ | **NPI** | 0→1→2→3→4→5→6 | プロジェクト全体の初期構築、全Phase実施 |
| 2 | 新規機能開発 | **NFD** | 0→2→3→4→5 | 既存プロジェクトへの新機能追加、新ユースケース |
| 3 | 既存機能追加・改修 | **ENH** | 0→2→3→4→5 | 既存機能の拡張・改善、ユースケース変更なし |
| 4 | バグ修正 | **BUG** | (0簡易版)→3→4 | 既存機能の不具合修正、仕様との乖離解消 |
| 5 | リファクタリング | **REF** | 0→3→4 | コード品質改善、機能変更なし |
| 6 | 設計変更・アーキテクチャ改善 | **ARC** | 0→2→3→4→5 | 根本的な設計・アーキテクチャの見直し |
| 7 | 緊急修正 | **HOT** | 簡易0→3→簡易4→5 | 24時間以内の対応が必要な緊急性の高い修正 |
| 8 | 実験的機能 | **POC** | 簡易0→3 | 技術検証、実験、概念実証 |

### タイプ選択の重要性

適切なタイプ判定により、以下のメリットが得られます：

- ✅ **最適なPhase経路の選択**: 必要なPhaseのみ実施し、効率化
- ✅ **適切な成果物の作成**: タイプごとに必要な文書のみ作成
- ✅ **リソースの効率的配分**: 作業量とリスクに応じた計画
- ✅ **品質とスピードのバランス**: 状況に応じた柔軟な対応

---

## 各タイプの詳細判定基準

各PBIタイプについて、以下の3つの判定基準を提供します：

1. **キーワードチェック**: PBI記述に含まれる典型的な単語
2. **判定質問**: Yes/Noで答えられる具体的な質問
3. **判定スコアリング**: 質問の回答から自動的にタイプを判定

---

### タイプ1: 新規プロジェクト立ち上げ (NPI)

#### 定義
全く新しいシステム・プロジェクトを立ち上げる作業。既存システムが存在しない状態からの開発。

#### キーワードチェック

**必須キーワード:**
- 「新規プロジェクト」「プロジェクト立ち上げ」「システム構築」
- 「新規システム開発」「ゼロから構築」

**関連キーワード:**
- 「要件定義から実施」「プロジェクト計画から作成」
- 「新規ビジネス」「新規サービス」
- 「既存システムなし」「初期開発」

#### 判定質問

1. **Q1**: これは全く新しいプロジェクト・システムの立ち上げですか？
   - Yes/No

2. **Q2**: 既存のシステムやプロジェクトは存在しませんか？
   - Yes/No

3. **Q3**: プロジェクト計画書や要件定義から作成する必要がありますか？
   - Yes/No

4. **Q4**: Phase 1（プロジェクト計画）とPhase 6（レビュー・改善）を含む全Phaseが必要ですか？
   - Yes/No

5. **Q5**: チーム体制、開発環境、インフラなどの初期構築が必要ですか？
   - Yes/No

#### 判定スコアリング

- **5問中4問以上がYes** → 「新規プロジェクト立ち上げ（NPI）」と判定
- **Q1とQ2が両方Yes** → NPIの可能性が非常に高い
- **Q3がNo** → 既存プロジェクトへの追加作業の可能性

#### 判定例

**✅ NPIと判定される例:**
- 「新規ECサイトを要件定義からゼロベースで構築する」
- 「新規事業のための顧客管理システムを立ち上げる」
- 「既存システムなし、プロジェクト計画から実施」

**❌ NPIではない例:**
- 「既存のECサイトに決済機能を追加」→ NFD
- 「既存システムのアーキテクチャを全面刷新」→ ARC

---

### タイプ2: 新規機能開発 (NFD)

#### 定義
既存プロジェクトに、新しいユースケース・ビジネス機能を追加する開発。

#### キーワードチェック

**必須キーワード:**
- 「新機能」「新規機能追加」「機能追加」
- 「新しいユースケース」「新たな要件」

**関連キーワード:**
- 「ユーザーストーリー追加」「新規画面」「新規API」
- 「新しい業務フロー」「別システム連携」
- 「データモデル追加」「新テーブル作成」

#### 判定質問

1. **Q1**: 既存プロジェクトに新しい機能を追加しますか？
   - Yes/No

2. **Q2**: これまで存在しなかった新しいユースケースが追加されますか？
   - Yes/No

3. **Q3**: 新しい画面、API、データモデルの追加が必要ですか？
   - Yes/No

4. **Q4**: 他システムとの新規連携や外部サービスとの統合が含まれますか？
   - Yes/No

5. **Q5**: 既存の機能の改善ではなく、全く新しい機能の追加ですか？
   - Yes/No

6. **Q6**: Phase 2（基本設計）が必要ですか？
   - Yes/No

#### 判定スコアリング

- **6問中4問以上がYes** → 「新規機能開発（NFD）」と判定
- **Q2とQ5が両方Yes** → NFDの可能性が非常に高い
- **Q5がNo** → 既存機能追加・改修（ENH）の可能性

#### 判定例

**✅ NFDと判定される例:**
- 「既存ECサイトに定期購入機能を追加」
- 「管理画面に売上レポート機能を新規追加」
- 「外部決済サービスとの連携機能を開発」

**❌ NFDではない例:**
- 「既存の検索機能の精度向上」→ ENH
- 「商品一覧画面のUI改善」→ ENH

---

### タイプ3: 既存機能追加・改修 (ENH)

#### 定義
既存の機能を拡張・改善する作業。新しいユースケースは追加せず、既存ユースケースの改善。

#### キーワードチェック

**必須キーワード:**
- 「改善」「改修」「拡張」「強化」
- 「機能改善」「性能向上」「UI改善」

**関連キーワード:**
- 「使いやすさ向上」「検索精度向上」
- 「表示項目追加」「フィルタ追加」
- 「既存機能の拡張」「パフォーマンス改善」

#### 判定質問

1. **Q1**: 既存の機能を改善・拡張しますか？
   - Yes/No

2. **Q2**: 新しいユースケースは追加されませんか？
   - Yes/No

3. **Q3**: 既存のデータモデルやアーキテクチャを維持しますか？
   - Yes/No

4. **Q4**: UI/UXの改善、パフォーマンス向上が主な目的ですか？
   - Yes/No

5. **Q5**: 既存機能の不具合修正ではありませんか？
   - Yes/No

6. **Q6**: 既存機能の範囲内での改善ですか？
   - Yes/No

#### 判定スコアリング

- **6問中4問以上がYes** → 「既存機能追加・改修（ENH）」と判定
- **Q2とQ3が両方Yes** → ENHの可能性が非常に高い
- **Q5がNo** → バグ修正（BUG）の可能性

#### 判定例

**✅ ENHと判定される例:**
- 「商品検索機能の検索精度を向上させる」
- 「商品一覧画面に並び替え機能を追加」
- 「既存のフォームに入力補助機能を追加」

**❌ ENHではない例:**
- 「定期購入機能を新規追加」→ NFD
- 「検索が正常に動作しないバグを修正」→ BUG

---

### タイプ4: バグ修正 (BUG)

#### 定義
既存機能が正常に動作しない、または仕様と異なる動作をしている問題を修正する作業。

#### キーワードチェック

**必須キーワード:**
- 「バグ」「不具合」「修正」「エラー」
- 「障害」「問題」「正常動作しない」

**関連キーワード:**
- 「動作しない」「期待通りでない」「仕様と異なる」
- 「本番障害」「エラーメッセージ」「例外発生」
- 「データ不整合」「表示崩れ」

#### 判定質問

1. **Q1**: 既存機能が正常に動作していませんか？
   - Yes/No

2. **Q2**: 本来の仕様と異なる動作をしていますか？
   - Yes/No

3. **Q3**: 新しい機能を追加する必要はありませんか？
   - Yes/No

4. **Q4**: 設計やアーキテクチャの変更は不要ですか？
   - Yes/No

5. **Q5**: コードの品質改善（リファクタリング）が主目的ではありませんか？
   - Yes/No

#### 判定スコアリング

- **5問中4問以上がYes** → 「バグ修正（BUG）」と判定
- **Q1とQ2が両方Yes** → BUGの可能性が非常に高い
- **Q4がNo** → 設計変更・アーキテクチャ改善（ARC）の可能性

#### 判定例

**✅ BUGと判定される例:**
- 「ログイン後にセッションが正しく保持されない」
- 「商品価格の計算が間違っている」
- 「検索結果が空の場合にエラーが表示される」

**❌ BUGではない例:**
- 「検索結果の並び順を改善したい」→ ENH
- 「バグ修正のためにアーキテクチャを見直す」→ ARC

---

### タイプ5: リファクタリング (REF)

#### 定義
外部から見た動作を変えずに、コードの内部構造を改善する作業。

#### キーワードチェック

**必須キーワード:**
- 「リファクタリング」「コード改善」「コード整理」
- 「技術的負債解消」「保守性向上」

**関連キーワード:**
- 「可読性向上」「重複コード削除」「関数分割」
- 「命名変更」「構造改善」「テスト追加」
- 「デッドコード削除」「複雑度削減」

#### 判定質問

1. **Q1**: 外部から見た機能の動作は変わりませんか？
   - Yes/No

2. **Q2**: コードの品質・保守性・可読性の向上が目的ですか？
   - Yes/No

3. **Q3**: バグ修正や新機能追加は含まれませんか？
   - Yes/No

4. **Q4**: 設計やアーキテクチャの根本的な変更は不要ですか？
   - Yes/No

5. **Q5**: 技術的負債の解消やコードの健全性向上が目的ですか？
   - Yes/No

#### 判定スコアリング

- **5問中4問以上がYes** → 「リファクタリング（REF）」と判定
- **Q1とQ3が両方Yes** → REFの可能性が非常に高い
- **Q4がNo** → 設計変更・アーキテクチャ改善（ARC）の可能性

#### 判定例

**✅ REFと判定される例:**
- 「複雑な関数を小さな関数に分割して可読性を向上」
- 「重複しているコードを共通化」
- 「変数名・関数名を意味が分かりやすい名前に変更」

**❌ REFではない例:**
- 「データベース構造を見直す」→ ARC
- 「機能を改善しながらコードも整理」→ ENH

---

### タイプ6: 設計変更・アーキテクチャ改善 (ARC)

#### 定義
システムの設計、アーキテクチャ、データモデルの根本的な見直しと改善。

#### キーワードチェック

**必須キーワード:**
- 「アーキテクチャ改善」「設計変更」「設計見直し」
- 「データモデル変更」「全面刷新」

**関連キーワード:**
- 「スケーラビリティ向上」「パフォーマンス改善（根本的）」
- 「モノリスからマイクロサービス」「DB構造変更」
- 「技術スタック変更」「フレームワーク変更」

#### 判定質問

1. **Q1**: システムの設計やアーキテクチャを根本的に変更しますか？
   - Yes/No

2. **Q2**: データベース構造やデータモデルの変更が必要ですか？
   - Yes/No

3. **Q3**: 技術スタックやフレームワークの変更が含まれますか？
   - Yes/No

4. **Q4**: スケーラビリティ、パフォーマンス、保守性の根本的な改善が目的ですか？
   - Yes/No

5. **Q5**: 複数のモジュール・コンポーネントに影響が及びますか？
   - Yes/No

6. **Q6**: Phase 2（基本設計）での設計書更新が必要ですか？
   - Yes/No

#### 判定スコアリング

- **6問中4問以上がYes** → 「設計変更・アーキテクチャ改善（ARC）」と判定
- **Q1とQ2が両方Yes** → ARCの可能性が非常に高い
- **Q6がNo** → リファクタリング（REF）の可能性

#### 判定例

**✅ ARCと判定される例:**
- 「モノリシックなシステムをマイクロサービスアーキテクチャに変更」
- 「データベースを正規化し、テーブル構造を全面的に見直す」
- 「フロントエンドをjQueryからReactに移行」

**❌ ARCではない例:**
- 「特定の関数のパフォーマンスを改善」→ REF or ENH
- 「単一モジュール内のコード整理」→ REF

---

### タイプ7: 緊急修正 (HOT)

#### 定義
本番環境での重大な問題に対する、24時間以内の緊急対応が必要な修正。

#### キーワードチェック

**必須キーワード:**
- 「緊急」「Hotfix」「緊急対応」「即座に対応」
- 「本番障害」「重大な問題」

**関連キーワード:**
- 「サービス停止」「データ損失」「セキュリティ脆弱性」
- 「24時間以内」「即時対応」「クリティカル」
- 「ユーザー影響大」「ビジネス影響大」

#### 判定質問

1. **Q1**: 本番環境で重大な問題が発生していますか？
   - Yes/No

2. **Q2**: 24時間以内の対応が必要ですか？
   - Yes/No

3. **Q3**: ユーザーやビジネスへの影響が大きいですか？
   - Yes/No

4. **Q4**: 通常のPhase経路を短縮する必要がありますか？
   - Yes/No

5. **Q5**: サービス停止、データ損失、セキュリティ問題などの緊急性がありますか？
   - Yes/No

#### 判定スコアリング

- **5問中4問以上がYes** → 「緊急修正（HOT）」と判定
- **Q2とQ5が両方Yes** → HOTの可能性が非常に高い
- **Q2がNo** → バグ修正（BUG）や新規機能開発（NFD）の可能性

#### 判定例

**✅ HOTと判定される例:**
- 「本番環境でログイン機能が全面停止」
- 「個人情報が外部から閲覧可能な状態になっている」
- 「決済処理で金額計算が間違っている」

**❌ HOTではない例:**
- 「一部の環境で表示が崩れている」→ BUG
- 「来週までに対応が必要なバグ」→ BUG

---

### タイプ8: 実験的機能 (POC)

#### 定義
技術検証、実験、概念実証のための開発。本番導入は未定。

#### キーワードチェック

**必須キーワード:**
- 「実験」「POC」「Spike」「技術検証」
- 「プロトタイプ」「概念実証」

**関連キーワード:**
- 「技術調査」「フィージビリティスタディ」
- 「試作」「MVP」「デモ」
- 「新技術の評価」「実現可能性の確認」

#### 判定質問

1. **Q1**: 技術検証や実験が主な目的ですか？
   - Yes/No

2. **Q2**: 本番環境への導入は未定または将来の判断ですか？
   - Yes/No

3. **Q3**: 新技術や新しいアプローチの実現可能性を確認しますか？
   - Yes/No

4. **Q4**: 完全な品質保証やドキュメント作成は不要ですか？
   - Yes/No

5. **Q5**: 短期間での結果確認が目的ですか？
   - Yes/No

#### 判定スコアリング

- **5問中4問以上がYes** → 「実験的機能（POC）」と判定
- **Q1とQ2が両方Yes** → POCの可能性が非常に高い
- **Q2がNo** → 新規機能開発（NFD）の可能性

#### 判定例

**✅ POCと判定される例:**
- 「機械学習モデルの精度検証のためのプロトタイプ作成」
- 「新しいUIフレームワークの採用可否を判断するための試作」
- 「GraphQL導入の技術的実現可能性を確認」

**❌ POCではない例:**
- 「検証済みの機能を本番導入」→ NFD
- 「既存機能の改善」→ ENH

---

## 境界ケース判定ルール

実務でよく発生する、判定が曖昧なケースについての具体的な判定ルールを提供します。

---

### ケース1: 既存機能の大幅改修

**状況:**
既存機能の50%以上が変更され、UI/UXが大幅に変わり、データ構造の変更も必要。

**判定ルール:**

```
IF 新しいユースケースが追加される
  OR 別システムとの連携が必要になる
  OR データモデルの根本的な変更が必要
THEN
  → 「新規機能開発（NFD）」

ELSE IF 既存のユースケースの改善のみ
  AND 既存のデータモデルを維持
THEN
  → 「既存機能追加・改修（ENH）」
```

**判定のポイント:**
- 新しいユースケースの追加有無が決定的
- データモデルの変更が「根本的」か「拡張」かを確認

**具体例:**
- ✅ NFD: 「商品検索に音声検索機能を追加（新ユースケース）」
- ✅ ENH: 「商品検索のUIを全面刷新（既存ユースケースの改善）」

---

### ケース2: 設計変更を伴うバグ修正

**状況:**
バグを正しく修正するためには、設計やアーキテクチャの見直しが必要。

**判定ルール:**

```
IF 設計の根本的な問題が原因
  AND 複数のモジュールに影響
  AND 長期的な品質向上が目的
THEN
  → 「設計変更・アーキテクチャ改善（ARC）」

ELSE IF 設計変更が小規模
  AND 主目的がバグ修正
THEN
  → 「バグ修正（BUG）」+ 備考に設計変更を記載
```

**判定のポイント:**
- 主目的が「バグ修正」か「設計改善」かを確認
- 影響範囲の広さを評価

**具体例:**
- ✅ ARC: 「データ競合バグの根本原因であるアーキテクチャを見直す」
- ✅ BUG: 「バグ修正のために関数の設計を少し変更」

---

### ケース3: 緊急の新機能追加

**状況:**
新機能だが、ビジネス上の理由で24時間以内の対応が必要。

**判定ルール:**

```
IF ビジネス上の緊急性（24時間以内）が最優先
  AND 既存システムに重大な影響なし
  AND 通常のPhase経路では間に合わない
THEN
  → 「緊急修正（HOT）」

ELSE IF 緊急性はあるが数日の猶予がある
THEN
  → 「新規機能開発（NFD）」+ Phase短縮で対応
```

**判定のポイント:**
- 真の緊急性（24時間以内）があるかを確認
- 既存システムへの影響度を評価

**具体例:**
- ✅ HOT: 「法改正対応で24時間以内に税率変更機能を追加」
- ✅ NFD: 「来週までに新機能が必要（Phase短縮で対応）」

---

### ケース4: 実験後の正式実装

**状況:**
POCで検証した技術を、本番環境に正式に実装する。

**判定ルール:**

```
IF POCから本番環境への移行
  AND 品質保証とドキュメント作成が必要
  AND 新しいユースケースを追加
THEN
  → 「新規機能開発（NFD）」
  → POCの成果物を参考にするが、Phase 0から実施

ELSE IF POCの延長で追加検証のみ
THEN
  → 「実験的機能（POC）」を継続
```

**判定のポイント:**
- 本番導入の意思決定がされているかを確認
- 品質保証レベルの要件を確認

**具体例:**
- ✅ NFD: 「POCで検証したAI機能を本番環境に正式実装」
- ✅ POC: 「POCの結果を受けて、さらに別の技術を検証」

---

### ケース5: パフォーマンス改善

**状況:**
システムのパフォーマンスを改善する必要がある。

**判定ルール:**

```
IF アーキテクチャやデータ構造の根本的な変更が必要
  AND 複数のコンポーネントに影響
THEN
  → 「設計変更・アーキテクチャ改善（ARC）」

ELSE IF 特定の機能・コードの最適化のみ
  AND 外部動作は変わらない
THEN
  → 「リファクタリング（REF）」

ELSE IF 機能改善とパフォーマンス改善が同時
THEN
  → 「既存機能追加・改修（ENH）」
```

**判定のポイント:**
- 変更の影響範囲と深さを評価
- 機能変更の有無を確認

**具体例:**
- ✅ ARC: 「DBクエリの根本的な見直しでシステム全体のパフォーマンスを改善」
- ✅ REF: 「特定のアルゴリズムを最適化してパフォーマンス向上」
- ✅ ENH: 「検索機能の精度とパフォーマンスを同時に改善」

---

### ケース6: セキュリティ脆弱性対応

**状況:**
セキュリティ脆弱性が発見され、対応が必要。

**判定ルール:**

```
IF 脆弱性が公開済みで攻撃リスクが高い
  AND 24時間以内の対応が必要
THEN
  → 「緊急修正（HOT）」

ELSE IF 攻撃リスクは低いが対応は必要
  AND 既存コードの修正のみ
THEN
  → 「バグ修正（BUG）」

ELSE IF セキュリティ強化のためのアーキテクチャ見直し
THEN
  → 「設計変更・アーキテクチャ改善（ARC）」
```

**判定のポイント:**
- 緊急性とリスクレベルを評価
- 対応の規模を確認

**具体例:**
- ✅ HOT: 「SQLインジェクションの脆弱性が公開、即座に対応」
- ✅ BUG: 「低リスクのXSS脆弱性を修正」
- ✅ ARC: 「認証・認可の仕組みを全面的に見直し」

---

### ケース7: 技術的負債解消

**状況:**
長年蓄積された技術的負債を解消する。

**判定ルール:**

```
IF アーキテクチャや設計の根本的な見直しが必要
  AND 複数のモジュールに影響
THEN
  → 「設計変更・アーキテクチャ改善（ARC）」

ELSE IF コードの品質改善のみ
  AND 外部動作は変わらない
THEN
  → 「リファクタリング（REF）」
```

**判定のポイント:**
- 変更の深さと影響範囲を評価
- 外部動作への影響の有無を確認

**具体例:**
- ✅ ARC: 「レガシーなコードベースを新しいアーキテクチャに移行」
- ✅ REF: 「特定のモジュール内のコードを整理して可読性向上」

---

### ケース8: データ移行

**状況:**
既存データを新しい構造に移行する必要がある。

**判定ルール:**

```
IF データ移行が機能追加の一部
  AND 新しいユースケースを追加
THEN
  → 「新規機能開発（NFD）」

ELSE IF データ移行がアーキテクチャ変更の一部
THEN
  → 「設計変更・アーキテクチャ改善（ARC）」

ELSE IF データ移行のみ（機能変更なし）
THEN
  → 「リファクタリング（REF）」または「既存機能追加・改修（ENH）」
```

**判定のポイント:**
- データ移行の目的を確認
- 機能変更の有無を評価

**具体例:**
- ✅ NFD: 「新しい顧客管理機能を追加し、既存顧客データを移行」
- ✅ ARC: 「データベースを正規化し、全データを新構造に移行」
- ✅ REF: 「データ構造を整理し、既存データを移行（機能不変）」

---

### ケース9: UI/UXの全面刷新

**状況:**
ユーザーインターフェースを全面的に刷新する。

**判定ルール:**

```
IF 新しいユースケースやワークフローが追加される
THEN
  → 「新規機能開発（NFD）」

ELSE IF 既存のユースケースはそのままでUIのみ変更
  AND 使いやすさ向上が目的
THEN
  → 「既存機能追加・改修（ENH）」

ELSE IF フロントエンドのフレームワーク変更を含む
  AND 技術スタックの刷新
THEN
  → 「設計変更・アーキテクチャ改善（ARC）」
```

**判定のポイント:**
- ユースケースの変更有無を確認
- 技術スタックの変更有無を確認

**具体例:**
- ✅ NFD: 「新しい操作方法と新機能を含むUI刷新」
- ✅ ENH: 「既存機能のUIを見やすく改善」
- ✅ ARC: 「jQueryからReactへの移行とUI刷新」

---

### ケース10: API仕様変更

**状況:**
既存のAPIの仕様を変更する必要がある。

**判定ルール:**

```
IF 既存APIに破壊的変更（Breaking Change）を加える
  AND 新しいAPI設計が必要
THEN
  → 「設計変更・アーキテクチャ改善（ARC）」

ELSE IF 新しいエンドポイントやパラメータを追加（非破壊的）
THEN
  → 「既存機能追加・改修（ENH）」

ELSE IF APIのバグ修正
THEN
  → 「バグ修正（BUG）」
```

**判定のポイント:**
- 破壊的変更かどうかを確認
- 既存クライアントへの影響を評価

**具体例:**
- ✅ ARC: 「RESTからGraphQLへのAPI全面移行」
- ✅ ENH: 「既存APIにオプショナルパラメータを追加」
- ✅ BUG: 「APIのレスポンス形式が仕様と異なる問題を修正」

---

### ケース11: テスト追加・改善

**状況:**
既存コードにテストを追加する、またはテストを改善する。

**判定ルール:**

```
IF テスト追加のみ（コード本体は変更なし）
THEN
  → 「リファクタリング（REF）」

ELSE IF テストとコード改善を同時実施
THEN
  → 「リファクタリング（REF）」

ELSE IF テストを追加しながら機能改善
THEN
  → 「既存機能追加・改修（ENH）」
```

**判定のポイント:**
- テストがメインか、機能改善がメインかを確認

**具体例:**
- ✅ REF: 「既存コードにユニットテストを追加」
- ✅ REF: 「テストカバレッジを向上させるためにテストを追加」
- ✅ ENH: 「機能改善と合わせてテストも追加」

---

### ケース12: ドキュメント更新

**状況:**
コードは変更せず、ドキュメントのみ更新する。

**判定ルール:**

```
IF ドキュメント更新のみ（コード変更なし）
THEN
  → PBIではなく、通常のタスクとして処理
  → または「リファクタリング（REF）」として軽微に扱う

ELSE IF コード変更とドキュメント更新を同時実施
THEN
  → コード変更の性質に応じて判定（NFD/ENH/BUG/REF/ARC）
```

**判定のポイント:**
- コード変更の有無を確認
- ドキュメント更新はPBIの一部として扱うか判断

**具体例:**
- ✅ 通常タスク: 「README.mdを最新の情報に更新」
- ✅ NFD: 「新機能を実装し、APIドキュメントも更新」

---

### ケース13: 外部ライブラリ・依存関係の更新

**状況:**
使用している外部ライブラリやフレームワークをアップデートする。

**判定ルール:**

```
IF セキュリティパッチの緊急適用
  AND 24時間以内の対応が必要
THEN
  → 「緊急修正（HOT）」

ELSE IF 脆弱性修正やバグ修正のアップデート
THEN
  → 「バグ修正（BUG）」

ELSE IF メジャーバージョンアップで大規模な変更が必要
THEN
  → 「設計変更・アーキテクチャ改善（ARC）」

ELSE IF マイナーバージョンアップ（影響小）
THEN
  → 「リファクタリング（REF）」
```

**判定のポイント:**
- アップデートの影響範囲と緊急性を評価

**具体例:**
- ✅ HOT: 「Log4jの脆弱性対応で即座にアップデート」
- ✅ BUG: 「ライブラリのバグ修正版にアップデート」
- ✅ ARC: 「Reactをv16からv18にメジャーアップデート」
- ✅ REF: 「依存ライブラリをマイナーアップデート」

---

### ケース14: 複数の変更が混在

**状況:**
1つのPBIに、新機能追加、バグ修正、リファクタリングなど複数の要素が含まれる。

**判定ルール:**

```
IF 複数の変更が混在している
THEN
  → **PBIを分割することを推奨**
  → 各変更を独立したPBIとして管理

ELSE IF 分割が困難な場合
THEN
  → 最も影響が大きい変更を基準に判定
  → 他の変更は備考欄に記載
```

**判定のポイント:**
- PBI分割の可否を検討
- 主要な変更内容を特定

**具体例:**
- ✅ 分割推奨: 「新機能追加」と「既存バグ修正」は別々のPBIに
- ✅ ENH（主）: 「検索機能改善（主）+ 軽微なコード整理」

---

### ケース15: 小規模な変更（タイポ修正など）

**状況:**
文言の修正、タイポ修正など、非常に小規模な変更。

**判定ルール:**

```
IF 変更が極めて軽微（数分で完了）
THEN
  → PBIとして管理せず、直接修正も検討
  → またはバグ修正（BUG）として軽微に扱う

ELSE IF 小規模だが複数箇所に影響
THEN
  → 「バグ修正（BUG）」または「リファクタリング（REF）」
```

**判定のポイント:**
- PBI管理の必要性を判断
- 影響範囲を確認

**具体例:**
- ✅ 直接修正: 「READMEのタイポを修正」
- ✅ BUG: 「画面上の誤字を複数箇所修正」

---

### ケース16: 設定変更（環境変数、設定ファイルなど）

**状況:**
コードは変更せず、設定ファイルや環境変数のみ変更する。

**判定ルール:**

```
IF 設定変更が緊急で重要（本番障害対応など）
THEN
  → 「緊急修正（HOT）」

ELSE IF 設定変更が機能改善の一部
THEN
  → 「既存機能追加・改修（ENH）」

ELSE IF 設定の整理や最適化のみ
THEN
  → 「リファクタリング（REF）」または通常タスク
```

**判定のポイント:**
- 設定変更の目的と影響を確認

**具体例:**
- ✅ HOT: 「本番環境のタイムアウト設定を緊急変更」
- ✅ ENH: 「機能改善のために設定を調整」
- ✅ REF: 「設定ファイルを整理して保守性向上」

---

### ケース17: モニタリング・ログ追加

**状況:**
既存機能にモニタリングやログ出力を追加する。

**判定ルール:**

```
IF モニタリング・ログ追加が主目的
  AND コードロジックの変更はない
THEN
  → 「リファクタリング（REF）」

ELSE IF 機能改善と同時にモニタリング追加
THEN
  → 機能改善の性質に応じて判定（NFD/ENH）
```

**判定のポイント:**
- モニタリング追加が主目的か副次的かを確認

**具体例:**
- ✅ REF: 「既存機能にログ出力を追加して問題調査を容易に」
- ✅ ENH: 「機能改善と合わせてモニタリングも追加」

---

### ケース18: コメント追加・削除

**状況:**
コードにコメントを追加する、または不要なコメントを削除する。

**判定ルール:**

```
IF コメントの追加・削除のみ
THEN
  → 「リファクタリング（REF）」または通常タスク

ELSE IF コード変更と同時にコメント追加
THEN
  → コード変更の性質に応じて判定
```

**判定のポイント:**
- コメントがメインか、コード変更がメインかを確認

**具体例:**
- ✅ REF: 「複雑なアルゴリズムにコメントを追加」
- ✅ 通常タスク: 「古いコメントを削除して整理」

---

## 判定フローチャート

以下の7ステップで、PBIタイプを体系的に判定できます。

---

### 判定フローチャート図

```
┌─────────────────────────────────────────┐
│  Step 1: プロジェクト新規性チェック          │
│  「これは全く新しいプロジェクト・システムの   │
│   立ち上げですか？」                       │
└─────────────┬───────────────────────────┘
              │
              ├─ Yes → 【NPI: 新規プロジェクト立ち上げ】
              │
              └─ No
                  ↓
┌─────────────────────────────────────────┐
│  Step 2: 緊急性チェック                     │
│  「24時間以内の緊急対応が必要ですか？」      │
└─────────────┬───────────────────────────┘
              │
              ├─ Yes → 【HOT: 緊急修正】
              │
              └─ No
                  ↓
┌─────────────────────────────────────────┐
│  Step 3: 実験性チェック                     │
│  「技術検証・実験が主な目的ですか？」        │
└─────────────┬───────────────────────────┘
              │
              ├─ Yes → 【POC: 実験的機能】
              │
              └─ No
                  ↓
┌─────────────────────────────────────────┐
│  Step 4: 既存機能の問題チェック              │
│  「既存機能が正常に動作していませんか？」    │
└─────────────┬───────────────────────────┘
              │
              ├─ Yes → 【BUG: バグ修正】
              │
              └─ No
                  ↓
┌─────────────────────────────────────────┐
│  Step 5: アーキテクチャ変更チェック          │
│  「設計・アーキテクチャの根本的な変更が      │
│   必要ですか？」                           │
└─────────────┬───────────────────────────┘
              │
              ├─ Yes → 【ARC: 設計変更・アーキテクチャ改善】
              │
              └─ No
                  ↓
┌─────────────────────────────────────────┐
│  Step 6: コード品質改善チェック              │
│  「外部動作は変えずに、コード品質を          │
│   改善しますか？」                         │
└─────────────┬───────────────────────────┘
              │
              ├─ Yes → 【REF: リファクタリング】
              │
              └─ No
                  ↓
┌─────────────────────────────────────────┐
│  Step 7: 機能追加チェック                    │
│  「新しいユースケースを追加しますか？」      │
└─────────────┬───────────────────────────┘
              │
              ├─ Yes → 【NFD: 新規機能開発】
              │
              └─ No → 【ENH: 既存機能追加・改修】
```

---

### 各ステップの詳細

#### Step 1: プロジェクト新規性チェック

**質問:** 「これは全く新しいプロジェクト・システムの立ち上げですか？」

**判定基準:**
- 既存のシステム・プロジェクトが存在しない
- Phase 1（プロジェクト計画）から実施が必要
- チーム体制、開発環境、インフラの初期構築が必要

**Yes → NPI（新規プロジェクト立ち上げ）**

---

#### Step 2: 緊急性チェック

**質問:** 「24時間以内の緊急対応が必要ですか？」

**判定基準:**
- 本番環境で重大な問題が発生
- ユーザーやビジネスへの影響が大きい
- サービス停止、データ損失、セキュリティ問題などの緊急性

**Yes → HOT（緊急修正）**

---

#### Step 3: 実験性チェック

**質問:** 「技術検証・実験が主な目的ですか？」

**判定基準:**
- 新技術や新しいアプローチの実現可能性を確認
- 本番環境への導入は未定
- 短期間での結果確認が目的

**Yes → POC（実験的機能）**

---

#### Step 4: 既存機能の問題チェック

**質問:** 「既存機能が正常に動作していませんか？」

**判定基準:**
- 既存機能が仕様と異なる動作をしている
- バグやエラーが発生している
- 正常な動作への復旧が目的

**Yes → BUG（バグ修正）**

---

#### Step 5: アーキテクチャ変更チェック

**質問:** 「設計・アーキテクチャの根本的な変更が必要ですか？」

**判定基準:**
- データベース構造やデータモデルの変更
- 技術スタックやフレームワークの変更
- 複数のモジュール・コンポーネントに影響

**Yes → ARC（設計変更・アーキテクチャ改善）**

---

#### Step 6: コード品質改善チェック

**質問:** 「外部動作は変えずに、コード品質を改善しますか？」

**判定基準:**
- 外部から見た機能の動作は変わらない
- コードの可読性、保守性、テストカバレッジの向上
- 技術的負債の解消

**Yes → REF（リファクタリング）**

---

#### Step 7: 機能追加チェック

**質問:** 「新しいユースケースを追加しますか？」

**判定基準:**
- **Yes**: 新しいユースケース、ビジネス機能を追加 → **NFD（新規機能開発）**
- **No**: 既存ユースケースの改善・拡張 → **ENH（既存機能追加・改修）**

---

## AIエージェント向け判定プロンプト

自律的AIエージェントがPBIタイプを判定する際に使用できる、構造化されたプロンプトテンプレートです。

---

### プロンプトテンプレート

```markdown
# PBIタイプ判定依頼

## PBI情報
- **PBIタイトル**: [PBIのタイトル]
- **PBI説明**: [PBIの詳細説明]
- **追加情報**: [その他の関連情報]

## 判定依頼
以下の情報に基づいて、このPBIのタイプを判定してください。

### 判定ステップ

#### Step 1: プロジェクト新規性
- これは全く新しいプロジェクト・システムの立ち上げですか？
- 回答: [Yes/No]
- 理由: [理由を記載]

#### Step 2: 緊急性
- 24時間以内の緊急対応が必要ですか？
- 回答: [Yes/No]
- 理由: [理由を記載]

#### Step 3: 実験性
- 技術検証・実験が主な目的ですか？
- 回答: [Yes/No]
- 理由: [理由を記載]

#### Step 4: 既存機能の問題
- 既存機能が正常に動作していませんか？
- 回答: [Yes/No]
- 理由: [理由を記載]

#### Step 5: アーキテクチャ変更
- 設計・アーキテクチャの根本的な変更が必要ですか？
- 回答: [Yes/No]
- 理由: [理由を記載]

#### Step 6: コード品質改善
- 外部動作は変えずに、コード品質を改善しますか？
- 回答: [Yes/No]
- 理由: [理由を記載]

#### Step 7: 機能追加
- 新しいユースケースを追加しますか？
- 回答: [Yes/No]
- 理由: [理由を記載]

## 判定結果
- **判定されたPBIタイプ**: [NPI/NFD/ENH/BUG/REF/ARC/HOT/POC]
- **選択したPhase経路**: [Phase経路を記載]
- **判定の根拠**: [判定理由を詳しく記載]
- **境界ケースの考慮**: [該当する境界ケースがあれば記載]
- **推奨される次のアクション**: [次に実施すべきアクションを記載]
```

---

### プロンプト使用例

#### 例1: 新規機能追加の場合

```markdown
# PBIタイプ判定依頼

## PBI情報
- **PBIタイトル**: 既存ECサイトに定期購入機能を追加
- **PBI説明**: ユーザーが商品を定期的に自動購入できる機能を追加する。定期購入の設定、キャンセル、変更が可能。
- **追加情報**: 既存のECサイトは稼働中。決済システムとの連携が必要。

## 判定依頼
以下の情報に基づいて、このPBIのタイプを判定してください。

### 判定ステップ

#### Step 1: プロジェクト新規性
- これは全く新しいプロジェクト・システムの立ち上げですか？
- 回答: No
- 理由: 既存のECサイトへの機能追加

#### Step 2: 緊急性
- 24時間以内の緊急対応が必要ですか？
- 回答: No
- 理由: 通常の開発スケジュールで対応可能

#### Step 3: 実験性
- 技術検証・実験が主な目的ですか？
- 回答: No
- 理由: 本番環境への正式実装が目的

#### Step 4: 既存機能の問題
- 既存機能が正常に動作していませんか？
- 回答: No
- 理由: バグ修正ではなく新機能追加

#### Step 5: アーキテクチャ変更
- 設計・アーキテクチャの根本的な変更が必要ですか？
- 回答: No
- 理由: 既存アーキテクチャの範囲内で実装可能

#### Step 6: コード品質改善
- 外部動作は変えずに、コード品質を改善しますか？
- 回答: No
- 理由: 新しい機能を追加する

#### Step 7: 機能追加
- 新しいユースケースを追加しますか？
- 回答: Yes
- 理由: 定期購入という新しいユースケースを追加

## 判定結果
- **判定されたPBIタイプ**: NFD（新規機能開発）
- **選択したPhase経路**: Phase 0 → 2 → 3 → 4 → 5
- **判定の根拠**: 既存ECサイトに「定期購入」という新しいユースケースを追加するため、新規機能開発（NFD）と判定。Phase 2（基本設計）から開始し、設計・実装・テスト・リリースを実施。
- **境界ケースの考慮**: なし
- **推奨される次のアクション**: Phase 0（事前準備）から開始し、要件を明確化。Phase 2で定期購入機能の設計書を作成。
```

---

### AIエージェント用の自動判定ロジック

AIエージェントがプログラム的に判定を行う場合の疑似コードです：

```python
def judge_pbi_type(pbi_info):
    """
    PBIタイプを自動判定する関数
    
    Args:
        pbi_info (dict): PBIの情報
            - title: str
            - description: str
            - additional_info: str
    
    Returns:
        dict: 判定結果
            - pbi_type: str (NPI/NFD/ENH/BUG/REF/ARC/HOT/POC)
            - phase_path: str
            - reason: str
    """
    
    # Step 1: プロジェクト新規性チェック
    if is_new_project(pbi_info):
        return {
            'pbi_type': 'NPI',
            'phase_path': '0→1→2→3→4→5→6',
            'reason': '全く新しいプロジェクト・システムの立ち上げ'
        }
    
    # Step 2: 緊急性チェック
    if is_urgent_within_24h(pbi_info):
        return {
            'pbi_type': 'HOT',
            'phase_path': '簡易0→3→簡易4→5',
            'reason': '24時間以内の緊急対応が必要'
        }
    
    # Step 3: 実験性チェック
    if is_experimental(pbi_info):
        return {
            'pbi_type': 'POC',
            'phase_path': '簡易0→3',
            'reason': '技術検証・実験が主な目的'
        }
    
    # Step 4: 既存機能の問題チェック
    if is_bug_fix(pbi_info):
        return {
            'pbi_type': 'BUG',
            'phase_path': '(0簡易版)→3→4',
            'reason': '既存機能の不具合修正'
        }
    
    # Step 5: アーキテクチャ変更チェック
    if is_architecture_change(pbi_info):
        return {
            'pbi_type': 'ARC',
            'phase_path': '0→2→3→4→5',
            'reason': '設計・アーキテクチャの根本的な変更'
        }
    
    # Step 6: コード品質改善チェック
    if is_refactoring(pbi_info):
        return {
            'pbi_type': 'REF',
            'phase_path': '0→3→4',
            'reason': 'コード品質改善（外部動作不変）'
        }
    
    # Step 7: 機能追加チェック
    if is_new_usecase(pbi_info):
        return {
            'pbi_type': 'NFD',
            'phase_path': '0→2→3→4→5',
            'reason': '新しいユースケースの追加'
        }
    else:
        return {
            'pbi_type': 'ENH',
            'phase_path': '0→2→3→4→5',
            'reason': '既存ユースケースの改善・拡張'
        }

# 各判定関数の実装例
def is_new_project(pbi_info):
    keywords = ['新規プロジェクト', 'プロジェクト立ち上げ', 'システム構築', 'ゼロから構築']
    return any(keyword in pbi_info['title'] + pbi_info['description'] for keyword in keywords)

def is_urgent_within_24h(pbi_info):
    keywords = ['緊急', 'Hotfix', '24時間以内', '即座に対応', '本番障害']
    return any(keyword in pbi_info['title'] + pbi_info['description'] for keyword in keywords)

# 以下、他の判定関数も同様に実装...
```

---

## よくある質問

### Q1: 複数のタイプに該当する場合はどうすればよいですか？

**A1:** 以下の対応を推奨します：

1. **PBIを分割する**: 可能な限り、各変更を独立したPBIに分割してください。
   - 例: 「新機能追加」と「既存バグ修正」は別々のPBIとして管理

2. **主要な変更を基準に判定する**: 分割が困難な場合は、最も影響が大きい変更を基準に判定し、他の変更は備考欄に記載してください。
   - 例: 主に検索機能の改善（ENH）で、軽微なコード整理も含む

---

### Q2: 判定に迷った場合はどうすればよいですか？

**A2:** 以下のステップで対応してください：

1. **判定フローチャート**を順番に確認
2. **境界ケース判定ルール**で類似のケースを探す
3. **判定質問**に回答してスコアリング
4. それでも迷う場合は、**より慎重なタイプ**を選択
   - 例: NFDかENHで迷う → NFD（Phase 2を含む方）を選択

---

### Q3: 緊急修正（HOT）の判定基準が曖昧です。どう判断すればよいですか？

**A3:** 以下の3つの基準を**全て満たす**場合にHOTと判定してください：

1. **24時間以内の対応が必要** - 真の緊急性があるか
2. **本番環境での重大な問題** - ユーザーやビジネスへの影響が大きいか
3. **通常のPhase経路では間に合わない** - Phase短縮が必須か

一つでも満たさない場合は、BUGやNFDとして通常の開発プロセスで対応してください。

---

### Q4: 実験的機能（POC）と新規機能開発（NFD）の境界が曖昧です。

**A4:** 以下の質問で判断してください：

- **Q**: 本番環境への導入が確定していますか？
  - **Yes** → NFD（本番品質が必要）
  - **No** → POC（検証が目的）

- **Q**: 完全な品質保証とドキュメント作成が必要ですか？
  - **Yes** → NFD
  - **No** → POC

---

### Q5: リファクタリング（REF）とアーキテクチャ改善（ARC）の違いは？

**A5:** 以下の表で判断してください：

| 項目 | REF | ARC |
|------|-----|-----|
| **変更の深さ** | コードレベル | 設計・アーキテクチャレベル |
| **影響範囲** | 特定のモジュール | 複数のコンポーネント |
| **Phase 2の必要性** | 不要 | 必要（設計書更新） |
| **データモデル変更** | なし | あり |

**例:**
- REF: 「特定の関数を分割して可読性向上」
- ARC: 「データベース構造を全面的に見直し」

---

### Q6: 既存機能追加・改修（ENH）と新規機能開発（NFD）の違いは？

**A6:** 以下の質問で判断してください：

- **Q**: 新しいユースケースが追加されますか？
  - **Yes** → NFD
  - **No** → ENH

**具体例:**
- NFD: 「ECサイトに定期購入機能を追加」（新ユースケース）
- ENH: 「商品検索の精度を向上」（既存ユースケースの改善）

---

### Q7: バグ修正（BUG）で設計変更が必要な場合はどうすればよいですか？

**A7:** 「ケース2: 設計変更を伴うバグ修正」の判定ルールを参照してください：

- **設計の根本的な問題が原因で、複数のモジュールに影響** → ARC
- **設計変更が小規模で、主目的がバグ修正** → BUG（備考に設計変更を記載）

---

### Q8: 小規模な変更はPBIとして管理すべきですか？

**A8:** 以下の基準で判断してください：

- **極めて軽微（数分で完了）**: PBIとして管理せず、直接修正も検討
  - 例: READMEのタイポ修正

- **小規模だが複数箇所に影響**: BUGまたはREFとして管理
  - 例: 画面上の誤字を複数箇所修正

---

### Q9: Phase経路は必ず固定ですか？柔軟に変更できますか？

**A9:** Phase経路は**ガイドライン**であり、状況に応じて柔軟に調整できます：

- **基本**: 各タイプの標準Phase経路を推奨
- **調整可能**: プロジェクトの状況、リスク、スピード要求に応じて調整
- **記録**: Phase経路を変更した場合は、その理由を記録

**例:**
- NFDでも、リスクが低い場合はPhase 2を簡略化
- BUGでも、影響が大きい場合はPhase 0を丁寧に実施

---

### Q10: このガイドは定期的に更新されますか？

**A10:** はい、以下のタイミングで更新を検討します：

- **新しい境界ケースの発見**: 実務で新しいケースが出た場合
- **判定基準の改善**: より明確な基準が見つかった場合
- **組織の開発プロセス変更**: プロセスが変わった場合

更新履歴は本ドキュメントの冒頭に記載します。

---

## まとめ

このガイドを活用することで、以下を実現できます：

✅ **正確なPBIタイプ判定**: 8つのタイプから適切なものを選択
✅ **境界ケースの解決**: 曖昧な状況でも明確な判定
✅ **効率的な開発プロセス**: 必要なPhaseのみ実施
✅ **一貫性のある判定**: チーム全体で統一された基準

---

## 関連ドキュメント

- **AI-MASTER-WORKFLOW-GUIDE.md**: 各Phaseの詳細な実施内容
- **AI-DELIVERABLE-REFERENCE-GUIDE.md**: Phase別成果物の参照ガイド
- **AI-PRE-WORK-CHECKLIST.md**: Phase開始前のチェックリスト

---

**ドキュメント終了**
