name: PR Description Quality Gate

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  validate-pr-description:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Get PR description
        id: pr-info
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            return {
              body: pr.body || '',
              title: pr.title || '',
              number: pr.number
            };
      
      - name: Validate PR description
        id: validate
        uses: actions/github-script@v7
        with:
          script: |
            const prBody = ${{ steps.pr-info.outputs.result }}.body;
            const prTitle = ${{ steps.pr-info.outputs.result }}.title;
            
            // æ¤œè¨¼çµæœã‚’æ ¼ç´
            const results = {
              passed: true,
              errors: [],
              warnings: [],
              stats: {}
            };
            
            // ========================================
            // 1. å¿…é ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®å­˜åœ¨ç¢ºèª
            // ========================================
            const requiredSections = [
              { name: 'å¤‰æ›´å†…å®¹ã®æ¦‚è¦', pattern: /##\s*ğŸ“‹\s*å¤‰æ›´å†…å®¹ã®æ¦‚è¦/i },
              { name: 'é–¢é€£ãƒã‚±ãƒƒãƒˆ', pattern: /##\s*ğŸ¯\s*é–¢é€£ãƒã‚±ãƒƒãƒˆ/i },
              { name: 'å¤‰æ›´ã®è©³ç´°', pattern: /##\s*ğŸ”\s*å¤‰æ›´ã®è©³ç´°/i },
              { name: 'ãƒ†ã‚¹ãƒˆã®å®Ÿæ–½çŠ¶æ³', pattern: /##\s*âœ…\s*ãƒ†ã‚¹ãƒˆã®å®Ÿæ–½çŠ¶æ³/i },
              { name: 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯', pattern: /##\s*ğŸ”’\s*ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯/i },
              { name: 'çµ„ç¹”æ¨™æº–ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ', pattern: /##\s*âœ…\s*çµ„ç¹”æ¨™æº–ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ/i },
              { name: 'ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã¸ã®è£œè¶³', pattern: /##\s*ğŸ“–\s*ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã¸ã®è£œè¶³/i }
            ];
            
            const missingSections = [];
            for (const section of requiredSections) {
              if (!section.pattern.test(prBody)) {
                missingSections.push(section.name);
              }
            }
            
            if (missingSections.length > 0) {
              results.passed = false;
              results.errors.push({
                type: 'missing-sections',
                message: `å¿…é ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒä¸è¶³ã—ã¦ã„ã¾ã™: ${missingSections.join(', ')}`,
                sections: missingSections
              });
            }
            
            // ========================================
            // 2. å¤‰æ›´å†…å®¹ã®æ¦‚è¦ã®æ–‡å­—æ•°ãƒã‚§ãƒƒã‚¯
            // ========================================
            const summaryMatch = prBody.match(/##\s*ğŸ“‹\s*å¤‰æ›´å†…å®¹ã®æ¦‚è¦\s*\n+([\s\S]*?)(?=\n##|$)/i);
            if (summaryMatch) {
              const summaryText = summaryMatch[1].trim();
              // ã‚³ãƒ¡ãƒ³ãƒˆè¡Œã€ç©ºè¡Œã€ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³è¨˜å·ã‚’é™¤å¤–
              const cleanedText = summaryText
                .replace(/<!--[\s\S]*?-->/g, '') // HTMLã‚³ãƒ¡ãƒ³ãƒˆé™¤å»
                .replace(/^[#\-*>\s]+/gm, '') // ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³è¨˜å·é™¤å»
                .replace(/\n+/g, ' ') // æ”¹è¡Œã‚’ã‚¹ãƒšãƒ¼ã‚¹ã«
                .trim();
              
              const charCount = cleanedText.length;
              results.stats.summaryCharCount = charCount;
              
              if (charCount < 50) {
                results.passed = false;
                results.errors.push({
                  type: 'insufficient-summary',
                  message: `å¤‰æ›´å†…å®¹ã®æ¦‚è¦ãŒçŸ­ã™ãã¾ã™ï¼ˆç¾åœ¨: ${charCount}æ–‡å­—ã€æœ€ä½: 50æ–‡å­—ï¼‰`,
                  current: charCount,
                  required: 50
                });
              }
            } else {
              results.passed = false;
              results.errors.push({
                type: 'missing-summary',
                message: 'å¤‰æ›´å†…å®¹ã®æ¦‚è¦ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã›ã‚“'
              });
            }
            
            // ========================================
            // 3. ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ç¢ºèªç‡ãƒã‚§ãƒƒã‚¯
            // ========================================
            const allCheckboxes = (prBody.match(/- \[[ x]\]/gi) || []).length;
            const checkedBoxes = (prBody.match(/- \[x\]/gi) || []).length;
            
            results.stats.totalCheckboxes = allCheckboxes;
            results.stats.checkedCheckboxes = checkedBoxes;
            
            if (allCheckboxes > 0) {
              const checkRate = (checkedBoxes / allCheckboxes) * 100;
              results.stats.checkRate = checkRate.toFixed(1);
              
              if (checkRate < 70) {
                results.passed = false;
                results.errors.push({
                  type: 'insufficient-checks',
                  message: `ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ç¢ºèªç‡ãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆç¾åœ¨: ${checkRate.toFixed(1)}%ã€æœ€ä½: 70%ï¼‰`,
                  current: checkRate.toFixed(1),
                  required: 70,
                  checked: checkedBoxes,
                  total: allCheckboxes
                });
              } else if (checkRate < 85) {
                results.warnings.push({
                  type: 'low-check-rate',
                  message: `ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ç¢ºèªç‡ãŒæ¨å¥¨å€¤ã‚’ä¸‹å›ã£ã¦ã„ã¾ã™ï¼ˆç¾åœ¨: ${checkRate.toFixed(1)}%ã€æ¨å¥¨: 85%ä»¥ä¸Šï¼‰`,
                  current: checkRate.toFixed(1),
                  recommended: 85
                });
              }
            } else {
              results.warnings.push({
                type: 'no-checkboxes',
                message: 'ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã‹?'
              });
            }
            
            // ========================================
            // 4. æ—¥æœ¬èªè¨˜è¼‰ã®ç¢ºèª
            // ========================================
            const japanesePattern = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]/;
            if (!japanesePattern.test(prBody)) {
              results.passed = false;
              results.errors.push({
                type: 'no-japanese',
                message: 'æ—¥æœ¬èªã§ã®è¨˜è¼‰ãŒå¿…é ˆã§ã™ï¼ˆçµ„ç¹”æ¨™æº–è¦ä»¶ï¼‰'
              });
            }
            
            // ========================================
            // 5. é–¢é€£ãƒã‚±ãƒƒãƒˆç•ªå·ã®å½¢å¼ãƒã‚§ãƒƒã‚¯
            // ========================================
            const ticketMatch = prBody.match(/##\s*ğŸ¯\s*é–¢é€£ãƒã‚±ãƒƒãƒˆ\s*\n+([\s\S]*?)(?=\n##|$)/i);
            if (ticketMatch) {
              const ticketText = ticketMatch[1].trim();
              const hasTicketNumber = /#\d+|PBI-\d+|Issue-\d+|Ticket-\d+/i.test(ticketText);
              
              if (!hasTicketNumber && !ticketText.includes('ãªã—') && !ticketText.includes('N/A')) {
                results.warnings.push({
                  type: 'unclear-ticket',
                  message: 'é–¢é€£ãƒã‚±ãƒƒãƒˆç•ªå·ãŒæ˜ç¢ºã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å½¢å¼: #123, PBI-456, Issue-789'
                });
              }
            }
            
            // ========================================
            // 6. çµ„ç¹”æ¨™æº–ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã®ç¢ºèª
            // ========================================
            const orgStandardSection = prBody.match(/##\s*âœ…\s*çµ„ç¹”æ¨™æº–ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ\s*\n+([\s\S]*?)(?=\n##|$)/i);
            if (orgStandardSection) {
              const criticalItems = [
                { pattern: /æ—¥æœ¬èªã§ã®è¨˜è¼‰ã‚’å®Œäº†/, name: 'æ—¥æœ¬èªè¨˜è¼‰' },
                { pattern: /ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„ã«æº–æ‹ /, name: 'ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„' },
                { pattern: /ãƒ‘ãƒ–ãƒªãƒƒã‚¯APIã«ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚³ãƒ¡ãƒ³ãƒˆ/, name: 'APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ' },
                { pattern: /CIå“è³ªã‚²ãƒ¼ãƒˆãŒå…¨ã¦é€šé/, name: 'CIå“è³ªã‚²ãƒ¼ãƒˆ' }
              ];
              
              const uncheckedCritical = [];
              for (const item of criticalItems) {
                const itemMatch = orgStandardSection[1].match(new RegExp(`- \\[([x ]?)\\].*${item.pattern.source}`, 'i'));
                if (itemMatch && itemMatch[1] !== 'x') {
                  uncheckedCritical.push(item.name);
                }
              }
              
              if (uncheckedCritical.length > 0) {
                results.warnings.push({
                  type: 'unchecked-critical-items',
                  message: `é‡è¦ãªçµ„ç¹”æ¨™æº–é …ç›®ãŒæœªç¢ºèªã§ã™: ${uncheckedCritical.join(', ')}`,
                  items: uncheckedCritical
                });
              }
            }
            
            // ========================================
            // çµæœã‚’JSONå½¢å¼ã§è¿”ã™
            // ========================================
            core.setOutput('passed', results.passed);
            core.setOutput('results', JSON.stringify(results, null, 2));
            
            return results;
      
      - name: Add label if validation failed
        if: steps.validate.outputs.passed == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: ['pr-description-incomplete']
            });
      
      - name: Remove label if validation passed
        if: steps.validate.outputs.passed == 'true'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                name: 'pr-description-incomplete'
              });
            } catch (error) {
              // ãƒ©ãƒ™ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç„¡è¦–
              console.log('Label not found or already removed');
            }
      
      - name: Post validation comment
        if: steps.validate.outputs.passed == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const results = JSON.parse('${{ steps.validate.outputs.results }}');
            
            // ã‚³ãƒ¡ãƒ³ãƒˆæœ¬æ–‡ã®ä½œæˆ
            let commentBody = '## ğŸš¨ PRè¨˜è¼‰ãƒ¬ãƒ™ãƒ«å“è³ªã‚²ãƒ¼ãƒˆ: æ”¹å–„ãŒå¿…è¦ã§ã™\n\n';
            commentBody += 'ã“ã®PRã®èª¬æ˜ã¯ã€çµ„ç¹”æ¨™æº–ã®è¨˜è¼‰ãƒ¬ãƒ™ãƒ«ã«é”ã—ã¦ã„ã¾ã›ã‚“ã€‚ä»¥ä¸‹ã®é …ç›®ã‚’æ”¹å–„ã—ã¦ãã ã•ã„ã€‚\n\n';
            
            // ã‚¨ãƒ©ãƒ¼é …ç›®
            if (results.errors.length > 0) {
              commentBody += '### âŒ å¿…é ˆæ”¹å–„é …ç›®\n\n';
              for (const error of results.errors) {
                commentBody += `- **${error.message}**\n`;
                if (error.type === 'missing-sections') {
                  commentBody += '  - ä¸è¶³ã‚»ã‚¯ã‚·ãƒ§ãƒ³:\n';
                  for (const section of error.sections) {
                    commentBody += `    - \`${section}\`\n`;
                  }
                } else if (error.type === 'insufficient-summary') {
                  commentBody += `  - ç¾åœ¨: ${error.current}æ–‡å­— â†’ å¿…è¦: ${error.required}æ–‡å­—ä»¥ä¸Š\n`;
                } else if (error.type === 'insufficient-checks') {
                  commentBody += `  - ç¾åœ¨: ${error.checked}/${error.total} (${error.current}%) â†’ å¿…è¦: ${error.required}%ä»¥ä¸Š\n`;
                }
                commentBody += '\n';
              }
            }
            
            // è­¦å‘Šé …ç›®
            if (results.warnings.length > 0) {
              commentBody += '### âš ï¸ æ¨å¥¨æ”¹å–„é …ç›®\n\n';
              for (const warning of results.warnings) {
                commentBody += `- ${warning.message}\n`;
              }
              commentBody += '\n';
            }
            
            // çµ±è¨ˆæƒ…å ±
            commentBody += '### ğŸ“Š ç¾åœ¨ã®è¨˜è¼‰çŠ¶æ³\n\n';
            commentBody += '| é …ç›® | å€¤ | çŠ¶æ…‹ |\n';
            commentBody += '|------|-----|------|\n';
            
            if (results.stats.summaryCharCount !== undefined) {
              const summaryStatus = results.stats.summaryCharCount >= 50 ? 'âœ…' : 'âŒ';
              commentBody += `| å¤‰æ›´å†…å®¹ã®æ¦‚è¦ | ${results.stats.summaryCharCount}æ–‡å­— | ${summaryStatus} (æœ€ä½50æ–‡å­—) |\n`;
            }
            
            if (results.stats.checkRate !== undefined) {
              const checkStatus = parseFloat(results.stats.checkRate) >= 70 ? 'âœ…' : 'âŒ';
              commentBody += `| ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ç¢ºèªç‡ | ${results.stats.checkRate}% (${results.stats.checkedCheckboxes}/${results.stats.totalCheckboxes}) | ${checkStatus} (æœ€ä½70%) |\n`;
            }
            
            commentBody += '\n';
            
            // æ”¹å–„æ–¹æ³•ã®ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹
            commentBody += '### ğŸ’¡ æ”¹å–„æ–¹æ³•\n\n';
            commentBody += '1. **PRãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨**: `.github/PULL_REQUEST_TEMPLATE.md` ã‚’å‚ç…§\n';
            commentBody += '2. **å¿…é ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å…¨ã¦è¨˜è¼‰**: å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®è¦‹å‡ºã—ã¨å†…å®¹ã‚’å«ã‚ã‚‹\n';
            commentBody += '3. **å¤‰æ›´å†…å®¹ã‚’å…·ä½“çš„ã«è¨˜è¼‰**: æœ€ä½50æ–‡å­—ã€æ¨å¥¨100æ–‡å­—ä»¥ä¸Š\n';
            commentBody += '4. **ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ç¢ºèª**: è©²å½“ã™ã‚‹é …ç›®ã« `[x]` ã§ãƒã‚§ãƒƒã‚¯\n';
            commentBody += '5. **æ—¥æœ¬èªã§è¨˜è¼‰**: çµ„ç¹”æ¨™æº–è¦ä»¶ã«ã‚ˆã‚Šå¿…é ˆ\n\n';
            
            // é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
            commentBody += '### ğŸ“š é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ\n\n';
            commentBody += '- [PRãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ](/08-templates/pr-templates/PULL_REQUEST_TEMPLATE.md)\n';
            commentBody += '- [PRãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½¿ç”¨ã‚¬ã‚¤ãƒ‰](/08-templates/pr-templates/README.md)\n';
            commentBody += '- [AI-PRE-WORK-CHECKLIST v1.3.0](/00-guides/AI-PRE-WORK-CHECKLIST.md) - Stage 3å‚ç…§\n\n';
            
            commentBody += '---\n';
            commentBody += '*ã“ã®ãƒã‚§ãƒƒã‚¯ã¯PRèª¬æ˜ã‚’ç·¨é›†ã™ã‚‹ã¨è‡ªå‹•çš„ã«å†å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚*';
            
            // æ—¢å­˜ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ¤œç´¢
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ğŸš¨ PRè¨˜è¼‰ãƒ¬ãƒ™ãƒ«å“è³ªã‚²ãƒ¼ãƒˆ')
            );
            
            if (botComment) {
              // æ—¢å­˜ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ›´æ–°
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              // æ–°è¦ã‚³ãƒ¡ãƒ³ãƒˆã‚’æŠ•ç¨¿
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: commentBody
              });
            }
      
      - name: Post success comment
        if: steps.validate.outputs.passed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const results = JSON.parse('${{ steps.validate.outputs.results }}');
            
            let commentBody = '## âœ… PRè¨˜è¼‰ãƒ¬ãƒ™ãƒ«å“è³ªã‚²ãƒ¼ãƒˆ: åˆæ ¼\n\n';
            commentBody += 'ã“ã®PRã®èª¬æ˜ã¯çµ„ç¹”æ¨™æº–ã®è¨˜è¼‰ãƒ¬ãƒ™ãƒ«ã‚’æº€ãŸã—ã¦ã„ã¾ã™ã€‚\n\n';
            
            // çµ±è¨ˆæƒ…å ±
            if (Object.keys(results.stats).length > 0) {
              commentBody += '### ğŸ“Š è¨˜è¼‰çŠ¶æ³\n\n';
              commentBody += '| é …ç›® | å€¤ | çŠ¶æ…‹ |\n';
              commentBody += '|------|-----|------|\n';
              
              if (results.stats.summaryCharCount !== undefined) {
                commentBody += `| å¤‰æ›´å†…å®¹ã®æ¦‚è¦ | ${results.stats.summaryCharCount}æ–‡å­— | âœ… |\n`;
              }
              
              if (results.stats.checkRate !== undefined) {
                commentBody += `| ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ç¢ºèªç‡ | ${results.stats.checkRate}% (${results.stats.checkedCheckboxes}/${results.stats.totalCheckboxes}) | âœ… |\n`;
              }
              
              commentBody += '\n';
            }
            
            // è­¦å‘Šé …ç›®ï¼ˆã‚ã‚‹å ´åˆï¼‰
            if (results.warnings.length > 0) {
              commentBody += '### âš ï¸ æ¨å¥¨æ”¹å–„é …ç›®ï¼ˆä»»æ„ï¼‰\n\n';
              for (const warning of results.warnings) {
                commentBody += `- ${warning.message}\n`;
              }
              commentBody += '\n';
            }
            
            commentBody += '---\n';
            commentBody += 'æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—: ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã‹ã‚‰ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’ãŠå¾…ã¡ãã ã•ã„ã€‚';
            
            // æ—¢å­˜ã®å¤±æ•—ã‚³ãƒ¡ãƒ³ãƒˆãŒã‚ã‚Œã°å‰Šé™¤
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('PRè¨˜è¼‰ãƒ¬ãƒ™ãƒ«å“è³ªã‚²ãƒ¼ãƒˆ')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: commentBody
              });
            }
      
      - name: Fail if validation failed
        if: steps.validate.outputs.passed == 'false'
        run: |
          echo "::error::PR description does not meet quality standards"
          exit 1
