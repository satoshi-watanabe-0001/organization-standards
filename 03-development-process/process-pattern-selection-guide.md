---
title: "プロセスパターン選択ガイド"
version: "1.1.0"
date: "2025-11-20"
status: "提案"
author: "AI Autonomous Development Analysis"
target_location: "03-development-process/process-pattern-selection-guide.md"
---

# プロセスパターン選択ガイド

## 📋 このドキュメントについて

### 目的
プロジェクトの特性に応じて、**最適な開発プロセスパターン**を選択するためのガイドを提供する。

### 対象
- プロジェクトマネージャー
- テックリード
- 自律型AIエージェント

### 3つのプロセスパターン
```
パターンA: AI最適化型 (推奨・デフォルト)
パターンB: 従来型 (事前詳細設計)
パターンC: リバースエンジニアリング型
```

---

## 🎯 パターン選択フローチャート

```
開始
  ↓
┌─────────────────────────────┐
│ Q1: プロジェクト規模は？      │
└─────────────────────────────┘
  ↓
  小規模（1-2週間）? → YES → パターンC候補
  ↓ NO
  ↓
┌─────────────────────────────┐
│ Q2: 複数チーム連携がある？    │
└─────────────────────────────┘
  ↓
  YES → パターンB候補
  ↓ NO
  ↓
┌─────────────────────────────┐
│ Q3: セキュリティクリティカル？│
└─────────────────────────────┘
  ↓
  YES → パターンB候補
  ↓ NO
  ↓
┌─────────────────────────────┐
│ Q4: 技術スタックは確立済み？  │
└─────────────────────────────┘
  ↓
  YES → パターンA候補（デフォルト）
  ↓ NO
  ↓
パターンB候補（リスク低減）
```

---

## 📊 プロジェクト特性マトリックス

### マトリックス表

| 特性 | パターンA | パターンB | パターンC |
|------|----------|----------|----------|
| **プロジェクト規模** | 中・小規模 | 大規模 | 小規模 |
| **開発期間** | 1-4週間 | 4週間以上 | 1-2週間 |
| **チーム規模** | 1-3名 | 4名以上 | 1-2名 |
| **チーム構成** | 単一チーム | 複数チーム | 単一チーム |
| **技術スタック** | 確立済み | 新規/混在 | 確立済み |
| **セキュリティ要件** | 標準 | 高 | 低 |
| **コンプライアンス** | 標準 | 厳格 | 緩い |
| **変更頻度** | 高い | 低い | 非常に高い |
| **ドキュメント重要度** | 中 | 高 | 低 |
| **AI主導度** | 高 | 中 | 非常に高い |

---

## 🔍 パターン詳細比較

### パターンA: AI最適化型（推奨・デフォルト）

#### 概要
```yaml
特徴:
  - 早期実装による高速検証サイクル
  - 実装後の詳細設計文書化
  - Phase 2A(事前設計) + Phase 5(詳細設計・実装後)
  
実行順序:
  Phase 0 → Phase 1 → Phase 2A(1-2日) → Phase 3 → Phase 4 → Phase 5(並行) → Phase 5

期間:
  合計: 2-3週間
  
効果:
  - リードタイム20%短縮
  - 手戻り30%削減
```

#### 適用条件
```yaml
必須条件:
  - [ ] AI主導開発が可能
  - [ ] チームがAI開発に慣れている
  - [ ] 技術スタックが確立されている
  
推奨条件:
  - [ ] 新規マイクロサービス
  - [ ] 中小規模プロジェクト（1-4週間）
  - [ ] 単一チームまたは少人数チーム（1-3名）
  - [ ] 要件の変更が比較的多い
  - [ ] 迅速なフィードバックサイクルが重要
```

#### メリット
- ✅ 最速で実装開始
- ✅ 実装と設計の乖離なし
- ✅ 変更に柔軟に対応
- ✅ AI開発の特性を活かせる
- ✅ ドキュメントが実装に完全一致

#### デメリット
- ⚠️ 事前承認が必要なプロジェクトには不向き
- ⚠️ 複数チーム連携では調整が難しい
- ⚠️ 大規模プロジェクトではリスクが高い

#### 推奨プロジェクトタイプ
1. **新規マイクロサービス開発**
2. **既存システムへの機能追加（中規模）**
3. **PoC後の正式実装**
4. **技術スタック変更（小規模）**

#### 具体例
```
プロジェクト: ユーザー管理API
規模: 中規模（2週間）
チーム: 2名
技術: TypeScript/Express/PostgreSQL（確立済み）

実行:
  Week 1: Phase 0-1-2.1 + Phase 3開始
  Week 2: Phase 3完了 + Phase 4 + Phase 5(並行)
  Week 3: Phase 5デプロイ

結果: 3週間で完了（従来型なら4週間）
```

---

### パターンB: 従来型（事前詳細設計）

#### 概要
```yaml
特徴:
  - 実装前に詳細設計を完成
  - 承認プロセスを経てから実装
  - Phase 2A(事前設計) + Phase 5(詳細設計・実装前) + 更新(実装後)
  
実行順序:
  Phase 0 → Phase 1 → Phase 2A(1-2日) → Phase 5(3-5日・実装前) → Phase 3 → Phase 4 → Phase 5更新(1日) → Phase 5

期間:
  合計: 3-5週間
  
効果:
  - リスク低減
  - 事前合意による手戻り防止
```

#### 適用条件
```yaml
必須条件:
  - [ ] 事前承認が必要
  - [ ] 複数チーム連携がある
  - [ ] セキュリティクリティカル
  
推奨条件:
  - [ ] 大規模プロジェクト（4週間以上）
  - [ ] 複数チーム（4名以上）
  - [ ] 外部システムとの統合が多い
  - [ ] 厳格なコンプライアンス要件
  - [ ] 変更コストが高い
```

#### メリット
- ✅ リスクが最小化
- ✅ 事前合意で手戻り防止
- ✅ 複数チーム間の調整が容易
- ✅ セキュリティレビューが充実
- ✅ ドキュメントが先に完成

#### デメリット
- ⚠️ 実装開始が遅い
- ⚠️ 設計と実装の乖離リスク
- ⚠️ 変更に対する柔軟性が低い
- ⚠️ ドキュメント更新の二度手間

#### 推奨プロジェクトタイプ
1. **金融システム開発**
2. **医療システム開発**
3. **大規模プラットフォーム構築**
4. **複数ベンダー連携プロジェクト**

#### 具体例
```
プロジェクト: 決済システムAPI
規模: 大規模（6週間）
チーム: 8名（2チーム）
技術: Java/Spring Boot/Oracle（一部新規）

実行:
  Week 1: Phase 0-1-2.1
  Week 2: Phase 5詳細設計（実装前）
  Week 3-4: Phase 3実装
  Week 5: Phase 4 QA
  Week 6: Phase 5更新 + Phase 5デプロイ

結果: 6週間で完了（リスクを最小化）
```

---

### パターンC: リバースエンジニアリング型

#### 概要
```yaml
特徴:
  - Phase 2Aをスキップ
  - 実装優先、ドキュメント後回し
  - Phase 5も簡易版または省略可能
  
実行順序:
  Phase 0 → Phase 1 → Phase 3（直接実装） → Phase 4 → Phase 5(簡易版・省略可) → Phase 5

期間:
  合計: 1-2週間
  
効果:
  - 最速開始
  - 検証優先
```

#### 適用条件
```yaml
必須条件:
  - [ ] 小規模（1-2週間）
  - [ ] 実験的・検証目的
  - [ ] ドキュメント要件が低い
  
推奨条件:
  - [ ] PoC (Proof of Concept)
  - [ ] 技術検証
  - [ ] 小規模バグ修正
  - [ ] プロトタイプ開発
  - [ ] 内部ツール開発
```

#### メリット
- ✅ 最速で開始・完了
- ✅ 柔軟性が最大
- ✅ 検証サイクルが高速
- ✅ オーバーヘッドが最小

#### デメリット
- ⚠️ ドキュメントが不足
- ⚠️ 保守性が低い
- ⚠️ チーム共有が難しい
- ⚠️ 本番運用には不向き

#### 推奨プロジェクトタイプ
1. **PoC開発**
2. **技術検証プロジェクト**
3. **小規模バグ修正（Hotfixを除く）**
4. **内部ツール・スクリプト**

#### 具体例
```
プロジェクト: 新しいキャッシュ戦略のPoC
規模: 小規模（1週間）
チーム: 1名
技術: Redis/TypeScript

実行:
  Day 1-2: Phase 0-1
  Day 3-5: Phase 3実装
  Day 6: Phase 4簡易テスト
  Day 7: 結果レポート作成

結果: 1週間で検証完了
注意: 本実装時はパターンAまたはBを使用
```

---

## 🎯 選択チェックリスト

### ステップ1: プロジェクト情報の収集

```yaml
プロジェクト基本情報:
  名前: [プロジェクト名]
  目的: [PoC/本番実装/機能追加/バグ修正]
  期間: [予定期間]
  チーム規模: [人数]
  技術スタック: [新規/確立済み/混在]
```

### ステップ2: 特性評価

各項目を1-5点でスコアリング:

| 項目 | スコア | 判断基準 |
|------|--------|---------|
| **プロジェクト規模** | 1-5 | 1:小 2:やや小 3:中 4:やや大 5:大 |
| **チーム規模** | 1-5 | 1:1名 2:2名 3:3-4名 4:5-7名 5:8名以上 |
| **セキュリティ要件** | 1-5 | 1:低 2:やや低 3:標準 4:やや高 5:高 |
| **変更頻度** | 1-5 | 1:ほぼなし 2:低 3:中 4:高 5:非常に高 |
| **ドキュメント重要度** | 1-5 | 1:低 2:やや低 3:中 4:やや高 5:高 |
| **技術的複雑性** | 1-5 | 1:単純 2:やや単純 3:中 4:やや複雑 5:複雑 |

### ステップ3: パターン判定

```python
# 簡易判定ロジック
def select_pattern(scores):
    total = sum(scores.values())
    
    # パターンC判定
    if scores['規模'] <= 2 and scores['ドキュメント'] <= 2:
        return "パターンC: リバースエンジニアリング型"
    
    # パターンB判定
    if (scores['チーム'] >= 4 or 
        scores['セキュリティ'] >= 4 or 
        scores['ドキュメント'] >= 4):
        return "パターンB: 従来型"
    
    # デフォルト: パターンA
    return "パターンA: AI最適化型"
```

### ステップ4: 最終確認

```yaml
選択結果: [パターン名]

確認事項:
  - [ ] チーム全員が合意している
  - [ ] ステークホルダーが承認している
  - [ ] 必要なリソースが確保されている
  - [ ] リスクが評価されている
```

---

## 📚 プロジェクトタイプ別推奨パターン

### プロジェクトタイプ一覧

| プロジェクトタイプ | 推奨パターン | 理由 |
|------------------|-------------|------|
| **新規マイクロサービス** | パターンA | 単一チーム、確立技術、変更に柔軟 |
| **既存システム大規模改修** | パターンB | 複数チーム、リスク高、事前合意必要 |
| **バグ修正（中規模）** | パターンA | 迅速対応、既存構造に従う |
| **Hotfix（緊急）** | パターンC | 最速対応、後でドキュメント化 |
| **PoC開発** | パターンC | 検証優先、ドキュメント最小限 |
| **技術検証** | パターンC | 実験的、柔軟性最大 |
| **金融システム** | パターンB | セキュリティ、コンプライアンス |
| **医療システム** | パターンB | 厳格な承認プロセス必要 |
| **内部ツール** | パターンC or A | 要件次第 |
| **顧客向けAPI** | パターンA or B | 規模次第 |
| **モバイルアプリ** | パターンA | UI変更多い、迅速対応必要 |
| **データパイプライン** | パターンA | 反復開発、パフォーマンス検証必要 |
| **機械学習モデル実装** | パターンA | 実験的要素多い |
| **レガシーマイグレーション** | パターンB | リスク高、計画的実施必要 |
| **リファクタリング（大規模）** | パターンB | 影響範囲大、慎重に実施 |
| **リファクタリング（小規模）** | パターンA | 限定的範囲、迅速実施 |

---

## 🔄 パターン変更

### いつパターンを変更すべきか

```yaml
変更トリガー:
  - プロジェクト規模が当初予想より大きい
  - チームが増員された
  - セキュリティ要件が追加された
  - ステークホルダーの要求が変わった
  - 技術的リスクが顕在化した

変更プロセス:
  1. 変更の必要性を評価
  2. テックリードと相談
  3. チームで合意
  4. 新パターンに移行
  5. ドキュメントを更新
```

### パターン変更例

#### ケース1: パターンC → パターンA
```
状況:
  PoCが成功し、本実装へ移行

対応:
  1. PoCコードをリファクタリング
  2. Phase 2Aを実施（事前設計）
  3. Phase 3で正式実装
  4. Phase 4で充実したテスト
  5. Phase 5でドキュメント化
```

#### ケース2: パターンA → パターンB
```
状況:
  プロジェクト途中でチームが増員
  複数チーム連携が必要に

対応:
  1. 現時点で詳細設計を作成
  2. チーム間のAPI契約を明確化
  3. 以降はパターンBで進行
```

---

## 📋 まとめ

### クイックリファレンス

```
【迷ったときのデフォルト】
→ パターンA: AI最適化型

【こんな時はパターンB】
- 大規模プロジェクト
- 複数チーム連携
- セキュリティクリティカル
- 厳格な承認プロセス

【こんな時はパターンC】
- PoC・技術検証
- 小規模バグ修正
- 内部ツール
- 1週間以内の開発
```

### 判断に迷ったら
1. このガイドの選択チェックリストを実施
2. テックリードに相談
3. チームで議論
4. 迷ったらパターンAを選択

---

**作成日**: 2025-11-19  
**次回レビュー**: 3ヶ月後  
**オーナー**: Engineering Leadership Team
