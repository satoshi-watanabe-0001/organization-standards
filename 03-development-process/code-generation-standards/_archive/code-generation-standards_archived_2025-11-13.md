# コード生成標準

**バージョン**: 1.0.0  
**最終更新**: 2024-10-24  
**ドキュメント種別**: 開発プロセス標準  
**階層**: Tier 3 (任意)

---

## 概要

### 目的

コード生成標準は、ソフトウェアプロジェクトで自動生成されるコードの作成、保守、管理のためのガイドラインを提供します。このドキュメントは、生成されたコードが保守可能で一貫性があり、プロジェクト標準に従うことを確保するために、コードジェネレーター、テンプレート、開発ワークフローとの統合のベストプラクティスをカバーします。

### コード生成の利点

- **ボイラープレートの削減**: 反復的なコード記述を排除
- **一貫性**: コードベース全体で統一されたパターンを確保
- **生産性**: 共通パターンの開発を高速化
- **保守性**: パターン定義を一元化
- **品質**: 反復的なタスクでの人的エラーを削減
- **標準準拠**: コーディング標準を自動的に強制

---

## コード生成の種類

### スキーマ駆動生成

データスキーマ、API仕様、またはデータベーススキーマからコードを生成。

**一般的な使用例:**
- OpenAPI仕様からのAPIクライアント/サーバーコード
- スキーマからのデータベースモデル
- JSONスキーマからの型定義
- GraphQLリゾルバーと型

**✅ 良い例 - OpenAPI Client Generation:**
```yaml
# openapi.yaml
openapi: 3.0.0
info:
  title: User API
  version: 1.0.0
paths:
  /users:
    get:
      summary: List users
      parameters:
        - name: limit
          in: query
          schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 20
        - name: offset
          in: query
          schema:
            type: integer
            minimum: 0
            default: 0
      responses:
        200:
          description: List of users
          content:
            application/json:
              schema:
                type: object
                properties:
                  users:
                    type: array
                    items:
                      $ref: '#/components/schemas/User'
                  total:
                    type: integer
components:
  schemas:
    User:
      type: object
      required: [id, email, name]
      properties:
        id:
          type: string
          format: uuid
        email:
          type: string
          format: email
        name:
          type: string
          minLength: 1
          maxLength: 100
        createdAt:
          type: string
          format: date-time
```

**Generated TypeScript Client:**
```typescript
// Generated file: src/generated/api-client.ts
// DO NOT EDIT - This file is automatically generated

export interface User {
  id: string;
  email: string;
  name: string;
  createdAt?: string;
}

export interface ListUsersParams {
  limit?: number;
  offset?: number;
}

export interface ListUsersResponse {
  users: User[];
  total: number;
}

export class UserApiClient {
  constructor(private baseUrl: string, private apiKey: string) {}
  
  async listUsers(params: ListUsersParams = {}): Promise<ListUsersResponse> {
    const url = new URL('/users', this.baseUrl);
    
    if (params.limit !== undefined) {
      url.searchParams.set('limit', params.limit.toString());
    }
    if (params.offset !== undefined) {
      url.searchParams.set('offset', params.offset.toString());
    }
    
    const response = await fetch(url.toString(), {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return response.json();
  }
}
```

**Generation Configuration:**
```json
{
  "generatorName": "typescript-fetch",
  "inputSpec": "openapi.yaml",
  "outputDir": "src/generated",
  "additionalProperties": {
    "typescriptThreePlus": true,
    "supportsES6": true,
    "npmName": "@company/api-client",
    "withoutPrefixEnums": true
  },
  "globalProperties": {
    "generateApiDocumentation": false,
    "generateModelDocumentation": false
  }
}
```

---

### テンプレートベース生成

変数置換を伴うテンプレートを使用したコード生成。

**一般的な使用例:**
- CRUD操作
- コンポーネントの足場
- 設定ファイル
- テストファイル生成

**Example - Entity Generator:**
```handlebars
<!-- templates/entity.hbs -->
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity('{{tableName}}')
export class {{className}} {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  {{#each fields}}
  @Column({{#if this.options}}{{{this.options}}}{{/if}})
  {{this.name}}: {{this.type}};

  {{/each}}
  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

**Generator Configuration:**
```yaml
# entity-config.yaml
entities:
  - name: User
    tableName: users
    fields:
      - name: email
        type: string
        options: "{ unique: true }"
      - name: firstName
        type: string
      - name: lastName
        type: string
      - name: isActive
        type: boolean
        options: "{ default: true }"
        
  - name: Post
    tableName: posts
    fields:
      - name: title
        type: string
      - name: content
        type: string
        options: "{ type: 'text' }"
      - name: published
        type: boolean
        options: "{ default: false }"
```

**Generated Output:**
```typescript
// Generated file: src/entities/User.ts
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  email: string;

  @Column()
  firstName: string;

  @Column()
  lastName: string;

  @Column({ default: true })
  isActive: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

---

### AST（抽象構文木）ベース生成

抽象構文木を構築・操作することによるコード生成。

**一般的な使用例:**
- 複雑なコード変換
- リファクタリングツール
- カスタムlintルール
- コード解析ツール

**Example - TypeScript AST Generation:**
```typescript
import * as ts from 'typescript';

class TypeScriptGenerator {
  generateInterface(name: string, properties: PropertyDefinition[]): ts.InterfaceDeclaration {
    const propertySignatures = properties.map(prop => 
      ts.factory.createPropertySignature(
        undefined, // modifiers
        ts.factory.createIdentifier(prop.name),
        prop.optional ? ts.factory.createToken(ts.SyntaxKind.QuestionToken) : undefined,
        this.createTypeNode(prop.type)
      )
    );

    return ts.factory.createInterfaceDeclaration(
      undefined, // decorators
      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)], // modifiers
      ts.factory.createIdentifier(name),
      undefined, // type parameters
      undefined, // heritage clauses
      propertySignatures
    );
  }

  generateSourceFile(interfaces: ts.InterfaceDeclaration[]): string {
    const sourceFile = ts.factory.createSourceFile(
      interfaces,
      ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),
      ts.NodeFlags.None
    );

    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
    return printer.printFile(sourceFile as ts.SourceFile);
  }

  private createTypeNode(type: string): ts.TypeNode {
    switch (type) {
      case 'string':
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
      case 'number':
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
      case 'boolean':
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
      default:
        return ts.factory.createTypeReferenceNode(type);
    }
  }
}

// Usage
const generator = new TypeScriptGenerator();
const userInterface = generator.generateInterface('User', [
  { name: 'id', type: 'string', optional: false },
  { name: 'email', type: 'string', optional: false },
  { name: 'name', type: 'string', optional: true }
]);

const code = generator.generateSourceFile([userInterface]);
console.log(code);
// Output:
// export interface User {
//   id: string;
//   email: string;
//   name?: string;
// }
```

---

## コード生成ベストプラクティス

### 生成されたコードの識別

手動編集を防ぐために、生成されたコードを常に明確にマーク。

**✅ 良い例:**
```typescript
// ==========================================
// Generated file: src/models/User.ts
// DO NOT EDIT - This file is automatically generated
// 
// Generator: entity-generator v2.1.0
// Template: entity.hbs
// Generated at: 2024-10-24T10:30:00Z
// Source: schemas/user.yaml
// ==========================================

import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

/**
 * User entity - Generated from schema
 * 
 * @generated
 * @source schemas/user.yaml
 */
@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  email: string;

  @Column()
  name: string;
}

// End of generated file
```

**❌ 悪い例:**
```typescript
// No indication this is generated code
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  email: string;

  @Column()
  name: string;
}
```

---

### テンプレート組織化

```
project/
├── templates/
│   ├── entities/
│   │   ├── entity.hbs          # Main entity template
│   │   ├── repository.hbs      # Repository template
│   │   └── service.hbs         # Service template
│   ├── api/
│   │   ├── controller.hbs      # API controller template
│   │   ├── dto.hbs            # Data transfer object template
│   │   └── routes.hbs         # Route definitions template
│   ├── tests/
│   │   ├── unit-test.hbs      # Unit test template
│   │   └── integration-test.hbs # Integration test template
│   └── shared/
│       ├── header.hbs         # Common file header
│       ├── footer.hbs         # Common file footer
│       └── imports.hbs        # Common imports
├── generators/
│   ├── entity-generator.js    # Entity generation logic
│   ├── api-generator.js       # API generation logic
│   └── test-generator.js      # Test generation logic
└── config/
    ├── generator-config.yaml  # Global generator configuration
    └── templates.json         # Template mappings
```

---

### バージョン管理統合

**Generated Code in Git Strategy:**

```gitignore
# .gitignore

# Option 1: Include generated code (recommended for libraries)
# Include generated files but mark them clearly
# Advantages: Easy to review changes, no build dependencies
src/generated/**/*.ts

# Option 2: Exclude generated code (recommended for applications)
# Exclude generated files and generate during build
# Advantages: Smaller repository, always fresh generation
# src/generated/
# !src/generated/.gitkeep

# Always exclude generator build artifacts
generators/dist/
generators/node_modules/
*.generator.log
```

**Pre-commit Hook for Generated Code:**
```bash
#!/bin/bash
# .git/hooks/pre-commit

echo "Checking generated code consistency..."

# Regenerate code to check for changes
npm run generate:code

# Check if any generated files were modified
if git diff --cached --name-only | grep "src/generated/"; then
  echo "Checking if generated code is up to date..."
  
  # Run generation
  npm run generate:code
  
  # Check if generation created any changes
  if ! git diff --quiet; then
    echo "❌ Generated code is out of date. Please run 'npm run generate:code' and commit the changes."
    exit 1
  fi
  
  echo "✅ Generated code is up to date."
fi

echo "Generated code check complete."
```

---

## ジェネレーター実装パターン

### プラグインベースジェネレーターアーキテクチャ

```typescript
interface GeneratorPlugin {
  name: string;
  version: string;
  generate(context: GenerationContext): Promise<GeneratedFile[]>;
  validate(config: any): ValidationResult;
}

interface GenerationContext {
  config: GeneratorConfig;
  inputSchema: any;
  outputDir: string;
  templateEngine: TemplateEngine;
  fileSystem: FileSystem;
  logger: Logger;
}

interface GeneratedFile {
  path: string;
  content: string;
  metadata: {
    generator: string;
    template: string;
    generatedAt: Date;
    sourceHash: string;
  };
}

class GeneratorEngine {
  private plugins: Map<string, GeneratorPlugin> = new Map();
  
  registerPlugin(plugin: GeneratorPlugin): void {
    this.plugins.set(plugin.name, plugin);
  }
  
  async generate(configPath: string): Promise<GenerationResult> {
    const config = await this.loadConfig(configPath);
    const context = await this.createContext(config);
    const results: GeneratedFile[] = [];
    
    for (const pluginConfig of config.plugins) {
      const plugin = this.plugins.get(pluginConfig.name);
      if (!plugin) {
        throw new Error(`Plugin ${pluginConfig.name} not found`);
      }
      
      // Validate plugin configuration
      const validation = plugin.validate(pluginConfig.config);
      if (!validation.valid) {
        throw new Error(`Invalid configuration for ${pluginConfig.name}: ${validation.errors.join(', ')}`);
      }
      
      // Generate files
      const pluginContext = { ...context, config: pluginConfig.config };
      const pluginResults = await plugin.generate(pluginContext);
      results.push(...pluginResults);
    }
    
    // Write generated files
    await this.writeFiles(results);
    
    return {
      generatedFiles: results,
      summary: this.generateSummary(results)
    };
  }
}

// Example plugin implementation
class EntityGeneratorPlugin implements GeneratorPlugin {
  name = 'entity-generator';
  version = '1.0.0';
  
  async generate(context: GenerationContext): Promise<GeneratedFile[]> {
    const { config, templateEngine, outputDir } = context;
    const files: GeneratedFile[] = [];
    
    for (const entityConfig of config.entities) {
      // Generate entity file
      const entityContent = await templateEngine.render('entity.hbs', {
        className: entityConfig.name,
        tableName: entityConfig.tableName,
        fields: entityConfig.fields,
        timestamp: new Date().toISOString()
      });
      
      files.push({
        path: `${outputDir}/entities/${entityConfig.name}.ts`,
        content: entityContent,
        metadata: {
          generator: this.name,
          template: 'entity.hbs',
          generatedAt: new Date(),
          sourceHash: this.calculateHash(entityConfig)
        }
      });
      
      // Generate repository file
      const repositoryContent = await templateEngine.render('repository.hbs', {
        className: entityConfig.name,
        entityName: entityConfig.name
      });
      
      files.push({
        path: `${outputDir}/repositories/${entityConfig.name}Repository.ts`,
        content: repositoryContent,
        metadata: {
          generator: this.name,
          template: 'repository.hbs',
          generatedAt: new Date(),
          sourceHash: this.calculateHash(entityConfig)
        }
      });
    }
    
    return files;
  }
  
  validate(config: any): ValidationResult {
    const errors: string[] = [];
    
    if (!config.entities || !Array.isArray(config.entities)) {
      errors.push('entities must be an array');
    }
    
    for (const entity of config.entities || []) {
      if (!entity.name) {
        errors.push('entity name is required');
      }
      if (!entity.tableName) {
        errors.push('entity tableName is required');
      }
      if (!entity.fields || !Array.isArray(entity.fields)) {
        errors.push('entity fields must be an array');
      }
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
  
  private calculateHash(data: any): string {
    return crypto.createHash('sha256')
      .update(JSON.stringify(data))
      .digest('hex');
  }
}
```

---

### 増分生成

```typescript
interface GenerationMetadata {
  sourceHash: string;
  generatedAt: Date;
  generator: string;
  template: string;
}

class IncrementalGenerator {
  private metadataStore: MetadataStore;
  
  constructor(metadataStore: MetadataStore) {
    this.metadataStore = metadataStore;
  }
  
  async generateIncremental(
    sources: SourceFile[],
    templates: Template[]
  ): Promise<GenerationResult> {
    const results: GeneratedFile[] = [];
    const skipped: string[] = [];
    
    for (const source of sources) {
      const currentHash = this.calculateSourceHash(source);
      const metadata = await this.metadataStore.getMetadata(source.path);
      
      // Skip if source hasn't changed
      if (metadata && metadata.sourceHash === currentHash) {
        skipped.push(source.path);
        continue;
      }
      
      // Generate new files
      const generatedFiles = await this.generateFromSource(source, templates);
      results.push(...generatedFiles);
      
      // Update metadata
      await this.metadataStore.updateMetadata(source.path, {
        sourceHash: currentHash,
        generatedAt: new Date(),
        generator: this.constructor.name,
        template: templates.map(t => t.name).join(',')
      });
    }
    
    return {
      generated: results,
      skipped,
      performance: {
        totalSources: sources.length,
        processed: results.length,
        skippedCount: skipped.length,
        timesSaved: `${((skipped.length / sources.length) * 100).toFixed(1)}%`
      }
    };
  }
  
  private calculateSourceHash(source: SourceFile): string {
    const content = JSON.stringify({
      content: source.content,
      lastModified: source.lastModified,
      dependencies: source.dependencies
    });
    
    return crypto.createHash('sha256').update(content).digest('hex');
  }
}

// Usage in build script
const generator = new IncrementalGenerator(
  new FileBasedMetadataStore('.generator-cache')
);

const sources = await loadSources('schemas/**/*.yaml');
const templates = await loadTemplates('templates/**/*.hbs');

const result = await generator.generateIncremental(sources, templates);

console.log(`Generated ${result.generated.length} files`);
console.log(`Skipped ${result.skipped.length} unchanged files`);
console.log(`Performance improvement: ${result.performance.timesSaved}`);
```

---

## 生成されたコードの品質保証

### 生成されたコードのテスト

```typescript
// Test generator for generated entities
class GeneratedCodeTester {
  async testGeneratedEntity(entityPath: string): Promise<TestResult> {
    const results: TestResult = {
      passed: 0,
      failed: 0,
      errors: []
    };
    
    try {
      // Test 1: Code compiles
      await this.testCompilation(entityPath);
      results.passed++;
      
      // Test 2: Entity can be instantiated
      const EntityClass = await import(entityPath);
      const instance = new EntityClass.default();
      results.passed++;
      
      // Test 3: TypeORM decorators are present
      const metadata = getMetadataArgsStorage();
      const entityMetadata = metadata.tables.find(
        table => table.target === EntityClass.default
      );
      
      if (!entityMetadata) {
        throw new Error('Entity metadata not found');
      }
      results.passed++;
      
      // Test 4: All expected columns are present
      const expectedColumns = this.getExpectedColumns(entityPath);
      const actualColumns = metadata.columns
        .filter(col => col.target === EntityClass.default)
        .map(col => col.propertyName);
        
      for (const expectedColumn of expectedColumns) {
        if (!actualColumns.includes(expectedColumn)) {
          throw new Error(`Missing expected column: ${expectedColumn}`);
        }
      }
      results.passed++;
      
    } catch (error) {
      results.failed++;
      results.errors.push(error.message);
    }
    
    return results;
  }
  
  async testAllGeneratedFiles(pattern: string): Promise<OverallTestResult> {
    const files = await glob(pattern);
    const results: TestResult[] = [];
    
    for (const file of files) {
      if (await this.isGeneratedFile(file)) {
        const result = await this.testGeneratedEntity(file);
        results.push(result);
      }
    }
    
    return {
      totalFiles: files.length,
      totalPassed: results.reduce((sum, r) => sum + r.passed, 0),
      totalFailed: results.reduce((sum, r) => sum + r.failed, 0),
      files: results
    };
  }
  
  private async isGeneratedFile(filePath: string): Promise<boolean> {
    const content = await fs.readFile(filePath, 'utf-8');
    return content.includes('@generated') || 
           content.includes('DO NOT EDIT') ||
           content.includes('automatically generated');
  }
}

// Integration with test suite
describe('Generated Code Quality', () => {
  const tester = new GeneratedCodeTester();
  
  it('should generate valid TypeScript entities', async () => {
    const result = await tester.testAllGeneratedFiles('src/generated/entities/**/*.ts');
    
    expect(result.totalFailed).toBe(0);
    expect(result.totalPassed).toBeGreaterThan(0);
    
    if (result.totalFailed > 0) {
      console.error('Generated code test failures:', result.files);
    }
  });
  
  it('should generate compilable code', async () => {
    const compileResult = await exec('npx tsc --noEmit --project tsconfig.json');
    expect(compileResult.exitCode).toBe(0);
  });
  
  it('should pass linting rules', async () => {
    const lintResult = await exec('npx eslint src/generated/**/*.ts');
    expect(lintResult.exitCode).toBe(0);
  });
});
```

---

### コード品質検証

```typescript
interface CodeQualityRules {
  maxLineLength: number;
  maxComplexity: number;
  requireDocumentation: boolean;
  allowedImports: string[];
  forbiddenPatterns: RegExp[];
}

class GeneratedCodeValidator {
  constructor(private rules: CodeQualityRules) {}
  
  async validateFile(filePath: string): Promise<ValidationResult> {
    const content = await fs.readFile(filePath, 'utf-8');
    const issues: ValidationIssue[] = [];
    
    // Check line length
    const lines = content.split('\n');
    lines.forEach((line, index) => {
      if (line.length > this.rules.maxLineLength) {
        issues.push({
          type: 'line-length',
          line: index + 1,
          message: `Line exceeds ${this.rules.maxLineLength} characters`,
          severity: 'warning'
        });
      }
    });
    
    // Check for forbidden patterns
    this.rules.forbiddenPatterns.forEach(pattern => {
      const matches = content.match(pattern);
      if (matches) {
        issues.push({
          type: 'forbidden-pattern',
          message: `Forbidden pattern found: ${pattern}`,
          severity: 'error'
        });
      }
    });
    
    // Check imports
    const importMatches = content.match(/import .+ from ['"](.+)['"];?/g);
    if (importMatches) {
      importMatches.forEach(importStatement => {
        const importPath = importStatement.match(/from ['"](.+)['"];?/)?.[1];
        if (importPath && !this.isAllowedImport(importPath)) {
          issues.push({
            type: 'invalid-import',
            message: `Import not allowed: ${importPath}`,
            severity: 'error'
          });
        }
      });
    }
    
    // Check documentation
    if (this.rules.requireDocumentation) {
      const hasJSDoc = content.includes('/**');
      const hasClassDoc = /export class \w+/.test(content) && 
                         content.includes('@description');
      
      if (!hasJSDoc && !hasClassDoc) {
        issues.push({
          type: 'missing-documentation',
          message: 'Generated class lacks proper documentation',
          severity: 'warning'
        });
      }
    }
    
    return {
      valid: issues.filter(i => i.severity === 'error').length === 0,
      issues
    };
  }
  
  private isAllowedImport(importPath: string): boolean {
    return this.rules.allowedImports.some(allowed => 
      importPath.startsWith(allowed) || 
      importPath.match(new RegExp(allowed))
    );
  }
}

// Usage in generator
class QualityAwareGenerator {
  private validator: GeneratedCodeValidator;
  
  constructor() {
    this.validator = new GeneratedCodeValidator({
      maxLineLength: 120,
      maxComplexity: 10,
      requireDocumentation: true,
      allowedImports: [
        'typeorm',
        'class-validator',
        'class-transformer',
        '@app/',
        'lodash',
        'date-fns'
      ],
      forbiddenPatterns: [
        /console\.log/,  // No console.log in generated code
        /any/,           // No 'any' type
        /\/\/ TODO/      // No TODO comments
      ]
    });
  }
  
  async generateWithQualityCheck(
    template: string,
    data: any,
    outputPath: string
  ): Promise<void> {
    // Generate code
    const generatedContent = await this.templateEngine.render(template, data);
    
    // Write to temporary file for validation
    const tempPath = `${outputPath}.tmp`;
    await fs.writeFile(tempPath, generatedContent);
    
    // Validate quality
    const validation = await this.validator.validateFile(tempPath);
    
    if (!validation.valid) {
      const errors = validation.issues.filter(i => i.severity === 'error');
      throw new Error(`Generated code quality check failed: ${errors.map(e => e.message).join(', ')}`);
    }
    
    // Move to final location if validation passed
    await fs.move(tempPath, outputPath);
    
    // Log warnings
    const warnings = validation.issues.filter(i => i.severity === 'warning');
    if (warnings.length > 0) {
      console.warn(`Generated code warnings for ${outputPath}:`, warnings);
    }
  }
}
```

---

## 開発ワークフローとの統合

### ビルドパイプライン統合

```yaml
# .github/workflows/code-generation.yml
name: Code Generation and Validation

on:
  push:
    paths:
      - 'schemas/**'
      - 'templates/**'
      - 'generators/**'
  pull_request:
    paths:
      - 'schemas/**'
      - 'templates/**'
      - 'generators/**'

jobs:
  generate-and-validate:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run code generation
        run: |
          npm run generate:clean
          npm run generate:all
          
      - name: Validate generated code
        run: |
          npm run lint:generated
          npm run test:generated
          
      - name: Check for uncommitted changes
        run: |
          if [ -n "$(git status --porcelain src/generated/)" ]; then
            echo "❌ Generated code is out of sync with schemas"
            echo "Please run 'npm run generate:all' and commit the changes"
            git status --porcelain src/generated/
            exit 1
          fi
          
      - name: Upload generation artifacts
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: generation-logs
          path: |
            .generator-cache/
            logs/generation.log
```

**Package.json Scripts:**
```json
{
  "scripts": {
    "generate:clean": "rimraf src/generated && mkdir -p src/generated",
    "generate:all": "npm run generate:entities && npm run generate:api && npm run generate:tests",
    "generate:entities": "node generators/entity-generator.js",
    "generate:api": "openapi-generator-cli generate -i openapi.yaml -g typescript-fetch -o src/generated/api",
    "generate:tests": "node generators/test-generator.js",
    "lint:generated": "eslint src/generated/**/*.ts --fix",
    "test:generated": "jest src/generated/**/*.test.ts",
    "validate:schemas": "ajv validate -s schemas/schema.json -d 'data/**/*.json'",
    "watch:generate": "nodemon --watch schemas --watch templates --exec 'npm run generate:all'"
  }
}
```

---

### IDE統合

**VS Code Extension Configuration:**
```json
// .vscode/settings.json
{
  "files.associations": {
    "*.hbs": "handlebars"
  },
  "emmet.includeLanguages": {
    "handlebars": "html"
  },
  "files.exclude": {
    "**/src/generated/**": false
  },
  "search.exclude": {
    "**/src/generated/**": true
  },
  "files.readonlyInclude": {
    "**/src/generated/**": true
  },
  "typescript.preferences.readonly": true,
  "eslint.workingDirectories": [
    "src/generated"
  ]
}
```

**VS Code Tasks:**
```json
// .vscode/tasks.json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Generate All Code",
      "type": "npm",
      "script": "generate:all",
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "presentation": {
        "echo": true,
        "reveal": "always",
        "focus": false,
        "panel": "shared"
      }
    },
    {
      "label": "Watch and Generate",
      "type": "npm",
      "script": "watch:generate",
      "runOptions": {
        "runOn": "folderOpen"
      },
      "presentation": {
        "echo": false,
        "reveal": "silent",
        "focus": false,
        "panel": "shared"
      }
    }
  ]
}
```

---

## Devin AI実践例

### ジェネレーター開発

**Prompt 1: Create Custom Code Generator**
```
Create a custom code generator for this project with the following requirements:

Project Type: [Node.js/React/etc.]
Target: Generate [CRUD operations/API endpoints/components/etc.]

Requirements:
1. Template-based generation using Handlebars
2. Configuration via YAML files
3. Support for incremental generation
4. Generated code quality validation
5. Integration with build pipeline

Components needed:
- Generator engine with plugin architecture
- Template organization structure
- Configuration schema and validation
- CLI interface for generator commands
- Build script integration

Include:
- Template examples for common patterns
- Configuration file examples
- Usage documentation
- Quality validation rules
- CI/CD integration scripts

Focus on maintainability and extensibility.
```

**Prompt 2: Generate OpenAPI Client Code**
```
Generate a complete API client from this OpenAPI specification:

[Paste OpenAPI spec or provide URL]

Requirements:
1. TypeScript client with proper typing
2. HTTP client abstraction (fetch/axios)
3. Error handling and retry logic
4. Request/response interceptors
5. Authentication handling
6. Generated documentation

Generate:
- Client class with all endpoint methods
- TypeScript interfaces for all models
- Error handling classes
- Configuration options
- Usage examples
- Unit test templates

Ensure the generated code follows these standards:
- ESLint compliance
- Proper JSDoc documentation
- Consistent naming conventions
- Tree-shakable exports
```

### テンプレート作成

**Prompt 3: Create Entity Generation Templates**
```
Create Handlebars templates for generating database entities with the following features:

Database: [PostgreSQL/MongoDB/etc.]
ORM: [TypeORM/Prisma/Mongoose/etc.]

Templates needed:
1. Entity class template
2. Repository template
3. Service layer template
4. DTO (Data Transfer Object) template
5. Test template

Features for each template:
- Proper typing and decorators
- Validation rules
- Relationships handling
- Audit fields (createdAt, updatedAt)
- Soft delete support
- Custom field types

Input schema format:
```yaml
entities:
  - name: User
    tableName: users
    fields:
      - name: email
        type: string
        unique: true
        required: true
      - name: name
        type: string
        required: true
    relationships:
      - type: oneToMany
        entity: Post
        field: posts
```

Include helper functions for common transformations (camelCase, PascalCase, pluralization).
```

**Prompt 4: Build React Component Generator**
```
Create a React component generator that produces components following our design system:

Component Types:
- Functional components with hooks
- TypeScript interfaces
- Styled-components integration
- Storybook stories
- Unit tests

Input configuration:
```yaml
components:
  - name: UserCard
    type: display
    props:
      - name: user
        type: User
        required: true
      - name: onEdit
        type: function
        optional: true
    features:
      - responsive
      - accessible
      - themeable
```

Generated files for each component:
- Component.tsx (main component)
- Component.styles.ts (styled-components)
- Component.stories.tsx (Storybook)
- Component.test.tsx (Jest/RTL tests)
- index.ts (barrel export)

Include proper TypeScript typing, accessibility attributes, and responsive design patterns.
```

### 品質保証

**Prompt 5: Create Generated Code Validator**
```
Build a comprehensive validator for generated code quality:

Validation Rules:
1. Code compilation (TypeScript/JavaScript)
2. Linting compliance (ESLint rules)
3. Code style consistency
4. Import/export correctness
5. Documentation completeness
6. Test coverage requirements
7. Performance considerations

Features:
- Configurable rule sets
- Multiple output formats (JSON, XML, HTML report)
- Integration with CI/CD pipelines
- Custom rule definitions
- Severity levels (error, warning, info)

Validation categories:
- Syntax and compilation
- Code quality metrics
- Security vulnerabilities
- Performance anti-patterns
- Documentation standards
- Test quality

Include configuration examples and integration scripts for popular CI/CD platforms.
```

**Prompt 6: Generate Test Cases for Generated Code**
```
Create a test generator that produces comprehensive test suites for generated code:

Test Types:
1. Unit tests for individual methods
2. Integration tests for API endpoints
3. Contract tests for interfaces
4. Property-based tests for data validation
5. Performance tests for critical paths

Testing Frameworks: [Jest/Vitest/Mocha + Chai/etc.]

For each generated entity/component, create:
- Basic functionality tests
- Edge case and error handling tests
- Mock data generators
- Test utilities and helpers
- Performance benchmark tests

Test generation should be based on the same schemas/configs used for main code generation.
Include realistic test data generation and proper mocking strategies.

Focus on high coverage and meaningful test scenarios rather than just structural tests.
```

### CI/CD統合

**Prompt 7: Setup Generation Pipeline**
```
Create a complete CI/CD pipeline for code generation with the following requirements:

Pipeline Stages:
1. Schema validation
2. Template compilation
3. Code generation
4. Quality validation
5. Test execution
6. Documentation generation
7. Artifact publishing

CI/CD Platform: [GitHub Actions/GitLab CI/Jenkins/etc.]

Features needed:
- Incremental generation (only changed schemas)
- Parallel processing for large codebases
- Caching for performance
- Error reporting and notifications
- Artifact management
- Multi-environment deployment

Include:
- Pipeline configuration files
- Quality gates and approval processes
- Rollback mechanisms
- Performance monitoring
- Integration with existing workflows

Ensure the pipeline is robust, fast, and provides clear feedback to developers.
```

**Prompt 8: Create Generator Monitoring Dashboard**
```
Build a monitoring dashboard for code generation processes:

Metrics to track:
1. Generation frequency and success rates
2. Template usage statistics
3. Generated code quality trends
4. Build time impacts
5. Developer adoption metrics
6. Error patterns and failures

Dashboard Features:
- Real-time generation status
- Historical trend analysis
- Quality metrics visualization
- Performance impact tracking
- Alert configuration
- Team/project breakdown

Technical Requirements:
- Web-based dashboard (React/Vue/etc.)
- API for metrics collection
- Database for historical data
- Integration with existing monitoring tools
- Export capabilities for reports

Include sample data and deployment instructions.
```

### 高度な生成パターン

**Prompt 9: Implement Multi-Target Generator**
```
Create a generator that can produce code for multiple platforms/languages from a single source:

Source: Domain model definitions (JSON Schema/GraphQL/etc.)
Targets:
- TypeScript interfaces
- Python dataclasses
- Java POJOs
- C# DTOs
- SQL DDL scripts
- JSON schemas
- GraphQL schemas

Features:
- Shared validation logic across platforms
- Consistent naming conventions
- Type mapping between languages
- Custom annotations/decorators per platform
- Dependency management

Architecture:
- Abstract syntax tree (AST) based generation
- Platform-specific code emitters
- Shared template library
- Plugin system for extensibility

Include examples showing how the same domain model generates consistent code across all target platforms.
```

**Prompt 10: Build Schema Evolution Generator**
```
Create a generator that handles schema evolution and migration:

Capabilities:
1. Detect schema changes (additions, deletions, modifications)
2. Generate migration scripts (database, API, client code)
3. Create compatibility layers for breaking changes
4. Generate deprecation warnings
5. Update documentation automatically

Migration Types:
- Database schema migrations
- API version compatibility
- Client code updates
- Configuration file updates
- Test data migrations

Features:
- Backwards compatibility analysis
- Breaking change detection
- Migration strategy recommendations
- Automated testing for migrations
- Rollback script generation

Input: Before/after schemas
Output: Complete migration package with scripts, documentation, and tests

Focus on enterprise-grade schema evolution with minimal downtime and maximum compatibility.
```

---

## パフォーマンスと最適化

### 生成パフォーマンス

```typescript
class PerformanceOptimizedGenerator {
  private templateCache: Map<string, CompiledTemplate> = new Map();
  private schemaCache: Map<string, ParsedSchema> = new Map();
  
  constructor(
    private concurrency: number = 4,
    private cacheEnabled: boolean = true
  ) {}
  
  async generateBatch(
    sources: GenerationSource[],
    options: GenerationOptions
  ): Promise<BatchGenerationResult> {
    const startTime = Date.now();
    
    // Pre-compile templates
    await this.precompileTemplates(options.templates);
    
    // Process in batches for memory efficiency
    const batches = this.createBatches(sources, this.concurrency);
    const results: GeneratedFile[] = [];
    
    for (const batch of batches) {
      const batchResults = await Promise.all(
        batch.map(source => this.generateFromSource(source, options))
      );
      results.push(...batchResults.flat());
      
      // Optional: Force garbage collection between batches
      if (global.gc) {
        global.gc();
      }
    }
    
    const endTime = Date.now();
    
    return {
      files: results,
      performance: {
        totalTime: endTime - startTime,
        filesPerSecond: results.length / ((endTime - startTime) / 1000),
        cacheHitRate: this.calculateCacheHitRate(),
        memoryUsage: process.memoryUsage()
      }
    };
  }
  
  private async precompileTemplates(templates: TemplateConfig[]): Promise<void> {
    if (!this.cacheEnabled) return;
    
    const compilationPromises = templates.map(async template => {
      if (!this.templateCache.has(template.path)) {
        const compiled = await this.compileTemplate(template);
        this.templateCache.set(template.path, compiled);
      }
    });
    
    await Promise.all(compilationPromises);
  }
  
  private createBatches<T>(items: T[], batchSize: number): T[][] {
    const batches: T[][] = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }
}

// Performance monitoring
class GenerationPerformanceMonitor {
  private metrics: PerformanceMetric[] = [];
  
  async measureGeneration<T>(
    operation: string,
    fn: () => Promise<T>
  ): Promise<T> {
    const startTime = process.hrtime.bigint();
    const startMemory = process.memoryUsage();
    
    try {
      const result = await fn();
      
      const endTime = process.hrtime.bigint();
      const endMemory = process.memoryUsage();
      const duration = Number(endTime - startTime) / 1_000_000; // Convert to milliseconds
      
      this.metrics.push({
        operation,
        duration,
        memoryDelta: {
          rss: endMemory.rss - startMemory.rss,
          heapUsed: endMemory.heapUsed - startMemory.heapUsed,
          heapTotal: endMemory.heapTotal - startMemory.heapTotal
        },
        timestamp: new Date()
      });
      
      return result;
      
    } catch (error) {
      const endTime = process.hrtime.bigint();
      const duration = Number(endTime - startTime) / 1_000_000;
      
      this.metrics.push({
        operation,
        duration,
        error: error.message,
        timestamp: new Date()
      });
      
      throw error;
    }
  }
  
  getPerformanceReport(): PerformanceReport {
    const grouped = this.groupMetricsByOperation();
    
    return {
      summary: {
        totalOperations: this.metrics.length,
        averageDuration: this.calculateAverageDuration(),
        slowestOperation: this.findSlowestOperation(),
        memoryTrend: this.calculateMemoryTrend()
      },
      operationBreakdown: grouped,
      recommendations: this.generateRecommendations(grouped)
    };
  }
  
  private generateRecommendations(
    grouped: Record<string, PerformanceMetric[]>
  ): string[] {
    const recommendations: string[] = [];
    
    Object.entries(grouped).forEach(([operation, metrics]) => {
      const avgDuration = metrics.reduce((sum, m) => sum + m.duration, 0) / metrics.length;
      const avgMemory = metrics.reduce((sum, m) => sum + (m.memoryDelta?.heapUsed || 0), 0) / metrics.length;
      
      if (avgDuration > 1000) { // > 1 second
        recommendations.push(`Consider optimizing ${operation}: average duration ${avgDuration.toFixed(2)}ms`);
      }
      
      if (avgMemory > 50 * 1024 * 1024) { // > 50MB
        recommendations.push(`High memory usage in ${operation}: average ${(avgMemory / 1024 / 1024).toFixed(2)}MB`);
      }
    });
    
    return recommendations;
  }
}
```

---

## 保守と進化

### テンプレートバージョニング

```typescript
interface TemplateVersion {
  version: string;
  compatibleSchemaVersions: string[];
  deprecatedAt?: Date;
  removedAt?: Date;
  migrationGuide?: string;
}

class VersionedTemplateManager {
  private templates: Map<string, Map<string, Template>> = new Map();
  
  registerTemplate(
    name: string,
    version: string,
    template: Template,
    metadata: TemplateVersion
  ): void {
    if (!this.templates.has(name)) {
      this.templates.set(name, new Map());
    }
    
    const templateVersions = this.templates.get(name)!;
    templateVersions.set(version, { ...template, metadata });
  }
  
  getTemplate(
    name: string,
    requestedVersion?: string,
    schemaVersion?: string
  ): Template {
    const templateVersions = this.templates.get(name);
    if (!templateVersions) {
      throw new Error(`Template ${name} not found`);
    }
    
    let selectedVersion: string;
    
    if (requestedVersion) {
      // Specific version requested
      if (!templateVersions.has(requestedVersion)) {
        throw new Error(`Template ${name} version ${requestedVersion} not found`);
      }
      selectedVersion = requestedVersion;
    } else {
      // Auto-select compatible version
      selectedVersion = this.selectCompatibleVersion(
        templateVersions,
        schemaVersion
      );
    }
    
    const template = templateVersions.get(selectedVersion)!;
    
    // Check for deprecation warnings
    if (template.metadata.deprecatedAt) {
      console.warn(
        `Template ${name}@${selectedVersion} is deprecated since ${template.metadata.deprecatedAt}`
      );
      
      if (template.metadata.migrationGuide) {
        console.warn(`Migration guide: ${template.metadata.migrationGuide}`);
      }
    }
    
    return template;
  }
  
  private selectCompatibleVersion(
    templateVersions: Map<string, Template>,
    schemaVersion?: string
  ): string {
    if (!schemaVersion) {
      // Return latest version
      const versions = Array.from(templateVersions.keys());
      return this.getLatestVersion(versions);
    }
    
    // Find compatible version
    for (const [version, template] of templateVersions) {
      if (template.metadata.compatibleSchemaVersions.includes(schemaVersion)) {
        return version;
      }
    }
    
    throw new Error(
      `No compatible template version found for schema version ${schemaVersion}`
    );
  }
  
  generateMigrationPlan(
    templateName: string,
    fromVersion: string,
    toVersion: string
  ): MigrationPlan {
    const fromTemplate = this.getTemplate(templateName, fromVersion);
    const toTemplate = this.getTemplate(templateName, toVersion);
    
    return {
      templateName,
      fromVersion,
      toVersion,
      changes: this.analyzeTemplateChanges(fromTemplate, toTemplate),
      breakingChanges: this.identifyBreakingChanges(fromTemplate, toTemplate),
      migrationSteps: this.generateMigrationSteps(fromTemplate, toTemplate),
      estimatedEffort: this.estimateMigrationEffort(fromTemplate, toTemplate)
    };
  }
}

// Usage example
const templateManager = new VersionedTemplateManager();

// Register template versions
templateManager.registerTemplate('entity', '1.0.0', entityTemplateV1, {
  version: '1.0.0',
  compatibleSchemaVersions: ['1.0.0', '1.1.0']
});

templateManager.registerTemplate('entity', '2.0.0', entityTemplateV2, {
  version: '2.0.0',
  compatibleSchemaVersions: ['2.0.0', '2.1.0'],
  migrationGuide: 'https://docs.company.com/templates/entity-v2-migration'
});

templateManager.registerTemplate('entity', '1.5.0', entityTemplateV15, {
  version: '1.5.0',
  compatibleSchemaVersions: ['1.0.0', '1.1.0', '1.2.0'],
  deprecatedAt: new Date('2024-12-01'),
  removedAt: new Date('2025-06-01'),
  migrationGuide: 'Migrate to v2.0.0 for continued support'
});
```

---

### ジェネレーター分析

```typescript
interface GeneratorUsageAnalytics {
  templateUsage: Record<string, number>;
  generationFrequency: { date: string; count: number }[];
  errorPatterns: { error: string; count: number; lastSeen: Date }[];
  performanceMetrics: {
    averageGenerationTime: number;
    p95GenerationTime: number;
    memoryUsage: number;
  };
  userAdoption: {
    activeUsers: number;
    newUsers: number;
    churned: number;
  };
}

class GeneratorAnalyticsCollector {
  constructor(
    private metricsStore: MetricsStore,
    private eventBus: EventBus
  ) {
    this.setupEventListeners();
  }
  
  private setupEventListeners(): void {
    this.eventBus.on('generation:started', this.onGenerationStarted.bind(this));
    this.eventBus.on('generation:completed', this.onGenerationCompleted.bind(this));
    this.eventBus.on('generation:failed', this.onGenerationFailed.bind(this));
    this.eventBus.on('template:used', this.onTemplateUsed.bind(this));
  }
  
  private async onGenerationStarted(event: GenerationStartedEvent): Promise<void> {
    await this.metricsStore.recordEvent({
      type: 'generation_started',
      userId: event.userId,
      projectId: event.projectId,
      templateCount: event.templates.length,
      timestamp: new Date()
    });
  }
  
  private async onGenerationCompleted(event: GenerationCompletedEvent): Promise<void> {
    await this.metricsStore.recordEvent({
      type: 'generation_completed',
      userId: event.userId,
      projectId: event.projectId,
      duration: event.duration,
      filesGenerated: event.filesGenerated,
      templateCount: event.templateCount,
      timestamp: new Date()
    });
    
    // Track performance metrics
    await this.recordPerformanceMetrics(event);
  }
  
  private async onGenerationFailed(event: GenerationFailedEvent): Promise<void> {
    await this.metricsStore.recordEvent({
      type: 'generation_failed',
      userId: event.userId,
      projectId: event.projectId,
      error: event.error,
      templateName: event.templateName,
      timestamp: new Date()
    });
  }
  
  async generateUsageReport(
    startDate: Date,
    endDate: Date
  ): Promise<GeneratorUsageAnalytics> {
    const events = await this.metricsStore.getEvents({
      startDate,
      endDate,
      types: ['generation_started', 'generation_completed', 'generation_failed', 'template_used']
    });
    
    return {
      templateUsage: this.calculateTemplateUsage(events),
      generationFrequency: this.calculateGenerationFrequency(events),
      errorPatterns: this.analyzeErrorPatterns(events),
      performanceMetrics: this.calculatePerformanceMetrics(events),
      userAdoption: this.calculateUserAdoption(events)
    };
  }
  
  async generateRecommendations(): Promise<string[]> {
    const report = await this.generateUsageReport(
      new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // Last 30 days
      new Date()
    );
    
    const recommendations: string[] = [];
    
    // Template usage recommendations
    const unusedTemplates = Object.entries(report.templateUsage)
      .filter(([_, count]) => count === 0)
      .map(([template, _]) => template);
      
    if (unusedTemplates.length > 0) {
      recommendations.push(
        `Consider removing unused templates: ${unusedTemplates.join(', ')}`
      );
    }
    
    // Performance recommendations
    if (report.performanceMetrics.averageGenerationTime > 10000) { // 10 seconds
      recommendations.push(
        'Generation performance is below target. Consider optimizing templates or caching.'
      );
    }
    
    // Error pattern recommendations
    const frequentErrors = report.errorPatterns
      .filter(error => error.count > 10)
      .sort((a, b) => b.count - a.count);
      
    if (frequentErrors.length > 0) {
      recommendations.push(
        `Address frequent errors: ${frequentErrors.slice(0, 3).map(e => e.error).join(', ')}`
      );
    }
    
    return recommendations;
  }
  
  private calculateTemplateUsage(events: AnalyticsEvent[]): Record<string, number> {
    const usage: Record<string, number> = {};
    
    events
      .filter(e => e.type === 'template_used')
      .forEach(event => {
        const templateName = event.templateName;
        usage[templateName] = (usage[templateName] || 0) + 1;
      });
      
    return usage;
  }
  
  private calculateGenerationFrequency(events: AnalyticsEvent[]): { date: string; count: number }[] {
    const frequency: Record<string, number> = {};
    
    events
      .filter(e => e.type === 'generation_completed')
      .forEach(event => {
        const date = event.timestamp.toISOString().split('T')[0];
        frequency[date] = (frequency[date] || 0) + 1;
      });
      
    return Object.entries(frequency)
      .map(([date, count]) => ({ date, count }))
      .sort((a, b) => a.date.localeCompare(b.date));
  }
}
```

---

## チェックリスト

### コード生成セットアップチェックリスト

**Project Setup / プロジェクトセットアップ:**
- [ ] Code generation directory structure established
- [ ] Template organization defined
- [ ] Generator configuration files created
- [ ] Build scripts integrated
- [ ] Version control strategy decided (.gitignore configured)

**Template Development / テンプレート開発:**
- [ ] Template engine selected and configured
- [ ] Common template patterns established
- [ ] Template versioning strategy implemented
- [ ] Helper functions library created
- [ ] Template testing framework setup

**Quality Assurance / 品質保証:**
- [ ] Generated code validation rules defined
- [ ] Automated testing for generated code implemented
- [ ] Code quality gates configured
- [ ] Performance benchmarks established
- [ ] Error handling and logging implemented

**Integration / 統合:**
- [ ] CI/CD pipeline integration completed
- [ ] IDE/editor support configured
- [ ] Development workflow documented
- [ ] Team training conducted
- [ ] Monitoring and analytics setup

---

### 生成されたコード品質チェックリスト

**Code Structure / コード構造:**
- [ ] Generated code follows project conventions
- [ ] Proper imports and exports
- [ ] Consistent naming patterns
- [ ] Appropriate modularization
- [ ] Clear separation of concerns

**Documentation / ドキュメンテーション:**
- [ ] Generated files clearly marked
- [ ] Proper JSDoc/comments included
- [ ] Type annotations present (TypeScript)
- [ ] Usage examples provided
- [ ] API documentation generated

**Testing / テスト:**
- [ ] Generated code compiles without errors
- [ ] Passes all linting rules
- [ ] Unit tests exist and pass
- [ ] Integration tests cover generated code
- [ ] Performance tests validate efficiency

**Maintainability / 保守性:**
- [ ] Generated code is readable
- [ ] No hardcoded values (configurable)
- [ ] Error handling implemented
- [ ] Logging and debugging support
- [ ] Update/regeneration process documented

---

### ジェネレーター保守チェックリスト

**Regular Maintenance / 定期保守:**
- [ ] Template versions reviewed and updated
- [ ] Deprecated templates identified
- [ ] Generator performance monitored
- [ ] Error patterns analyzed
- [ ] Usage analytics reviewed

**Quality Improvement / 品質改善:**
- [ ] Generated code quality trends analyzed
- [ ] User feedback collected and addressed
- [ ] Template optimization opportunities identified
- [ ] New template patterns documented
- [ ] Best practices updated

**Evolution Management / 進化管理:**
- [ ] Schema changes impact assessed
- [ ] Breaking changes communicated
- [ ] Migration guides provided
- [ ] Backward compatibility maintained
- [ ] Future roadmap planned

---

## 参考資料

### 主要リソース

- Martin Fowlerの「Code Generation Patterns」
- OpenAPI Generator - 多言語コード生成
- Handlebars.js - テンプレートエンジン
- AST Explorer - 抽象構文木の可視化
- Yeoman - コード足場ツール

### ツールとライブラリ

**Code Generation Tools:**
- OpenAPI Generator: https://openapi-generator.tech/
- Plop: https://plopjs.com/
- Hygen: https://hygen.io/
- GraphQL Code Generator: https://graphql-code-generator.com/

**Template Engines:**
- Handlebars: https://handlebarsjs.com/
- Mustache: https://mustache.github.io/
- EJS: https://ejs.co/
- Nunjucks: https://mozilla.github.io/nunjucks/

### 関連標準
- [03-development-process/README.md](../README.md)
- [01-coding-standards/README.md](../../01-coding-standards/README.md)
- [04-quality-standards/README.md](../../04-quality-standards/README.md)

---

## 変更履歴

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0.0 | 2024-10-24 | Initial version | Development Team |

---

**Document Owner / ドキュメント所有者**: Development Team  
**Review Cycle / レビューサイクル**: Quarterly / 四半期ごと  
**Next Review Date / 次回レビュー日**: 2025-01-24