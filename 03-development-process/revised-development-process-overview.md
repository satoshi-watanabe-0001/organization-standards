---
version: "3.5.0"
last_updated: "2025-11-20"
status: "active"
owner: "Engineering Team"
category: "development-process"
change_type: "major - Phase番号リナンバリング完全移行"
changelog:
  - version: "3.4.0"
  - version: "3.5.0"
    date: "2025-11-20"
    changes: "Phase番号リナンバリング完了（旧番号表記削除、完全移行）"
    date: "2025-11-20"
    changes: "Phase番号リナンバリング実施（移行期間: 〜2025-12-20）"
  - version: "3.3.0"
    date: "2025-11-19"
    changes: "Phase 5並行実施の詳細タイムライン、トリガー、FAQを追加"
  - version: "3.2.0"
    date: "2025-11-19"
    changes: "Phase 2A/2B リネーム対応（Phase 2A/2.2から変更）"
---

# 改訂版 開発プロセス概要 / Revised Development Process Overview

## 📋 変更概要

### 主要変更点

**変更前**: Phase 2 (設計) - 単一フェーズ、実装前に実施
**変更後**: Phase 2A (事前設計) + Phase 5 (詳細設計) - 実行順序を明確化

### Phase番号と実行順序の関係

```yaml
重要な注意:
  phase_2_1:
    phase_number: "Phase 2A"
    execution_order: "Phase 1 の後、Phase 3 の前"
    timing: "実装開始前"
  
  phase_2_2:
    phase_number: "Phase 5"
    execution_order: "Phase 4 の後、Phase 6 の前"
    timing: "実装完了後 (または Phase 3-4 と並行)"
```

**Phase 5 は Phase 4 の後に実行されます**

### 変更の目的

1. **AI開発の特性を活かす**: 早期実装による高速検証サイクル
2. **手戻りの削減**: 実装後の確定情報に基づく詳細設計
3. **並行作業の実現**: 実装とドキュメント化の並行化によるリードタイム短縮
4. **柔軟性の向上**: プロジェクトタイプに応じた適切なアプローチ選択
### ⚠️ Phase番号変更の移行期間について

**Phase番号のリナンバリングを実施しました**（2025-11-20）:

| 旧番号 | 新番号 | 名称 |
|--------|--------|------|
| Phase 2B | Phase 5 | 詳細設計 |
| Phase 5 | Phase 6 | デプロイメント |
| Phase 6 | Phase 7 | 運用・監視 |

**目的**: Phase番号と実行順序を完全に一致させ、新規参加者の混乱を解消

**完了日**: 2025-11-20

**重要**: 実行順序は変更されていません。Phase 5は引き続きPhase 4の後に実行されます。


---

## 🔄 改訂版開発ライフサイクル

### フェーズ全体像（実行順序）

```
実行順序 → Phase番号 → フェーズ名

1. Phase 0: 要件分析・企画 (Requirements & Planning)
   期間: 1-2週間
   ↓
2. Phase 1: プロジェクト初期化 (Project Initialization)
   期間: 1-3日
   ↓
3. Phase 2A: 事前設計 (Pre-Implementation Design) ★NEW
   期間: 1-2日
   目的: 実装の方向性を定める最小限の設計
   別名: Preliminary Design
   ↓
4. Phase 3: 実装 (Implementation)
   期間: 1-4週間
   ↓
5. Phase 4: レビュー・QA (Review & QA)
   期間: 3-5日
   ↓
6. Phase 5: 詳細設計 (Post-Implementation Design) ★NEW
   期間: 2-3日
   目的: 実装内容の文書化と設計の整理
   別名: Detailed Design
   実行順序: Phase 4 の後（または Phase 3-4 と並行）
   ↓
7. Phase 6: デプロイメント (Deployment)
   期間: 数時間～1日
   ↓
8. Phase 7: 運用・保守 (Operations & Maintenance)
   期間: 継続的
```

### フェーズ実行戦略の選択

プロジェクトタイプに応じて3つの実行パターンから選択:

#### **パターンA: AI最適化型** (推奨・デフォルト)

**実行順序**:
```
Phase 0 → Phase 1 → Phase 2A (事前設計 1-2日)
                        ↓
                   Phase 3 (実装 1-4週間)
                        ↓
                   Phase 4 (レビュー・QA 3-5日)
                        ↓
              Phase 5 (詳細設計 2-3日)
              ※Phase 3-4 と並行実施も可能
                        ↓
                   Phase 6 → Phase 7
```

**タイミング詳細**:
- Phase 2A: 実装開始前に実施
- Phase 5: Phase 3 実装中に並行開始、Phase 4 完了時に完成
  - Week 1-2: Phase 3 実装中に 20-30% 進行
  - Week 3: Phase 4 レビュー中に 30-40% 進行
  - Phase 4 完了後: 残り 30-40% 完成

**適用**: 新規マイクロサービス、AI主導開発、中小規模プロジェクト

**効果**: リードタイム20%短縮、手戻り30%削減

---

#### **パターンB: 従来型** (事前詳細設計)

**実行順序**:
```
Phase 0 → Phase 1 → Phase 2A (事前設計 1-2日)
                        ↓
                   Phase 5 (詳細設計 3-5日)
                   ※実装前に詳細設計を完成
                        ↓
                   Phase 3 (実装 1-4週間)
                        ↓
                   Phase 4 (レビュー・QA 3-5日)
                        ↓
              Phase 5 更新 (1日)
              ※実装との差分を反映
                        ↓
                   Phase 6 → Phase 7
```

**タイミング詳細**:
- Phase 2A: 実装開始前
- Phase 5: 実装開始前に詳細設計を完成
- Phase 5 更新: 実装完了後に最終版に更新

**適用**: 複数チーム連携、セキュリティクリティカル、大規模プロジェクト

**効果**: リスク低減、事前合意による手戻り防止

---

#### **パターンC: リバースエンジニアリング型**

**実行順序**:
```
Phase 0 → Phase 1 → Phase 3 (実装 1-4週間)
              ※Phase 2A をスキップ
                        ↓
                   Phase 4 (レビュー・QA 3-5日)
                        ↓
              Phase 5 (詳細設計 1-2日)
              ※簡易版または省略可能
                        ↓
                   Phase 6 → Phase 7
```

**タイミング詳細**:
- Phase 2A: スキップ
- Phase 5: Phase 4 完了後に実装内容を文書化

**適用**: 小規模改修、技術検証、PoC

**効果**: 最速開始、検証優先

---

## 📐 Phase 2A: 事前設計 (Pre-Implementation Design)

### 実行タイミング

```yaml
execution_order:
  phase_number: "Phase 2A"
  after: "Phase 1 (プロジェクト初期化)"
  before: "Phase 3 (実装)"
  timing: "実装開始前"
  duration: "1-2日"
```

### 目的

実装開始前に必要最小限の設計を行い、以下を明確化する:
- アーキテクチャの方向性
- 重要な技術決定
- チーム間の契約(API等)
- 制約条件(セキュリティ、パフォーマンス)

### 期間

- **目標**: 1-2日
- **最大**: 3日

### 成果物 (Deliverables)

#### 必須成果物

| # | 成果物名 | テンプレート | 内容 | ページ数目安 |
|---|---------|------------|------|------------|
| 1 | **ADR (Architecture Decision Record)** | `adr-template.md` | 重要な技術決定の記録 | 1-3ページ/決定 |
| 2 | **API契約書 (API Contract)** | `api-contract-template.md` | エンドポイント一覧と基本的な入出力定義 | 2-5ページ |
| 3 | **制約条件文書 (Constraints Document)** | `constraints-template.md` | セキュリティ、パフォーマンス、技術制約 | 1-2ページ |

#### 推奨成果物 (条件付き)

| # | 成果物名 | 作成条件 | 内容 |
|---|---------|---------|------|
| 4 | **技術提案書 (簡易版)** | 承認が必要な場合 | 技術アプローチの承認取得 |
| 5 | **アーキテクチャ概要図** | 新規システム | システム全体の構成図 |
| 6 | **データモデル概要** | DB変更がある場合 | 主要エンティティとリレーション |

### 完了基準

```yaml
completion_criteria:
  - [ ] 重要な技術決定がADRに記録されている
  - [ ] API契約書が作成され、関係チームと合意されている
  - [ ] 制約条件が明確に定義されている
  - [ ] 実装チームが Phase 3 を開始できる状態である
  - [ ] テックリードの承認を得ている

next_phase:
  - Phase 3 (実装) に進む
```

---

## 📝 Phase 5: 詳細設計 (Post-Implementation Design)

### 実行タイミング

```yaml
execution_order:
  phase_number: "Phase 5"
  after: "Phase 4 (レビュー・QA)"
  before: "Phase 6 (デプロイメント)"
  timing_options:
    option_1_parallel: "Phase 3-4 と並行実施 (推奨)"
    option_2_after: "Phase 4 完了後に実施"
  duration: "2-3日"

重要:
  "Phase 5 の実行順序は Phase 4 の後"
  "Phase 3 実装中から並行開始し、Phase 4 完了時に完成させる"
```

### 目的

実装完了後(または並行)に、以下を文書化する:
- 実装された内容の詳細設計
- アーキテクチャの確定版
- 技術的意思決定の記録
- 保守・運用のための情報

### 期間

```yaml
parallel_execution:
  phase_3_during: "Phase 3 期間の 20-30%"
  phase_4_during: "Phase 4 期間の 30-40%"
  total: "実装期間内に完了"

after_execution:
  standalone: "2-3日"
```

### 成果物 (Deliverables)

#### 必須成果物

| # | 成果物名 | テンプレート | 内容 | ページ数目安 |
|---|---------|------------|------|------------|
| 1 | **設計書 (Design Document)** | `design-document-template.md` | 詳細な技術設計の文書化 | 10-30ページ |
| 2 | **完全版API仕様書** | `api-specification-template.md` | 全エンドポイントの詳細仕様 | 10-50ページ |
| 3 | **アーキテクチャ図** | (Diagrams.net等) | システム構成の完全版 | 5-10図 |
| 4 | **データモデル文書** | `data-model-template.md` | ER図、スキーマ定義、マイグレーション | 5-15ページ |

#### 推奨成果物

| # | 成果物名 | 作成条件 | 内容 |
|---|---------|---------|------|
| 5 | **更新版ADR** | 実装中に決定事項がある場合 | 追加の技術決定記録 |
| 6 | **設計レビュー記録** | 正式レビューを実施した場合 | レビュー結果と対応記録 |
| 7 | **パフォーマンステスト結果** | 性能要件がクリティカル | ベンチマーク結果と分析 |
| 8 | **セキュリティ評価書** | セキュリティレビュー実施 | 脆弱性分析と対策 |

### 並行実施の具体的スケジュール（詳細版）

> **2025-11-19 追加**: Phase 5 並行実施の具体的なタイムラインとトリガーを追加

#### 並行実施とは

Phase 3（実装）とPhase 4（レビュー・QA）と「並行」してPhase 5（詳細設計）を
進めることで、以下のメリットを実現:

- ✅ リードタイム20%短縮
- ✅ 実装の記憶が鮮明なうちにドキュメント化
- ✅ 心理的負担の分散（一気に作成しない）

---

#### パターン1: 2週間実装プロジェクト

**適用**: 小規模マイクロサービス、機能追加

**タイムライン**:
```
┌──────────────────────────────────────────────────────────┐
│ Week 1: Phase 3 (実装) - 集中実装期間                      │
├──────────────────────────────────────────────────────────┤
│ Day 1-3 │ 実装 100% │ 設計 0%  │ プロジェクト構造、コア実装  │
│ Day 4-5 │ 実装 100% │ 設計 0%  │ コア機能完成               │
├──────────────────────────────────────────────────────────┤
│ Week 2: Phase 3 (実装継続) + Phase 5 開始                │
├──────────────────────────────────────────────────────────┤
│ Day 1-2 │ 実装  80% │ 設計 20% │ ★Phase 5開始              │
│         │           │          │ コア機能ドキュメント化開始   │
│ Day 3-5 │ 実装  70% │ 設計 30% │ API仕様書作成開始          │
│         │           │          │ 追加機能実装継続            │
├──────────────────────────────────────────────────────────┤
│ Week 3: Phase 4 (レビュー・QA) + Phase 5 継続            │
├──────────────────────────────────────────────────────────┤
│ Day 1-3 │ レビュー  │ 設計 30% │ テスト実施                 │
│         │    70%    │          │ データモデル文書化          │
│ Day 4-5 │ レビュー  │ 設計 40% │ アーキテクチャ図作成        │
│         │    60%    │          │                           │
├──────────────────────────────────────────────────────────┤
│ Week 3 終了後: Phase 5 完了                              │
├──────────────────────────────────────────────────────────┤
│ Day 1-2 │ 設計 100% │          │ 設計書最終版作成           │
│         │           │          │ 全ドキュメントレビュー       │
└──────────────────────────────────────────────────────────┘
```

**Phase 5 開始トリガー** (Week 2 Day 1):
- [ ] コア機能（CRUD操作）が実装完了
- [ ] 主要APIエンドポイントが動作確認済み
- [ ] ユニットテストが基本ケースをカバー
- [ ] データモデルが確定（大きな変更の可能性が低い）

---

#### パターン2: 4週間実装プロジェクト

**適用**: 中規模マイクロサービス、複数機能の統合

**タイムライン**:
```
┌──────────────────────────────────────────────────────────┐
│ Week 1-2: Phase 3 (実装) - 集中実装期間                    │
├──────────────────────────────────────────────────────────┤
│ Week 1  │ 実装 100% │ 設計 0%  │ コア機能実装               │
│ Week 2  │ 実装 100% │ 設計 0%  │ コア機能完成、安定化        │
├──────────────────────────────────────────────────────────┤
│ Week 3: Phase 3 (実装継続) + Phase 5 開始                │
├──────────────────────────────────────────────────────────┤
│         │ 実装  80% │ 設計 20% │ ★Phase 5開始              │
│         │           │          │ コア機能ドキュメント化       │
│         │           │          │ 追加機能実装                │
├──────────────────────────────────────────────────────────┤
│ Week 4: Phase 3 (実装完了) + Phase 5 継続                │
├──────────────────────────────────────────────────────────┤
│         │ 実装  70% │ 設計 30% │ 最終機能実装               │
│         │           │          │ API仕様書、データモデル作成  │
├──────────────────────────────────────────────────────────┤
│ Week 5: Phase 4 (レビュー・QA) + Phase 5 継続            │
├──────────────────────────────────────────────────────────┤
│         │ レビュー  │ 設計 40% │ テスト・レビュー実施        │
│         │    60%    │          │ アーキテクチャ図作成        │
├──────────────────────────────────────────────────────────┤
│ Week 5 終了後: Phase 5 完了                              │
└──────────────────────────────────────────────────────────┘
```

**Phase 5 開始トリガー** (Week 3):
- [ ] 実装期間の40-50%が経過
- [ ] コア機能がすべて実装完了
- [ ] 統合テストが基本シナリオをカバー
- [ ] アーキテクチャの大きな変更がない

---

#### Phase 5 開始判断フローチャート

```
              Phase 3 実装中
                    │
                    ▼
      ┌─────────────────────────┐
      │ コア機能は完成した?      │
      └─────────┬───────────────┘
                │
   ┌────────────┴────────────┐
   │                         │
 YES                        NO
   │                         │
   ▼                         ▼
┌─────────────────┐ ┌──────────────────┐
│ Phase 5 開始可 │ │ もう少し実装継続  │
│ トリガー確認へ  │ │ 1-2日後に再判断   │
└────────┬────────┘ └──────────────────┘
         │
         ▼
┌───────────────────────────────────┐
│ Phase 5 開始トリガー（確認）     │
├───────────────────────────────────┤
│ □ コア機能（CRUD操作）完了        │
│ □ 主要APIが動作確認済み           │
│ □ データモデルが確定              │
│ □ 実装期間の40-50%経過（4週以上） │
└────────┬──────────────────────────┘
         │
         ▼
  ┌──────┴──────┐
  │             │
全てYES      いずれかNO
  │             │
  ▼             ▼
Phase 5    もう少し待つ
開始!       (1週間後に再判断)
```

---

#### 作業切り替えのベストプラクティス

**タイミング1: 午前・午後で切り替え**（推奨）
```
午前: Phase 3/4 に集中（脳が活性化している時間）
午後: Phase 5 に切り替え（ドキュメント作成は午後が適）
```

**メリット**:
- コンテキストスイッチが1日1回
- 実装の記憶が新鮮なうちにドキュメント化

**タイミング2: 待ち時間活用**（最も効率的）
```
Phase 4 のテスト実行中、CI/CD実行中 → Phase 5 作業
Phase 4 のレビュー待ち → Phase 5 作業
```

---

#### よくある質問（FAQ）

**Q1: Week 1から Phase 5 を開始してはいけないのか?**

A1: 推奨しません。理由:
- Week 1 はプロジェクト構造構築、コア実装が最優先
- この段階ではアーキテクチャが変更される可能性が高い
- Phase 5 を開始しても、後で大きく書き直すことになる
- → Week 2 からの開始が最適

**Q2: Phase 3 が予定より早く終わった場合は?**

A2: Phase 5 に集中するチャンス:
- 残り時間を Phase 5 に100%投入
- 早期にドキュメントを完成させる
- Phase 4 (レビュー) の前にドキュメントレビューも完了可能

**Q3: Phase 3 が遅れている場合は?**

A3: Phase 5 開始を遅らせる:
- まずPhase 3 の完了を優先
- Phase 5 は Phase 4 期間中に集中して実施
- Phase 4 完了後に Phase 5 を単独で実施（2-3日）
- リードタイムは伸びるが、品質は確保

**Q4: AIエージェントに Phase 5 を自動化できるか?**

A4: 部分的に可能:
- ✅ 自動化可能: OpenAPI仕様生成、ER図生成、コード→ドキュメント
- ⚠️ 人間確認必要: アーキテクチャ図、設計意図の記述
- ❌ 自動化困難: 設計判断の理由、将来の拡張方針

理想: AIが80%生成 → 人間が20%レビュー・修正

---

### 完了基準

```yaml
completion_criteria:
  prerequisites:
    - [ ] Phase 3 (実装) が完了している
    - [ ] Phase 4 (レビュー・QA) が完了または進行中
    - [ ] コードが安定している
  
  deliverables:
    - [ ] 設計書が完成している
    - [ ] 完全版API仕様書が完成している
    - [ ] アーキテクチャ図が完成している
    - [ ] データモデル文書が完成している
  
  quality:
    - [ ] 実装内容と完全に一致している
    - [ ] 新メンバーのオンボーディングに使える
    - [ ] 運用チームが必要な情報を得られる
  
  approval:
    - [ ] テックリードの承認を得ている

next_phase:
  - Phase 6 (デプロイメント) に進む
```

---

## 🔀 実行順序の明確化

### パターンA: AI最適化型の詳細フロー

```
Week 0: Phase 2A (事前設計 1-2日)
  └─ 成果物: ADR, API契約, 制約条件
      ↓
Week 1-2: Phase 3 (実装)
  ├─ メイン作業: 実装 (80%)
  └─ 並行作業: Phase 5 開始 (20%)
      - 完成部分から順次文書化
      - アーキテクチャ図の作成開始
      ↓
Week 3: Phase 4 (レビュー・QA)
  ├─ メイン作業: レビュー・テスト (70%)
  └─ 並行作業: Phase 5 継続 (30%)
      - API仕様書の完成
      - データモデル文書の作成
      ↓
Week 3 終了時: Phase 5 完了
  └─ 全ての設計ドキュメントが完成
      ↓
Week 4: Phase 6 (デプロイメント)
```

### パターンB: 従来型の詳細フロー

```
Week 0: Phase 2A (事前設計 1-2日)
  └─ 成果物: ADR, API契約, 制約条件
      ↓
Week 1: Phase 5 (詳細設計 3-5日) ※実装前
  └─ 成果物: 設計書, API仕様書, 図, データモデル (初版)
      ↓
Week 2-3: Phase 3 (実装)
  └─ 設計書を参照しながら実装
      ↓
Week 4: Phase 4 (レビュー・QA)
  └─ 実装との整合性確認
      ↓
Week 4 終了時: Phase 5 更新 (1日)
  └─ 実装との差分を反映し、最終版を作成
      ↓
Week 5: Phase 6 (デプロイメント)
```

### パターンC: リバースエンジニアリング型の詳細フロー

```
Week 1-2: Phase 3 (実装)
  └─ Phase 2A スキップ、直接実装
      ↓
Week 3: Phase 4 (レビュー・QA)
  └─ テストとレビュー
      ↓
Week 3-4: Phase 5 (詳細設計 1-2日) ※実装後
  └─ 実装された内容を文書化 (簡易版)
      ↓
Week 4: Phase 6 (デプロイメント)
```

---

## 📊 成果物サマリー

### Phase 2A (事前設計) の成果物

**実行タイミング**: Phase 1 の後、Phase 3 の前

| 成果物 | 必須/推奨 | ページ数 | 作成時間 | 目的 |
|--------|----------|---------|---------|------|
| ADR | 必須 | 1-3 | 2-4時間 | 重要な技術決定の記録 |
| API契約書 | 必須 | 2-5 | 2-4時間 | チーム間の契約定義 |
| 制約条件文書 | 必須 | 1-2 | 1-2時間 | 非機能要件の明確化 |
| 技術提案書(簡易版) | 推奨 | 3-5 | 2-3時間 | 承認取得 |
| アーキテクチャ概要図 | 推奨 | 1-2図 | 1-2時間 | システム構成の可視化 |

**合計作成時間**: 8-15時間 (1-2日)

---

### Phase 5 (詳細設計) の成果物

**実行タイミング**: Phase 4 の後 (または Phase 3-4 と並行)

| 成果物 | 必須/推奨 | ページ数 | 作成時間 | 目的 |
|--------|----------|---------|---------|------|
| 設計書 | 必須 | 10-30 | 8-16時間 | 詳細技術設計の文書化 |
| 完全版API仕様書 | 必須 | 10-50 | 4-8時間 | 全エンドポイント仕様 |
| アーキテクチャ図 | 必須 | 5-10図 | 4-6時間 | システム構成の完全版 |
| データモデル文書 | 必須 | 5-15 | 4-8時間 | ER図、スキーマ定義 |
| 更新版ADR | 推奨 | 1-3 | 1-2時間 | 追加の技術決定 |

**合計作成時間**: 21-40時間 (3-5日)
**AI活用時**: 10-20時間 (1.5-3日)

---

## 🎯 プロジェクトタイプ別の推奨パターンと実行順序

### 新規マイクロサービス開発

**推奨パターン**: AI最適化型 (パターンA)

**実行順序**:
1. Phase 2A (1-2日) → ADR, API契約, 制約条件
2. Phase 3 (1-4週間) → 実装
3. Phase 4 (3-5日) → レビュー・QA
4. Phase 5 (並行 or 直後) → 設計書, API仕様書, 図, データモデル
5. Phase 6 → デプロイ

---

### 複数チーム連携プロジェクト

**推奨パターン**: 従来型 (パターンB)

**実行順序**:
1. Phase 2A (1-2日) → ADR, API契約, 制約条件
2. Phase 5 (3-5日) → 詳細設計 (実装前に完成)
3. Phase 3 (1-4週間) → 実装
4. Phase 4 (3-5日) → レビュー・QA
5. Phase 5 更新 (1日) → 最終版に更新
6. Phase 6 → デプロイ

---

### 小規模機能追加

**推奨パターン**: リバースエンジニアリング型 (パターンC)

**実行順序**:
1. Phase 3 (1-2週間) → 実装 (Phase 2A スキップ)
2. Phase 4 (2-3日) → レビュー・QA
3. Phase 5 (1日) → 簡易版設計書 (必要に応じて)
4. Phase 6 → デプロイ


---

# Phase 5並行実施: パターンC（マイルストーン並行型） - 詳細ガイド

> **推奨パターン**: Phase 5を効率的に実施する最も実用的なアプローチ

---

## 📌 パターンCの概要

### 基本コンセプト

```yaml
原則:
  - 機能単位（Feature/Epic）の完成をトリガーに、その機能のドキュメント化を実施
  - 実装の記憶が最も鮮明なタイミングで文書化
  - 実装とドキュメントの切り替え回数を最小化（週1-2回）
  
メリット:
  - ✅ 集中力を維持したまま効率的な作業
  - ✅ 高品質なドキュメント（実装直後の記録）
  - ✅ 認知負荷の軽減（1日に複数タスクを切り替えない）
  - ✅ 自然なタイミング（機能完成時）
```

---

## 🔄 実施フロー（3週間プロジェクト例）

### 全体スケジュール

```
Week 1: 実装集中期間
├─ Day 1-5: Milestone 1 (コア機能) 実装
└─ Day 5 午後: Phase 5 ブロック #1 (4時間)
     └─ コア機能のドキュメント化
     └─ 進捗: 25%

Week 2: 実装 + 部分的ドキュメント化
├─ Day 1-5: Milestone 2 (拡張機能) 実装
└─ Day 5 午後: Phase 5 ブロック #2 (4時間)
     └─ 拡張機能のドキュメント化
     └─ 進捗: 50%

Week 3: Phase 4 (レビュー・QA) + Phase 5 完成
├─ Day 1-3: Phase 4 実施
│    └─ Phase 5 ブロック #3 と並行 (6時間)
│         └─ 進捗: 80%
└─ Day 4-5: Phase 5 最終化
     └─ Phase 5 ブロック #4 (4時間)
     └─ 進捗: 100%
```

---

## 📋 マイルストーン定義

### マイルストーン設定の原則

1. **機能単位で分割**: 1マイルストーン = 1つの独立した機能
2. **期間**: 3-7日（1週間以内を推奨）
3. **完了基準**: 実装完了 + ユニットテスト + コードレビュー
4. **Phase 5トリガー**: 完了基準を満たした直後

---

### 標準的なマイルストーン例

#### Milestone 1: コア機能完成

**期間**: Week 1 (Day 1-5)

**実装内容**:
- ユーザー登録・ログイン API
- JWT認証機構
- ユーザーデータモデル
- ユニットテスト（カバレッジ80%+）

**完了基準**:
```yaml
implementation:
  - [✓] 全APIエンドポイントが動作
  - [✓] ユニットテスト完了（80%+ カバレッジ）
  - [✓] 統合テスト完了（主要シナリオ）

code_quality:
  - [✓] コードレビュー完了
  - [✓] Linter/Formatter クリア
  - [✓] セキュリティスキャンクリア
```

**Phase 5トリガー**: Week 1 Day 5 午後（または翌週月曜午前）

**Phase 5作業ブロック #1** (4-6時間):
- [ ] コア機能のAPI仕様書作成（OpenAPI形式）
- [ ] 認証フローのシーケンス図作成
- [ ] ユーザーデータモデルのER図作成
- [ ] ADR更新（JWT選定理由、リフレッシュトークン方式）

**進捗**: Phase 5全体の **25%完了**

---

#### Milestone 2: セキュリティ強化完成

**期間**: Week 2 (Day 1-5)

**実装内容**:
- リフレッシュトークン機構
- レート制限ミドルウェア
- CORS設定
- セキュリティヘッダー

**完了基準**: 同上

**Phase 5トリガー**: Week 2 Day 5 午後

**Phase 5作業ブロック #2** (4-6時間):
- [ ] セキュリティアーキテクチャ文書作成
- [ ] JWT/リフレッシュトークンの詳細設計
- [ ] 脅威モデル文書化
- [ ] レート制限設計の記録

**進捗**: Phase 5全体の **50%完了**

---

#### Milestone 3: 監視・ロギング完成

**期間**: Week 3 Day 1-3 (3日間)

**実装内容**:
- 構造化ログ（JSON形式）
- メトリクス収集（Prometheus形式）
- ヘルスチェックエンドポイント
- 分散トレーシング準備

**完了基準**: 同上

**Phase 5トリガー**: Week 3 Day 3 午後（Phase 4と並行）

**Phase 5作業ブロック #3** (6-8時間):
- [ ] 監視・ロギング設計の文書化
- [ ] 全体アーキテクチャ図の完成
- [ ] デプロイメント図作成
- [ ] パフォーマンス設計文書

**進捗**: Phase 5全体の **80%完了**

---

#### Phase 5 最終化

**期間**: Week 3 Day 4-5（Phase 4完了後）

**Phase 5作業ブロック #4** (4-6時間):
- [ ] 設計書の全体統合・整合性確認
- [ ] as-built記録（実装との差異）
- [ ] 全ドキュメントのレビュー・校正
- [ ] README、索引の整備

**進捗**: Phase 5全体の **100%完了**

---

## ⏱️ 時間配分の詳細

### 3週間プロジェクトの場合

| 週 | Phase 3実装時間 | Phase 5ドキュメント時間 | Phase 5割合 |
|----|---------------|---------------------|-----------|
| Week 1 | 36時間 (5日 × 7.2h) | 4時間 (金曜午後) | 10% |
| Week 2 | 36時間 | 4時間 (金曜午後) | 10% |
| Week 3 | Phase 4: 24時間 (3日) | 6時間 (Phase 4並行) | 20% |
| Week 3 | - | 4時間 (最終化) | - |
| **合計** | **96時間** | **18時間** | **15.8%** |

**実績**: Phase 3-4期間の **15.8%** を Phase 5 に配分

**従来の課題だった"20-30%"よりも現実的な数値**

---

## 🎯 プロジェクト規模別マイルストーン設定

### 小規模プロジェクト（1-2週間）

```yaml
milestone_count: 2-3
phase_5_blocks: 2-3
block_duration: 2-4時間

example:
  milestone_1:
    name: "コア機能"
    duration: "5日"
    phase_5_block: "2時間"
  
  milestone_2:
    name: "追加機能"
    duration: "3日"
    phase_5_block: "2時間"
  
  finalization:
    name: "最終化"
    duration: "2日"
    phase_5_block: "2時間"
```

---

### 中規模プロジェクト（3-6週間）

```yaml
milestone_count: 3-5
phase_5_blocks: 3-5
block_duration: 4-6時間

example:
  milestone_1:
    name: "コア機能"
    duration: "1週間"
    phase_5_block: "4時間"
  
  milestone_2:
    name: "拡張機能"
    duration: "1週間"
    phase_5_block: "4時間"
  
  milestone_3:
    name: "統合・監視"
    duration: "5日"
    phase_5_block: "6時間"
  
  finalization:
    name: "最終化"
    duration: "2日"
    phase_5_block: "4時間"
```

---

### 大規模プロジェクト（2-3ヶ月）

```yaml
milestone_count: 5-8
phase_5_blocks: 5-8
block_duration: 6-8時間

example:
  - マイクロサービス基盤構築（1週間）→ Phase 5ブロック: 6時間
  - 認証・認可サービス（2週間）→ Phase 5ブロック: 8時間
  - ビジネスロジック実装（2週間）→ Phase 5ブロック: 8時間
  - 統合テスト（1週間）→ Phase 5ブロック: 6時間
  - パフォーマンス最適化（1週間）→ Phase 5ブロック: 6時間
  - 最終化（3日）→ Phase 5ブロック: 8時間
```

---

## ✅ Phase 5開始トリガー判断フローチャート

```
              マイルストーン実装期間終了
                         │
                         ▼
        ┌────────────────────────────┐
        │ 完了基準をすべて満たした?   │
        └────────┬──────────┬────────┘
                 │          │
               YES         NO
                 │          │
                 │          ▼
                 │  ┌──────────────────┐
                 │  │ 不足項目を完了   │
                 │  │ 1-2日追加で作業  │
                 │  └──────┬───────────┘
                 │         │
                 └─────────┴──────┐
                                  │
                                  ▼
        ┌────────────────────────────────────┐
        │ Phase 5作業ブロック開始タイミング  │
        ├────────────────────────────────────┤
        │ Option A: 金曜午後 (推奨)          │
        │   └─ 週末前にドキュメント化完了     │
        │                                    │
        │ Option B: 翌週月曜午前             │
        │   └─ 週明けリフレッシュした状態で  │
        │                                    │
        │ Option C: Phase 4実施中            │
        │   └─ テスト実行・レビュー待ち時間  │
        └────────────────────────────────────┘
```

---

## 📝 作業ブロック実施のベストプラクティス

### 推奨タイミング

1. **金曜午後** ⭐⭐⭐⭐⭐
   - メリット: 週末前に区切りがつく、実装の記憶が鮮明
   - 時間帯: 13:00 - 17:00 (4時間)

2. **Phase 4待ち時間活用** ⭐⭐⭐⭐
   - テスト実行中、CI/CD実行中
   - コードレビュー待ち時間

3. **翌週月曜午前** ⭐⭐⭐
   - メリット: 週末で頭がリフレッシュ
   - デメリット: 実装の記憶が若干薄れる可能性

---

### 作業環境の準備

```yaml
before_starting:
  - [ ] 実装コードをすべてコミット
  - [ ] テストがすべてパス
  - [ ] 邪魔が入らない環境確保（会議ブロック）
  - [ ] 必要なツールを起動（図作成ツール、エディタ）

during_work:
  - 実装コードを参照しながら作業
  - コミット履歴を確認して設計判断の理由を記録
  - 完璧を求めすぎない（80%完成度で次へ）

after_completion:
  - ドキュメントをコミット
  - 次のマイルストーンの実装に戻る
```

---

## ❓ よくある質問（FAQ）

### Q1: マイルストーンが予定より早く終わった場合は?

**A**: 次の2つの選択肢があります：

1. **即座にPhase 5ブロックを開始**（推奨）
   - 実装の記憶が最も鮮明
   - 早期完了でバッファ時間確保

2. **次のマイルストーン実装を先行**
   - Phase 5ブロックを予定通り金曜午後に実施
   - 複数マイルストーンをまとめてドキュメント化

---

### Q2: Phase 5ブロック中に実装の誤りを発見した場合は?

**A**: ドキュメント作成を一時中断し、実装修正を優先：

1. 発見した問題をIssue登録
2. 緊急度が高い場合は即座に実装修正
3. 修正後、ドキュメント化を再開

**メリット**: ドキュメント化が品質レビューの役割も果たす

---

### Q3: Phase 5ブロックが予定時間内に終わらない場合は?

**A**: 80%ルールを適用：

- 80%完成度でいったん終了
- 残りは次のPhase 5ブロック時に完成
- 完璧を求めすぎない（最終化ブロックで統合）

---

### Q4: 全マイルストーンで同じ成果物を作るのか?

**A**: いいえ。マイルストーンごとに異なります：

- **Milestone 1**: コア機能のAPI仕様、データモデル
- **Milestone 2**: セキュリティ設計、ADR
- **Milestone 3**: 監視設計、アーキテクチャ図
- **最終化**: 全体統合、as-built記録

---

## 📊 成果物の段階的完成イメージ

### API仕様書の例

| マイルストーン | 完成度 | 内容 |
|-------------|--------|------|
| Milestone 1 | 30% | コア機能のエンドポイント（登録・ログイン） |
| Milestone 2 | 60% | 認証・トークン更新エンドポイント |
| Milestone 3 | 90% | ヘルスチェック、メトリクスエンドポイント |
| 最終化 | 100% | 全体レビュー、エラーレスポンス統一、サンプル充実 |

---

### アーキテクチャ図の例

| マイルストーン | 完成度 | 内容 |
|-------------|--------|------|
| Milestone 1 | 20% | コア機能のシーケンス図 |
| Milestone 2 | 50% | セキュリティレイヤー追加 |
| Milestone 3 | 80% | 監視・ロギング追加、デプロイメント図 |
| 最終化 | 100% | 全体構成図、コンポーネント図、統合 |

---

## 🎯 成功のポイント

1. **マイルストーンは明確に**: 完了基準を事前定義
2. **金曜午後を活用**: 週末前の自然な区切り
3. **80%ルール**: 完璧を求めすぎない
4. **テンプレート活用**: 効率的なドキュメント作成
5. **AI支援**: OpenAPI生成、図の自動生成を活用

---

**このパターンにより、Phase 5並行実施が実務で実行可能になります。**

---

## 📚 関連ドキュメント

### Phase 2A 詳細ガイド
- `phase-2A-pre-implementation-design-guide.md` (旧名: phase-2a)
- 実行タイミング: Phase 1 の後、Phase 3 の前

### Phase 5 詳細ガイド
- `phase-2B-post-implementation-design-guide.md` (旧名: phase-2b)
- 実行タイミング: Phase 4 の後 (または Phase 3-4 と並行)

### 成果物マトリクス
- `revised-design-deliverables-matrix.md`

---

## ⚠️ 重要な注意事項

### Phase番号と実行順序の違いに注意

```yaml
注意:
  phase_2_2:
    phase_number: "Phase 5"
    description: "番号は2だが、実際は Phase 4 の後に実行される"
    reason: "設計フェーズの一部だが、実装後に実施するため"
    
実行順序の覚え方:
  "Phase 2A → Phase 3 → Phase 4 → Phase 5 → Phase 6"
  "事前設計 → 実装 → レビュー → 詳細設計 → デプロイ"
```

### チェックリストでの確認

各フェーズ開始前に、前提条件を確認:

```yaml
phase_2_1_start:
  - [ ] Phase 1 が完了している
  - [ ] 要件定義が明確である

phase_3_start:
  - [ ] Phase 2A が完了している
  - [ ] ADR, API契約, 制約条件が準備できている

phase_2_2_start:
  - [ ] Phase 3 が完了している (並行の場合は主要機能が完成)
  - [ ] Phase 4 が進行中または完了している
  - [ ] コードが安定している
```

---

## 🚀 次のステップ

### 組織標準への統合

1. **AI-MASTER-WORKFLOW-GUIDE.md** の改訂
   - Phase 2A / Phase 5 の説明追加
   - 実行順序の明確化

2. **phase-guides/** の更新
   - phase-2a → phase-2A にリネーム
   - phase-2b → phase-2B にリネーム
   - 各ガイドに実行順序を明記

3. **テンプレート作成**
   - api-contract-template.md (新規)
   - constraints-template.md (新規)

---

**この改訂により、実行順序が明確な開発プロセスを実現します。**
