# テスト戦略
## Testing Strategy

**最終更新日**: 2025-10-27  
**バージョン**: 1.0.0  
**対象**: QAリード・テクニカルリード・開発者・自律型AI Devin  
**適用範囲**: 全プロジェクト共通テスト戦略

---

## 📖 概要

このドキュメントは、組織全体のテスト戦略を定義し、効果的で効率的なテストアプローチを確立します。テストレベル、テストタイプ、テスト計画、リスクベーステスト、テスト環境戦略をカバーし、高品質なソフトウェアデリバリーを支援します。

### 🎯 目的

- **包括的なテスト**: すべてのテストレベルをカバーする戦略的アプローチ
- **効率的なテスト**: テストピラミッドに基づく最適なテスト配分
- **リスク管理**: リスクベースのテスト優先順位付け
- **自動化推進**: CI/CDパイプラインへのテスト統合
- **品質保証**: 継続的な品質向上と早期バグ検出

---

## 📂 目次

1. [テストレベルの定義](#1-テストレベルの定義)
2. [テストピラミッド戦略](#2-テストピラミッド戦略)
3. [テストタイプの分類](#3-テストタイプの分類)
4. [リスクベーステスト](#4-リスクベーステスト)
5. [テスト計画策定](#5-テスト計画策定)
6. [テスト環境戦略](#6-テスト環境戦略)
7. [テストデータ戦略](#7-テストデータ戦略)
8. [CI/CDとの統合](#8-cicdとの統合)
9. [テストメトリクスとKPI](#9-テストメトリクスとkpi)
10. [テストプロセス改善](#10-テストプロセス改善)
11. [Devin AIガイドライン](#11-devin-aiガイドライン)

---

## 1. テストレベルの定義

### 1.1 ユニットテスト（Unit Testing）

#### **定義**
個別の関数、メソッド、クラスを独立してテストし、最小単位のコードが正しく動作することを検証

#### **特徴**
```yaml
スコープ:       単一の関数/メソッド/クラス
依存関係:       モック/スタブで置換
実行速度:       非常に高速（ミリ秒単位）
実行頻度:       毎コミット
自動化レベル:   100%
担当:          開発者
```

#### **テスト対象**
- ビジネスロジック
- ユーティリティ関数
- データ変換ロジック
- バリデーションルール
- 計算処理

#### **目標カバレッジ**
```yaml
全体:           80%以上
ビジネスロジック: 90%以上
ユーティリティ:   85%以上
```

#### **ベストプラクティス**
- AAAパターン（Arrange-Act-Assert）の使用
- テストの独立性確保（他のテストに依存しない）
- 明確なテスト名（何をテストするか明確に）
- 1テスト1アサーション（理想）
- 高速実行（全体で5分以内）

---

### 1.2 統合テスト（Integration Testing）

#### **定義**
複数のコンポーネント、モジュール、サービス間の相互作用とインターフェースをテスト

#### **特徴**
```yaml
スコープ:       複数コンポーネントの統合
依存関係:       実際の依存関係を使用
実行速度:       中速（秒〜分単位）
実行頻度:       毎プルリクエスト
自動化レベル:   90%以上
担当:          開発者・QAエンジニア
```

#### **テスト対象**
- APIエンドポイント
- データベース操作
- 外部サービス連携
- メッセージキュー
- ファイルシステム操作
- キャッシュ層

#### **統合パターン**

**1. ビッグバン統合**:
```
すべてのコンポーネントを一度に統合
├─ 利点: シンプル、実装が早い
└─ 欠点: 問題の特定が困難
```

**2. トップダウン統合**:
```
上位モジュールから順次統合
├─ 利点: 早期の全体像把握
└─ 欠点: 下位モジュールのスタブが必要
```

**3. ボトムアップ統合**:
```
下位モジュールから順次統合
├─ 利点: 早期の基盤検証
└─ 欠点: 上位モジュールのドライバーが必要
```

**4. サンドイッチ統合（推奨）**:
```
トップダウンとボトムアップの組み合わせ
├─ 利点: バランスの取れたアプローチ
└─ 欠点: やや複雑
```

#### **目標カバレッジ**
```yaml
主要統合ポイント:  100%
APIエンドポイント:  100%
データベース操作:   90%以上
```

---

### 1.3 エンドツーエンドテスト（E2E Testing）

#### **定義**
ユーザーの視点から、システム全体のワークフローをテスト

#### **特徴**
```yaml
スコープ:       システム全体
依存関係:       すべて実際の依存関係
実行速度:       低速（分〜時間単位）
実行頻度:       毎デプロイ
自動化レベル:   80%以上
担当:          QAエンジニア
```

#### **テスト対象**
- クリティカルなユーザーフロー
- ビジネストランザクション
- エンドツーエンドのシナリオ
- UIとバックエンドの統合

#### **E2Eテストの範囲**
```
少なすぎる → リスク高
    ↓
適切な範囲 → クリティカルパスに集中
    ↓
多すぎる → メンテナンスコスト増、実行時間長
```

**推奨アプローチ**:
- クリティカルビジネスフロー: 100%カバー
- 主要機能: 80%カバー
- 補助機能: 統合テストでカバー

---

### 1.4 その他のテストレベル

#### **コンポーネントテスト**
```yaml
定義:    UI コンポーネント単体のテスト
スコープ: 単一のUIコンポーネント
ツール:  Storybook, React Testing Library
```

#### **契約テスト（Contract Testing）**
```yaml
定義:    サービス間のAPIコントラクトをテスト
スコープ: APIインターフェース
ツール:  Pact, Spring Cloud Contract
用途:    マイクロサービスアーキテクチャ
```

#### **スモークテスト**
```yaml
定義:    基本機能の簡易テスト
スコープ: 主要機能のみ
実行時間: 5-10分
用途:    デプロイ後の即座の検証
```

---

## 2. テストピラミッド戦略

### 2.1 理想的なテストピラミッド

```
           △
          /E2E\          10% - UI/エンドツーエンド
         /─────\         • 最も遅い
        /統合Test\       • 最も壊れやすい
       /─────────\      30% - API/統合
      /ユニットTest\     • 中速
     /─────────────\    • 安定
    /───────────────\  60% - ユニット/単体
                        • 最も速い
                        • 最も安定
```

### 2.2 テスト配分の根拠

#### **ユニットテスト（60%）**

**理由**:
- 高速実行（数秒〜数分）
- 問題の特定が容易
- メンテナンスコストが低い
- 開発中の即座のフィードバック

**焦点**:
- ビジネスロジック
- アルゴリズム
- データ変換
- バリデーション

---

#### **統合テスト（30%）**

**理由**:
- 実際の統合ポイントを検証
- データベース、APIの実際の動作確認
- ユニットテストでカバーできない領域

**焦点**:
- APIエンドポイント
- データベース操作
- 外部サービス連携
- メッセージング

---

#### **E2Eテスト（10%）**

**理由**:
- 実行が遅い
- メンテナンスコストが高い
- フレイキーテストになりやすい

**焦点**:
- クリティカルなユーザーフロー
- 購入フロー
- 登録・ログインフロー
- 主要なビジネストランザクション

---

### 2.3 アンチパターン: テストアイスクリームコーン

```
      ━━━━━━━━━
     ┃  E2E  ┃     ← 多すぎるE2Eテスト
     ┃       ┃
     ┃       ┃
     ┗━━━━━━━┛
        ┃統合┃       ← 少ない統合テスト
        ┗━━━┛
         ┃U┃         ← 非常に少ないユニットテスト
         ┗━┛
```

**問題点**:
- テスト実行時間が長い（数時間）
- CI/CDボトルネック
- フレイキーテスト多発
- デバッグが困難
- メンテナンスコスト大

**回避方法**:
- ピラミッド型を維持
- E2Eテストは厳選
- ユニットテストを充実

---

### 2.4 プロジェクトタイプ別の調整

#### **マイクロサービスアーキテクチャ**
```
E2E:        5%   （サービス横断フローのみ）
契約:       15%  （サービス間契約）
統合:       30%  （サービス内統合）
ユニット:    50%  （ビジネスロジック）
```

#### **モノリシックアプリケーション**
```
E2E:        10%  （主要フロー）
統合:       30%  （モジュール間）
ユニット:    60%  （ビジネスロジック）
```

#### **ライブラリ/SDK開発**
```
E2E:        0%   （該当なし）
統合:       20%  （外部依存との統合）
ユニット:    80%  （APIと内部ロジック）
```

---

## 3. テストタイプの分類

### 3.1 機能テスト（Functional Testing）

#### **正常系テスト（Happy Path Testing）**
```yaml
目的:    期待される正常な動作の検証
カバー:  主要な成功シナリオ
優先度:  最高
```

**例**:
```python
def test_user_registration_success():
    """正常なユーザー登録フロー"""
    user_data = {
        "email": "user@example.com",
        "password": "SecurePass123!",
        "name": "Test User"
    }
    response = client.post("/api/register", json=user_data)
    assert response.status_code == 201
    assert "user_id" in response.json()
```

---

#### **異常系テスト（Error Path Testing）**
```yaml
目的:    エラーハンドリングの検証
カバー:  すべてのエラーケース
優先度:  高
```

**例**:
```python
def test_user_registration_duplicate_email():
    """重複メールアドレスでの登録失敗"""
    # 既存ユーザーを作成
    create_user("user@example.com")
    
    # 同じメールで登録試行
    response = client.post("/api/register", json={
        "email": "user@example.com",
        "password": "Pass123!",
        "name": "Another User"
    })
    assert response.status_code == 400
    assert "already exists" in response.json()["error"]
```

---

#### **境界値テスト（Boundary Testing）**
```yaml
目的:    境界条件での動作検証
カバー:  最小値、最大値、境界付近
優先度:  高
```

**例**:
```python
def test_password_length_boundaries():
    """パスワード長の境界値テスト"""
    # 最小値未満（7文字）
    assert not validate_password("Pass12!")
    
    # 最小値（8文字）
    assert validate_password("Pass123!")
    
    # 最大値（64文字）
    assert validate_password("P" * 63 + "!")
    
    # 最大値超過（65文字）
    assert not validate_password("P" * 64 + "!")
```

---

#### **エッジケーステスト（Edge Case Testing）**
```yaml
目的:    特殊な状況での動作検証
カバー:  空値、null、極端な値
優先度:  中
```

**例**:
```python
def test_search_edge_cases():
    """検索機能のエッジケース"""
    # 空文字列
    assert search_users("") == []
    
    # 特殊文字
    assert search_users("@#$%") == []
    
    # 非常に長い文字列
    assert search_users("a" * 1000) == []
    
    # Unicodeサロゲートペア
    assert search_users("👨‍👩‍👧‍👦") == []
```

---

### 3.2 非機能テスト（Non-Functional Testing）

#### **パフォーマンステスト**
```yaml
種類:
  - 負荷テスト:     通常負荷での動作確認
  - ストレステスト:  限界負荷の特定
  - スパイクテスト:  急激な負荷変動への対応
  - 耐久テスト:     長時間運用での安定性
  - スケーラビリティテスト: 拡張性の検証
```

#### **セキュリティテスト**
```yaml
種類:
  - SAST:           静的解析
  - DAST:           動的解析
  - ペネトレーション: 侵入テスト
  - 脆弱性スキャン:   既知の脆弱性検出
```

#### **ユーザビリティテスト**
```yaml
目的:    ユーザー体験の検証
手法:    ユーザビリティテスト、A/Bテスト
対象:    UI/UX
```

#### **互換性テスト**
```yaml
目的:    異なる環境での動作検証
対象:    ブラウザ、OS、デバイス、バージョン
```

#### **アクセシビリティテスト**
```yaml
目的:    WCAG準拠の検証
ツール:  axe-core, Lighthouse
対象:    Webアプリケーション
```

---

### 3.3 回帰テスト（Regression Testing）

#### **定義**
既存機能が新しい変更によって破壊されていないことを検証

#### **戦略**
```yaml
フル回帰:
  実施:    リリース前
  内容:    すべてのテストを実行
  期間:    数時間
  
部分回帰:
  実施:    毎プルリクエスト
  内容:    影響範囲のテストのみ
  期間:    数十分
  
スモーク回帰:
  実施:    毎デプロイ
  内容:    クリティカルパスのみ
  期間:    数分
```

#### **自動化**
```
回帰テストは100%自動化が目標
↓
CI/CDパイプラインに統合
↓
毎コミット・毎PR・毎デプロイで実行
```

---

## 4. リスクベーステスト

### 4.1 リスク評価マトリクス

```
影響度 ↑
高  │  M   H   H
    │
中  │  L   M   H
    │
低  │  L   L   M
    └───────────→ 発生確率
      低  中  高

L: Low Risk    (低リスク)
M: Medium Risk (中リスク)
H: High Risk   (高リスク)
```

### 4.2 リスク分類

#### **高リスク（High Risk）**
```yaml
特徴:
  - クリティカルなビジネス機能
  - 金銭取引、個人情報
  - 高頻度の使用
  - 複雑なロジック
  - 変更が頻繁

テスト戦略:
  - カバレッジ: 100%
  - テストレベル: すべて
  - 優先度: 最高
  - 自動化: 必須
```

**例**:
- 決済処理
- ユーザー認証
- データ暗号化
- 個人情報管理

---

#### **中リスク（Medium Risk）**
```yaml
特徴:
  - 重要だが代替手段あり
  - 中程度の複雑さ
  - 中頻度の使用

テスト戦略:
  - カバレッジ: 80%以上
  - テストレベル: ユニット+統合
  - 優先度: 高
  - 自動化: 推奨
```

**例**:
- 検索機能
- レポート生成
- 通知システム

---

#### **低リスク（Low Risk）**
```yaml
特徴:
  - 補助的な機能
  - シンプルなロジック
  - 低頻度の使用
  - 影響範囲が限定的

テスト戦略:
  - カバレッジ: 60%以上
  - テストレベル: ユニット中心
  - 優先度: 中
  - 自動化: オプション
```

**例**:
- UIの装飾
- ヘルプ機能
- ログ記録

---

### 4.3 リスクベースのテスト優先順位

```
1. 高リスク・高頻度
   → 最優先でテスト作成・実行

2. 高リスク・低頻度
   → 詳細なテスト、手動テストも検討

3. 低リスク・高頻度
   → 基本的なテストのみ

4. 低リスク・低頻度
   → 最小限のテスト、または省略
```

---

## 5. テスト計画策定

### 5.1 テスト計画のテンプレート

```markdown
# テスト計画書

## 1. プロジェクト情報
- プロジェクト名:
- バージョン:
- 計画作成日:
- 作成者:

## 2. テストスコープ
### 対象機能
- 機能A: 新規ユーザー登録
- 機能B: 商品検索
- 機能C: 購入フロー

### 対象外
- 管理者機能（別計画）
- レガシー機能（変更なし）

## 3. テスト戦略
### テストレベル
- ユニットテスト: 開発者
- 統合テスト: 開発者・QA
- E2Eテスト: QA

### テストタイプ
- 機能テスト
- パフォーマンステスト
- セキュリティテスト

## 4. テスト環境
- 開発環境: local
- テスト環境: staging
- 本番環境: production

## 5. リスク評価
| 機能 | リスクレベル | 対策 |
|------|------------|------|
| 決済 | 高 | 100%カバレッジ |
| 検索 | 中 | 80%カバレッジ |

## 6. スケジュール
- テスト設計: Week 1-2
- テスト実装: Week 3-4
- テスト実行: Week 5
- バグ修正: Week 6

## 7. 成功基準
- カバレッジ: 80%以上
- Critical/High bugs: 0件
- テスト成功率: 98%以上

## 8. 成果物
- テスト設計書
- テストケース
- テスト実行結果レポート
- バグレポート
```

---

### 5.2 プロジェクトフェーズ別のテスト計画

#### **要件定義フェーズ**
```yaml
活動:
  - テスト可能性の評価
  - 受け入れ基準の定義
  - リスク分析
  
成果物:
  - テスト戦略書
  - リスク評価マトリクス
```

#### **設計フェーズ**
```yaml
活動:
  - テストケース設計
  - テストデータ設計
  - テスト環境計画
  
成果物:
  - テスト設計書
  - テストケース仕様書
```

#### **開発フェーズ**
```yaml
活動:
  - ユニットテスト実装
  - テスト自動化
  - 継続的テスト実行
  
成果物:
  - テストコード
  - テスト実行結果
```

#### **テストフェーズ**
```yaml
活動:
  - 統合テスト実行
  - E2Eテスト実行
  - バグ修正と再テスト
  
成果物:
  - テスト実行レポート
  - バグレポート
  - 品質メトリクスレポート
```

---

## 6. テスト環境戦略

### 6.1 環境の種類

```
開発環境 (Development)
    ↓
テスト環境 (Testing/QA)
    ↓
ステージング環境 (Staging)
    ↓
本番環境 (Production)
```

---

#### **開発環境（Development）**
```yaml
目的:    開発者の日常作業
特徴:    頻繁な変更、不安定
データ:  モックデータ、小規模
テスト:  ユニットテスト、統合テスト
```

#### **テスト環境（Testing/QA）**
```yaml
目的:    QAチームのテスト実行
特徴:    安定、定期的なデプロイ
データ:  テストデータ、中規模
テスト:  統合テスト、E2Eテスト
```

#### **ステージング環境（Staging）**
```yaml
目的:    本番前の最終検証
特徴:    本番環境と同一構成
データ:  本番データのコピー（匿名化）
テスト:  スモークテスト、パフォーマンステスト
```

#### **本番環境（Production）**
```yaml
目的:    実際のユーザー向けサービス
特徴:    最高の安定性とセキュリティ
データ:  実際のユーザーデータ
テスト:  モニタリング、スモークテスト
```

---

### 6.2 環境管理のベストプラクティス

```yaml
Infrastructure as Code:
  - Terraform, AWS CloudFormation
  - 環境を再現可能に
  
コンテナ化:
  - Docker, Kubernetes
  - 一貫した環境
  
環境分離:
  - ネットワーク分離
  - データベース分離
  - 認証情報の分離
  
データ管理:
  - 本番データは匿名化
  - GDPRコンプライアンス
  - 定期的なリフレッシュ
```

---

## 7. テストデータ戦略

### 7.1 テストデータの種類

#### **静的テストデータ**
```yaml
特徴:    固定データ、変更されない
用途:    基本的なテストケース
管理:    バージョン管理に含める
例:      基準日付、固定ユーザー
```

#### **動的テストデータ**
```yaml
特徴:    実行時に生成
用途:    ユニークな値が必要なテスト
管理:    ファクトリーパターン
例:      新規ユーザー、トランザクション
```

#### **合成テストデータ**
```yaml
特徴:    ツールで自動生成
用途:    大量データが必要なテスト
ツール:  Faker, faker.js
例:      負荷テスト用データ
```

---

### 7.2 テストデータ生成

**Python例（Faker使用）**:
```python
from faker import Faker
import factory

fake = Faker('ja_JP')

class UserFactory(factory.Factory):
    class Meta:
        model = User
    
    email = factory.LazyAttribute(lambda _: fake.email())
    name = factory.LazyAttribute(lambda _: fake.name())
    phone = factory.LazyAttribute(lambda _: fake.phone_number())
    address = factory.LazyAttribute(lambda _: fake.address())

# 使用例
def test_user_creation():
    user = UserFactory.create()
    assert user.email
    assert user.name
```

---

### 7.3 テストデータ管理

```yaml
原則:
  1. 本番データの直接使用禁止
  2. 個人情報の匿名化必須
  3. テスト後のクリーンアップ
  4. データのバージョン管理
  
クリーンアップ戦略:
  - トランザクションロールバック
  - テスト後の削除処理
  - 専用テストデータベース使用
```

---

## 8. CI/CDとの統合

### 8.1 CI/CDパイプラインのテストステージ

```yaml
stages:
  - build           # ビルド
  - unit-test       # ユニットテスト
  - lint            # 静的解析
  - integration     # 統合テスト
  - security        # セキュリティテスト
  - deploy-staging  # ステージングデプロイ
  - e2e-test        # E2Eテスト
  - deploy-prod     # 本番デプロイ
  - smoke-test      # スモークテスト
```

---

### 8.2 テスト実行戦略

#### **並列実行**
```yaml
利点:
  - 実行時間短縮
  - CI/CDの高速化
  
実装:
  - テストの独立性確保
  - 並列実行フレームワーク使用
  - リソース競合の回避
```

#### **テスト選択**
```yaml
変更影響分析:
  - 変更されたファイルに関連するテストのみ実行
  - 高速フィードバック
  
定期的なフル実行:
  - 夜間に全テスト実行
  - 回帰テストの確保
```

---

### 8.3 フィードバックループの最適化

```
コミット → ユニットテスト → 5分以内
    ↓
プルリクエスト → 統合テスト → 15分以内
    ↓
マージ → フルテスト → 30分以内
    ↓
デプロイ → E2Eテスト → 1時間以内
```

**目標**:
- 開発者は10分以内にフィードバックを得る
- ブロッキング問題は即座に通知

---

## 9. テストメトリクスとKPI

### 9.1 主要メトリクス

```yaml
テスト実行メトリクス:
  - テスト総数
  - 成功率
  - 失敗率
  - スキップ率
  - 実行時間
  
品質メトリクス:
  - コードカバレッジ
  - ブランチカバレッジ
  - バグ検出率
  - バグ密度
  
効率メトリクス:
  - テスト作成時間
  - テスト実行時間
  - バグ修正時間
  - フレイキーテスト率
```

---

### 9.2 KPI目標値

| メトリクス | 目標 | 評価基準 |
|-----------|------|---------|
| テスト成功率 | > 98% | 優秀: 100%, 良好: 98-99% |
| コードカバレッジ | > 80% | 優秀: 85%+, 良好: 80-84% |
| フレイキーテスト率 | < 2% | 優秀: < 1%, 良好: 1-2% |
| ユニットテスト実行時間 | < 5分 | 優秀: < 3分, 良好: 3-5分 |
| 統合テスト実行時間 | < 15分 | 優秀: < 10分, 良好: 10-15分 |
| E2Eテスト実行時間 | < 30分 | 優秀: < 20分, 良好: 20-30分 |

---

### 9.3 テストカバレッジ要件と例外適用基準

#### 基本要件

```yaml
基本要件:
  新規プロジェクト:
    全体カバレッジ: 80%以上
    ビジネスロジック: 90%以上
  
  新規機能追加:
    新規コード部分: 90%以上
    既存コード影響範囲: 80%以上
  
  バグ修正:
    修正箇所およびその周辺: 100%
```

---

#### 例外が認められるケース

以下の状況では、カバレッジ要件の例外適用が認められる場合があります。

---

##### **ケース1: レガシーコードベースへの機能追加**

**状況**:
- 既存プロジェクトのカバレッジが低い (< 50%)
- 新規機能を追加する
- レガシーコード全体のテスト追加は非現実的

**例外基準**:
```yaml
適用条件:
  既存コードカバレッジ: < 50%
  新規追加コード量: 既存コードの < 20%

例外要件:
  新規コード部分:
    カバレッジ: 90%以上（通常より高い基準）
  
  レガシーコード部分:
    変更箇所のみテスト追加:
      - 変更箇所自体: 100%
      - 影響範囲: 主要パスのテスト必須
    未変更箇所: テスト追加不要
  
  全体目標:
    既存カバレッジから +5%以上の向上
    （例: 35% → 42% = +7%）

承認:
  必須: Tech Leadの承認
  記録: 技術的負債リストに記録

改善計画:
  必須: レガシーコードのテスト追加計画を別PBIで立案
  タイミング: 3ヶ月以内に段階的なテスト追加実施
  目標: 最終的に60%以上を目指す
```

**記録例**:
```markdown
## テストカバレッジ例外適用: PROJ-1234

### 状況
- プロジェクト: PaymentService
- 既存カバレッジ: 35%
- 新機能: 新決済手段の追加（新規コード 2,000行）

### 例外内容
全体カバレッジ80%要件を以下に変更:
- 新規コード: 92%（達成）
- レガシーコード: 変更箇所のみ（達成）
- 全体: 35% → 42%（+7%）

### 承認
- Tech Lead: John Doe（承認日: 2025-11-19）

### 改善計画
- PBI-5678: PaymentService テストカバレッジ向上（3ヶ月計画）
  - 目標: 35% → 60%
  - フェーズ1（1ヶ月）: コア機能のテスト追加 → 45%
  - フェーズ2（2ヶ月）: 主要パスのテスト追加 → 55%
  - フェーズ3（3ヶ月）: エッジケースのテスト追加 → 60%
```

---

##### **ケース2: UI/統合テストが困難なコード**

**状況**:
- 外部サービス連携が多い
- モック作成が困難
- E2Eテストが不安定

**例外基準**:
```yaml
適用条件:
  外部依存度: 高い（3つ以上の外部サービス）
  モック作成の複雑度: 高い

例外要件:
  ユニットテスト:
    カバレッジ: 85%以上（通常より高い）
  
  統合テスト:
    カバレッジ: 60%以上（通常 80%を緩和）
    主要シナリオ: 必須
  
  E2Eテスト:
    最小限のスモークテストのみ

代替対策:
  必須:
    - 契約テスト（Pact等）の導入
    - 本番モニタリングの強化
    - カナリアデプロイの実施
    - エラーレートアラートの設定

承認:
  必須: Tech Lead + QA Leadの承認
```

---

##### **ケース3: 緊急修正（Hotfix）**

**状況**:
- 24時間以内の対応が必要
- 本番障害の緊急修正

**例外基準**:
```yaml
適用条件:
  PBIタイプ: HOT (Hotfix)
  対応期限: 24時間以内

緊急対応時の要件:
  修正箇所のユニットテスト: 100%（必須）
  影響範囲の統合テスト: 主要シナリオのみ
  全体カバレッジ: 要件なし

事後対応（必須）:
  72時間以内に完全なテストスイート追加:
    - 全ユニットテスト
    - 全統合テスト
    - E2Eテスト（必要に応じて）
  
  Post-Incident Review:
    - 根本原因分析
    - 再発防止策の実施
    - テストギャップの特定と対策

承認:
  緊急対応: On-call Engineerの判断で実施可能
  事後報告: Tech Leadへの報告必須
```

---

##### **ケース4: POC/実験的機能**

**状況**:
- 技術検証が目的
- 本番導入は未定

**例外基準**:
```yaml
適用条件:
  PBIタイプ: POC (Proof of Concept)
  本番導入: 未定

要件:
  ユニットテスト: 主要ロジックのみ（カバレッジ要件なし）
  統合テスト: 基本的な動作確認のみ
  E2Eテスト: 不要

注意事項:
  本番導入する場合は通常要件（80%）で再実装:
    - POCコードをそのまま本番に持ち込まない
    - NFDまたはENHとして新規実装を推奨

承認:
  必須: Tech Leadの承認
  POC期間: 明記（通常2週間以内）
```

---

#### 例外申請プロセス

```markdown
## テストカバレッジ例外申請テンプレート

### 基本情報
- **PBI**: PROJ-XXXX
- **プロジェクト**: [プロジェクト名]
- **申請日**: YYYY-MM-DD
- **申請者**: [氏名]

### 例外内容
- **通常要件**: 全体カバレッジ 80%以上
- **申請要件**: [具体的な数値]

### 該当ケース
- [ ] レガシーコードベース
- [ ] 外部依存度が高い
- [ ] 緊急修正 (Hotfix)
- [ ] POC/実験的機能
- [ ] その他: [説明]

### 理由
[例外が必要な具体的な理由]

### 代替対策
[カバレッジ要件を緩和する代わりに実施する対策]

### 改善計画（該当する場合）
[将来的にカバレッジを向上させる計画]

### 承認
- **Tech Lead**: [氏名] - [承認/却下] - [日付]
- **QA Lead** (必要な場合): [氏名] - [承認/却下] - [日付]

### 技術的負債としての記録
- [ ] 技術的負債リストに追加済み
- [ ] 改善PBI作成済み（該当する場合）
```

---

#### AIエージェントへの指示

```yaml
ai_guidelines:
  テストカバレッジ判断時:
    1. 通常要件 (80%) の適用を試みる
    2. 困難な場合、上記4つのケースに該当するか確認
    3. 該当する場合、自動承認条件を確認
    4. 自動承認条件を満たす場合、事前承認済みとして進行
    5. 条件を満たさない場合、例外申請テンプレートを作成し人間承認を待つ
  
  # === 自動承認ルール ===
  auto_approval_rules:
    
    case1_legacy_code:
      条件_全て満たす必要:
        - 既存カバレッジ < 50%
        - 新規コードカバレッジ >= 90%
        - 変更箇所自体 100%カバー
        - 全体カバレッジ +5%以上向上
        - 技術的負債リストに自動記録完了
        - 改善PBI自動作成完了
      対応:
        - 事前承認済みとして進行
        - 週次サマリーで事後報告
        - Tech Leadへの個別承認不要
    
    case2_external_dependencies:
      条件_全て満たす必要:
        - ユニットテスト >= 85%
        - 統合テスト >= 60%
        - 契約テスト(Pact等)導入済み
        - モニタリング強化済み(アラート設定)
        - カナリアデプロイ設定済み
      対応:
        - 自動承認
        - Tech Lead + QA Leadへ週次報告
    
    case3_hotfix:
      条件_全て満たす必要:
        - PBIタイプ: HOT
        - 修正箇所ユニットテスト 100%
        - 影響範囲の主要シナリオテスト完了
        - 72時間以内の完全テストスイート追加を自動スケジュール
      対応:
        - 条件満たせば即座に進行
        - On-call Engineerへの通知のみ(承認待ち不要)
        - 72時間後に完全テストスイート追加確認
    
    case4_poc:
      条件_全て満たす必要:
        - PBIタイプ: POC
        - POC期間 <= 2週間
        - 本番環境影響なし
        - 主要ロジックのテスト存在
      対応:
        - 自動承認
        - Tech Leadへ週次報告
  
  # === 人間承認が必要なケース ===
  human_approval_required:
    - 上記自動承認条件を満たさない例外申請
    - カスタム例外ケース(上記４つ以外)
    - セキュリティリスクを伴う場合
    - 本番データに影響する場合
  
  ai_cannot_auto_decide:
    - "✗ 自動承認条件を満たさない例外の承認"
    - "✗ カバレッジ要件の勝手な緩和"
    - "✗ 「困難だから」という理由だけでの要件スキップ"
  
  must_do:
    - "✓ 自動承認条件をまず確認"
    - "✓ 条件満たせば事前承認済みとして進行"
    - "✓ 例外理由を具体的に説明(人間承認時)"
    - "✓ 代替対策を必ず提案(人間承認時)"
    - "✓ 改善計画を明示(レガシーコードの場合)"
    - "✓ 全ての自動承認を記録・報告"
```

---

## 10. テストプロセス改善

### 10.1 継続的改善サイクル

```
測定 → 分析 → 改善 → 検証 → 測定...
```

#### **測定**
- メトリクス収集
- データ蓄積
- トレンド分析

#### **分析**
- ボトルネック特定
- 問題の根本原因分析
- 改善機会の発見

#### **改善**
- アクションプランの策定
- 実施
- ドキュメント更新

#### **検証**
- 改善効果の測定
- KPI達成度評価
- フィードバック収集

---

### 10.2 レトロスペクティブ

**スプリント終了時**:
```markdown
## テストレトロスペクティブ

### うまくいったこと
- テストカバレッジ85%達成
- フレイキーテスト3件修正

### 問題点
- E2Eテスト実行時間が長い（45分）
- 統合テストの環境セットアップが複雑

### アクションアイテム
1. E2Eテストの並列化検討
2. テスト環境のDockerコンテナ化
3. フレイキーテスト0件を目標に
```

---

## 11. Devin AIガイドライン

### 11.1 テスト戦略の自動生成

**Devinへのプロンプト例**:
```
【タスク】
以下の機能に対するテスト戦略を策定してください。

【機能】
新規ユーザー登録API
- エンドポイント: POST /api/register
- 入力: email, password, name
- 処理: バリデーション、パスワードハッシュ化、DB保存、メール送信

【要求事項】
1. リスク評価（高/中/低）
2. テストレベルの選択（ユニット/統合/E2E）
3. テストケースの優先順位
4. カバレッジ目標
5. 推奨ツール

【出力フォーマット】
Markdown形式のテスト戦略書
```

---

### 11.2 テスト計画の自動生成

```
【タスク】
スプリントXXのテスト計画を作成してください。

【スプリント情報】
- 期間: 2025-11-01 ~ 2025-11-14
- 新機能: 3件
- バグ修正: 5件
- チーム: 開発者3名、QA 1名

【新機能詳細】
1. パスワードリセット機能
2. プロフィール編集機能
3. 通知設定機能

【出力】
- テスト計画書
- テストケース数の見積もり
- リソース配分
- スケジュール
```

---

## 📊 クイックリファレンス

### テストレベル比較表

| テストレベル | スコープ | 速度 | 自動化 | 担当 | 比率 |
|------------|---------|------|--------|------|------|
| ユニット | 単一関数/クラス | 最速 | 100% | 開発者 | 60% |
| 統合 | 複数コンポーネント | 中速 | 90%+ | 開発者/QA | 30% |
| E2E | システム全体 | 低速 | 80%+ | QA | 10% |

### テストタイプ選択ガイド

| 目的 | 推奨テストタイプ | 優先度 |
|------|----------------|--------|
| ビジネスロジック検証 | ユニット | 最高 |
| API動作確認 | 統合 | 高 |
| ユーザーフロー検証 | E2E | 中 |
| パフォーマンス確認 | 負荷テスト | 高 |
| セキュリティ確認 | SAST/DAST | 最高 |

---

## 📚 関連ドキュメント

### 内部リソース
- **ユニットテスト標準**: `/04-quality-standards/unit-testing.md`
- **統合テスト標準**: `/04-quality-standards/integration-testing.md`
- **E2Eテスト標準**: `/04-quality-standards/e2e-testing.md`
- **品質メトリクス**: `/04-quality-standards/quality-metrics.md`
- **CI/CD パイプライン**: `/03-development-process/ci-cd-pipeline.md`

### 外部参考資料
- [Test Pyramid - Martin Fowler](https://martinfowler.com/articles/practical-test-pyramid.html)
- [ISTQB Testing Glossary](https://glossary.istqb.org/)
- [Google Testing Blog](https://testing.googleblog.com/)

---

**最終更新**: 2025-10-27  
**次回レビュー予定**: 2026-01-27
