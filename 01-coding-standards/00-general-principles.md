# コーディング共通原則
## General Coding Principles

**最終更新日**: 2024-10-09  
**バージョン**: 1.0.0  
**対象**: 全プログラミング言語共通  

## 目的

このドキュメントは、プログラミング言語に依存しない普遍的なコーディング原則を定義し、自律型AI Devinおよび開発チームの判断基準として機能します。言語固有の実装詳細は各言語別規約ファイルを参照してください。

---

## 1. 基本設計原則

### 1.1 SOLID原則の適用

#### **Single Responsibility Principle（単一責任原則）**
**基本思想**: 1つのクラス・関数・モジュールは1つの責任のみを持つ

**判断基準**:
- 変更理由が複数ある場合は責任が分散している
- 「○○かつ○○を行う」という表現になる場合は分割を検討
- 1つの機能変更が複数箇所に影響する場合は設計見直し

**Devin指示**: クラス・関数作成時は単一の明確な目的のみに焦点を当てよ

#### **Open/Closed Principle（開放閉鎖原則）**
**基本思想**: 拡張に対して開放的、修正に対して閉鎖的

**判断基準**:
- 新機能追加時に既存コードの修正が必要な場合は設計を見直す
- インターフェース・抽象化を活用して拡張可能性を確保
- 設定・パラメータ化により動作を変更可能にする

**Devin指示**: 将来の機能拡張を考慮し、インターフェース・抽象化を適切に設計せよ

#### **Liskov Substitution Principle（リスコフの置換原則）**
**基本思想**: 派生クラスは基底クラスと置換可能であること

**判断基準**:
- 派生クラスが基底クラスの契約（事前条件・事後条件）を破らない
- 基底クラスのメソッドを完全に置き換え可能
- クライアントコードが派生クラスと基底クラスを意識せず使用可能

**Devin指示**: 継承関係では基底クラスとの互換性を厳密に保持せよ

#### **Interface Segregation Principle（インターフェース分離原則）**
**基本思想**: クライアントは使用しないメソッドに依存すべきでない

**判断基準**:
- インターフェースが大きすぎる場合は用途別に分割
- 実装クラスが「使用しないメソッド」を持つ場合は設計見直し
- 機能グループごとに小さなインターフェースを作成

**Devin指示**: インターフェースは利用者の観点から最小限に設計せよ

#### **Dependency Inversion Principle（依存性逆転原則）**
**基本思想**: 上位モジュールは下位モジュールに依存せず、両者は抽象に依存すべき

**判断基準**:
- 具象クラスへの直接依存を避け、インターフェース・抽象クラスに依存
- 依存性注入（DI）パターンの活用
- モジュール間の結合度を最小化

**Devin指示**: 具象クラスではなく抽象・インターフェースに依存せよ、依存性注入を積極活用せよ

### 1.2 Clean Code原則

#### **可読性優先**
**基本思想**: コードは書くより読まれることが多い

**判断基準**:
- 6ヶ月後の自分が理解できるか
- 新しいチームメンバーが30分以内に理解できるか
- コメントなしでも意図が伝わるか

**優先順位**:
1. 自己文書化コード（変数名・関数名で意図を表現）
2. 適切なコメント（なぜそうするかの理由）
3. ドキュメント（使用方法・仕様）

**Devin指示**: 実行効率より可読性を優先せよ、ただし著しいパフォーマンス劣化は例外とする

#### **シンプル性（KISS原則）**
**基本思想**: Keep It Simple, Stupid - 単純さこそ究極の洗練

**判断基準**:
- より単純な解決方法が存在しないか常に検討
- 複雑な実装は分割・抽象化で単純化
- 過度な最適化・汎用化を避ける

**Devin指示**: 最もシンプルで理解しやすい実装を選択せよ

#### **重複排除（DRY原則）**
**基本思想**: Don't Repeat Yourself - 同じことを二度書かない

**判断基準**:
- 3回以上の重複で抽象化を検討
- ビジネスロジックの重複は即座に共通化
- 設定・定数の重複は集約化

**注意事項**: 表面的な重複と本質的な重複を区別する

**Devin指示**: 重複を発見した場合は即座に共通化せよ、ただし無理な抽象化は避けよ

---

## 2. 命名原則

### 2.1 基本哲学

#### **自己文書化**
**基本思想**: 名前を見ただけで目的・役割が理解できる

**判断基準**:
- 名前から型・用途・スコープが推測可能
- ビジネス用語・ドメイン用語をそのまま使用
- 技術的詳細より業務的意味を重視

#### **一貫性**
**基本思想**: プロジェクト全体で統一されたパターン

**判断基準**:
- 同じ概念には同じ単語を使用
- 似た機能には似た命名パターンを適用
- チーム内での用語統一

#### **検索可能性**
**基本思想**: IDE・エディタで容易に検索・発見できる

**判断基準**:
- 一意性のある名前を使用
- 略語より完全形を優先（ただし一般的略語は例外）
- typoしにくい単語を選択

### 2.2 命名基準

#### **変数・関数名**
- **動詞＋名詞**の組み合わせで意図を明確化
- **bool値**には`is`、`has`、`can`、`should`を接頭辞として使用
- **配列・リスト**には複数形を使用
- **一時変数**でも意味のある名前を付与

#### **クラス・型名**
- **名詞**を使用し、責任を表現
- **抽象クラス・インターフェース**には目的を明確に表現
- **例外クラス**には`Error`、`Exception`を接尾辞として使用

#### **定数・設定値**
- **大文字＋アンダースコア**（言語規約に従う）
- **用途・単位**を名前に含める
- **マジックナンバー**は必ず名前付き定数に置換

**Devin指示**: 略語・省略形より完全形を優先し、ビジネス用語をそのまま使用せよ

---

## 3. エラーハンドリング原則

### 3.1 基本思想

#### **フェイルファスト**
**基本思想**: 問題を早期発見・早期対応

**判断基準**:
- 不正な状態・データを検出したら即座に例外発生
- 処理継続より安全な停止を優先
- 部分的成功より全体の整合性を重視

#### **ユーザビリティ**
**基本思想**: エンドユーザーに分かりやすいメッセージ

**判断基準**:
- 技術的詳細をユーザーに露出しない
- 具体的な解決方法を提示
- 多言語対応を考慮したメッセージ設計

#### **運用性**
**基本思想**: システム管理者・開発者が問題を特定できる

**判断基準**:
- 詳細なログ情報を記録
- スタックトレース・関連データを保持
- 外部システム・サービスとの連携状況を記録

### 3.2 対応レベル

#### **Level 1: 予期可能エラー**
- **対応方法**: 事前チェック・バリデーションで回避
- **例**: 入力値チェック、リソース存在確認、権限チェック
- **ログレベル**: INFO または WARNING

#### **Level 2: 予期不可能エラー（回復可能）**
- **対応方法**: 適切な例外処理で対応・リトライ
- **例**: ネットワーク障害、一時的なリソース不足
- **ログレベル**: ERROR（回復後はWARNING）

#### **Level 3: システム障害（回復不可能）**
- **対応方法**: ログ記録＋アラート通知＋安全な停止
- **例**: データベース接続断、重要な設定ファイル欠損
- **ログレベル**: FATAL または CRITICAL

**Devin指示**: エラーレベルに応じた適切な処理を実装し、詳細なログ出力を含めよ

---

## 4. セキュリティ基本原則

### 4.1 基本思想

#### **ゼロトラスト**
**基本思想**: すべての入力を信頼しない

**判断基準**:
- 外部からの入力は必ず検証・サニタイゼーション
- 内部システム間の通信も認証・認可を実装
- 最小権限の原則を厳格に適用

#### **深層防御**
**基本思想**: 複数の防御レイヤーで保護

**判断基準**:
- 単一の防御メカニズムに依存しない
- ネットワーク・アプリケーション・データの各レイヤーでセキュリティ対策
- 攻撃検知・ログ監視・インシデント対応を組み合わせ

#### **機密性・完全性・可用性（CIA）**
**基本思想**: 情報セキュリティの3要素を確保

**判断基準**:
- **機密性**: アクセス制御・暗号化で未認可アクセスを防止
- **完全性**: データ改ざん検知・バージョン管理で完全性を保証
- **可用性**: 冗長化・バックアップでサービス継続性を確保

### 4.2 実装指針

#### **入力検証**
- **ホワイトリスト方式**を優先（ブラックリストは補完的使用）
- **型・範囲・フォーマット**を厳密にチェック
- **SQLインジェクション・XSS**対策を必須実装

#### **認証・認可**
- **多要素認証**の実装を推奨
- **最小権限の原則**を厳格に適用
- **セッション管理**を適切に実装（タイムアウト・無効化）

#### **機密情報の取り扱い**
- **環境変数・外部設定ファイル**で管理
- **ソースコードに機密情報を埋め込まない**
- **暗号化・ハッシュ化**を適切に実装

**Devin指示**: すべての外部入力を疑い、適切な検証・サニタイゼーションを実装せよ

---

## 5. コメント・ドキュメンテーション原則

### 5.1 基本哲学

#### **コードがWHAT、コメントがWHY**
**基本思想**: コードは「何をするか」、コメントは「なぜそうするか」を説明

**判断基準**:
- コードから読み取れる内容はコメントしない
- ビジネス要件・制約・背景をコメントで説明
- 設計判断・トレードオフの理由を記録

#### **未来の自分・チームメンバーへの配慮**
**基本思想**: 6ヶ月後の理解を想定

**判断基準**:
- 複雑なアルゴリズム・ビジネスロジックには必ずコメント
- 外部システム・API との連携部分は詳細に説明
- 一時的な回避策・技術的負債は明確に表示

### 5.2 コメント種別

#### **関数・メソッドコメント**
- **目的・責任**の説明
- **パラメータ・戻り値**の仕様
- **例外・エラー条件**の説明
- **使用例・注意事項**

#### **クラス・モジュールコメント**
- **設計意図・責任範囲**
- **依存関係・制約条件**
- **ライフサイクル・使用パターン**

#### **インラインコメント**
- **複雑な計算ロジック**の説明
- **ビジネスルール・制約**の背景
- **パフォーマンス・最適化**の理由
- **TODO・FIXME・HACK**の明確な表示

**Devin指示**: 複雑なロジック・ビジネス要件には必ずコメントを付与し、WHYを重視せよ

---

## 6. テスト基本原則

### 6.1 基本思想

#### **テストピラミッド**
**基本思想**: 単体テスト（多数）→ 統合テスト（中程度）→ E2Eテスト（少数）

**判断基準**:
- **単体テスト**: 70-80%のカバレッジを目標
- **統合テスト**: モジュール間の連携を重点的にテスト
- **E2Eテスト**: 重要なユーザージャーニーを選択的にテスト

#### **テスタビリティ**
**基本思想**: テストしやすい設計がよい設計

**判断基準**:
- 依存性注入でモック・スタブを使用可能
- 副作用のない純粋関数を優先
- 外部依存を抽象化・分離

### 6.2 テスト設計原則

#### **AAA パターン**
- **Arrange**: テストデータ・環境の準備
- **Act**: テスト対象の実行
- **Assert**: 結果の検証

#### **FIRST 原則**
- **Fast**: 高速な実行
- **Independent**: テスト間の独立性
- **Repeatable**: 繰り返し実行可能
- **Self-validating**: 自動判定（成功・失敗）
- **Timely**: 実装と同時期に作成

#### **テストケース設計**
- **正常系・異常系・境界値**を必ずテスト
- **ビジネスロジック**は100%カバレッジを目標
- **エッジケース・コーナーケース**を積極的にテスト

**Devin指示**: テスト容易性を考慮した設計とし、AAA・FIRSTパターンに従ったテストコードを作成せよ

---

## 7. パフォーマンス考慮事項

### 7.1 基本思想

#### **測定ベース最適化**
**基本思想**: 推測ではなく実測に基づく最適化

**判断基準**:
- パフォーマンスボトルネックを特定してから最適化
- プロファイリングツールで定量的に評価
- 最適化前後での性能比較を必ず実施

#### **適切な抽象化レベル**
**基本思想**: パフォーマンスと可読性のバランス

**判断基準**:
- 可読性を犠牲にする最適化は慎重に判断
- 重要な処理のみ低レベル最適化を適用
- 一般的な処理は高レベル抽象化を優先

### 7.2 最適化指針

#### **アルゴリズム・データ構造**
- **計算量（時間・空間）**を意識した選択
- **適切なデータ構造**の選択（配列・ハッシュ・ツリー等）
- **キャッシュ効率**を考慮したアクセスパターン

#### **リソース管理**
- **メモリリーク**の防止
- **接続・ファイルハンドル**の適切なクローズ
- **大量データ処理**でのストリーミング処理

#### **外部システム連携**
- **バッチ処理・並列処理**の活用
- **接続プール・キャッシュ**の適切な使用
- **タイムアウト・リトライ**の実装

**Devin指示**: 可読性を優先しつつ、明らかなパフォーマンス問題は積極的に最適化せよ

---

## 8. 判断基準・優先順位

### 8.1 原則間の優先順位

**最高優先**: セキュリティ・データ整合性
- 機能性・パフォーマンスより安全性を優先
- 機密情報保護・脆弱性対策は妥協不可

**高優先**: 可読性・保守性
- 短期的な開発効率より長期的な保守性を重視
- 複雑な最適化より単純で理解しやすい実装

**中優先**: パフォーマンス・効率性
- ユーザー体験に大きく影響する場合は高優先に昇格
- 可読性と両立可能な範囲で最適化

**低優先**: 技術的完璧性・新技術採用
- ビジネス価値に直結しない技術的探求は控えめに
- 実績のある技術を優先、新技術は慎重に評価

### 8.2 例外・特殊ケース

#### **リアルタイム・高頻度処理**
- パフォーマンスが最高優先に昇格
- 可読性との適切なバランスを考慮

#### **プロトタイプ・概念検証**
- 速度・柔軟性を最優先
- 品質基準を一時的に緩和（明確な期限付き）

#### **レガシーシステム統合**
- 既存システムとの整合性を重視
- 段階的な品質改善アプローチを採用

**Devin指示**: セキュリティ・可読性を基本とし、特殊要件がある場合のみ例外的判断を行え

---

## 9. Devin向け実行ガイドライン

### 9.1 基本実行フロー

1. **要件理解**: ビジネス要件・技術制約を正確に把握
2. **原則適用**: 本ドキュメントの原則に基づいて設計判断
3. **言語規約参照**: 該当言語の具体的実装規約を確認
4. **実装実行**: 原則・規約に従ってコード生成
5. **品質確認**: 生成コードが原則に適合しているかチェック

### 9.2 判断迷い時の対応

1. **本ドキュメントに立ち戻る**: 基本原則から判断
2. **優先順位を適用**: セキュリティ > 可読性 > パフォーマンス
3. **シンプルな解決策を選択**: 複雑さより単純さを優先
4. **一貫性を保持**: 既存コードとの整合性を重視

### 9.3 品質チェックポイント

#### **設計品質**
- [ ] SOLID原則に準拠しているか
- [ ] 適切な抽象化レベルか
- [ ] 責任範囲が明確か

#### **実装品質**
- [ ] 命名規則に従っているか
- [ ] エラーハンドリングが适切か
- [ ] セキュリティ要件を満たしているか

#### **保守性**
- [ ] 可読性が高いか
- [ ] コメント・ドキュメントが充実しているか
- [ ] テスタビリティが確保されているか

**Devin最終指示**: この原則を常に参照し、判断に迷った場合は保守性・安全性を優先した選択を行え

---

## 改訂履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|----------|--------|
| 1.0.0 | 2024-10-09 | 初版作成 | システム |

---

**注意**: このドキュメントは全言語共通の原則です。具体的な実装方法は各言語別規約ファイルを参照してください。