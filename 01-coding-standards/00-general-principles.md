# コーディング共通原則
## General Coding Principles

**最終更新日**: 2024-10-09  
**バージョン**: 1.1.0  
**対象**: 全プログラミング言語共通  

## 目的

このドキュメントは、プログラミング言語に依存しない普遍的なコーディング原則を定義し、自律型AI Devinおよび開発チームの判断基準として機能します。言語固有の実装詳細は各言語別規約ファイルを参照してください。

**🆕 コメント規約ドキュメント（2025-11-14追加）**: 詳細なコメント記述規約は以下を参照:
- [00-inline-comment-standards.md](00-inline-comment-standards.md) - インラインコメント共通原則
- [00-test-comment-standards.md](00-test-comment-standards.md) - テストコメント共通原則
- 言語別実装例: [python/](python/) | [java/](java/) | [typescript/](typescript/) | [sql/](sql/) | [css/](css/)

---

## 1. 基本設計原則

### 1.1 SOLID原則の適用

#### **Single Responsibility Principle（単一責任原則）**
**基本思想**: 1つのクラス・関数・モジュールは1つの責任のみを持つ

**判断基準**:
- 変更理由が複数ある場合は責任が分散している
- 「○○かつ○○を行う」という表現になる場合は分割を検討
- 1つの機能変更が複数箇所に影響する場合は設計見直し

**Devin指示**: クラス・関数作成時は単一の明確な目的のみに焦点を当てよ

#### **Open/Closed Principle（開放閉鎖原則）**
**基本思想**: 拡張に対して開放的、修正に対して閉鎖的

**判断基準**:
- 新機能追加時に既存コードの修正が必要な場合は設計を見直す
- インターフェース・抽象化を活用して拡張可能性を確保
- 設定・パラメータ化により動作を変更可能にする

**Devin指示**: 将来の機能拡張を考慮し、インターフェース・抽象化を適切に設計せよ

#### **Liskov Substitution Principle（リスコフの置換原則）**
**基本思想**: 派生クラスは基底クラスと置換可能であること

**判断基準**:
- 派生クラスが基底クラスの契約（事前条件・事後条件）を破らない
- 基底クラスのメソッドを完全に置き換え可能
- クライアントコードが派生クラスと基底クラスを意識せず使用可能

**Devin指示**: 継承関係では基底クラスとの互換性を厳密に保持せよ

#### **Interface Segregation Principle（インターフェース分離原則）**
**基本思想**: クライアントは使用しないメソッドに依存すべきでない

**判断基準**:
- インターフェースが大きすぎる場合は用途別に分割
- 実装クラスが「使用しないメソッド」を持つ場合は設計見直し
- 機能グループごとに小さなインターフェースを作成

**Devin指示**: インターフェースは利用者の観点から最小限に設計せよ

#### **Dependency Inversion Principle（依存性逆転原則）**
**基本思想**: 上位モジュールは下位モジュールに依存せず、両者は抽象に依存すべき

**判断基準**:
- 具象クラスへの直接依存を避け、インターフェース・抽象クラスに依存
- 依存性注入（DI）パターンの活用
- モジュール間の結合度を最小化

**Devin指示**: 具象クラスではなく抽象・インターフェースに依存せよ、依存性注入を積極活用せよ

### 1.2 Clean Code原則

#### **可読性優先**
**基本思想**: コードは書くより読まれることが多い

**判断基準**:
- 6ヶ月後の自分が理解できるか
- 新しいチームメンバーが30分以内に理解できるか
- コメントなしでも意図が伝わるか

**優先順位**:
1. 自己文書化コード（変数名・関数名で意図を表現）
2. 適切なコメント（なぜそうするかの理由）
3. ドキュメント（使用方法・仕様）

**Devin指示**: 実行効率より可読性を優先せよ、ただし著しいパフォーマンス劣化は例外とする

#### **シンプル性（KISS原則）**
**基本思想**: Keep It Simple, Stupid - 単純さこそ究極の洗練

**判断基準**:
- より単純な解決方法が存在しないか常に検討
- 複雑な実装は分割・抽象化で単純化
- 過度な最適化・汎用化を避ける

**Devin指示**: 最もシンプルで理解しやすい実装を選択せよ

#### **重複排除（DRY原則）**
**基本思想**: Don't Repeat Yourself - 同じことを二度書かない

**判断基準**:
- 3回以上の重複で抽象化を検討
- ビジネスロジックの重複は即座に共通化
- 設定・定数の重複は集約化

**注意事項**: 表面的な重複と本質的な重複を区別する

**Devin指示**: 重複を発見した場合は即座に共通化せよ、ただし無理な抽象化は避けよ

### 1.3 コード保守性メトリクス

#### **関数/メソッドサイズ基準**
**基本思想**: 小さい関数は理解・テスト・再利用が容易

**定量基準**:
- **理想**: 1関数20行以内
- **推奨上限**: 50行
- **絶対上限**: 100行（超える場合は必ず分割検討）

**例外条件**:
- 設定データの初期化（辞書・配列の大規模定義）
- 自動生成コード
- フレームワークが要求する特定パターン

**Devin指示**: 関数が50行を超える場合、サブ関数への分割を検討せよ

---

#### **クラス/ファイルサイズ基準**
**基本思想**: 大きなクラスは単一責任原則違反の兆候

**定量基準**:
- **理想**: 1クラス200行以内
- **推奨上限**: 400行
- **絶対上限**: 1000行（超える場合は必ず分割）

**例外条件**:
- ドメインモデル（多数のフィールドとメソッドを持つエンティティ）
- 自動生成コード
- レガシーコードの段階的リファクタリング中

**Devin指示**: クラスが400行を超える場合、責任分割を検討せよ

---

#### **循環的複雑度（Cyclomatic Complexity）**
**基本思想**: 分岐が多いと理解・テストが困難

**定量基準**:
- **理想**: 複雑度5以下
- **推奨上限**: 10
- **絶対上限**: 15（超える場合は必ずリファクタ）

**測定方法**:
```
複雑度 = 分岐数 + 1
（if, else if, switch case, for, while, catch, &&, || などをカウント）
```

**改善方法**:
- 複雑な条件を述語関数に抽出
- Early Return パターンでネスト削減
- Strategy パターンで分岐を抽象化

**Devin指示**: 複雑度が10を超える関数は、条件分岐の抽出または戦略パターン適用を検討せよ

---

#### **認知的複雑度（Cognitive Complexity）**
**基本思想**: コードを理解するための精神的負荷を測定

**定量基準**:
- **理想**: 複雑度5以下
- **推奨上限**: 15
- **絶対上限**: 25（超える場合は必ずリファクタ）

**測定特性**:
- ネストした制御構造に高いペナルティ
- 線形な制御フローは低ペナルティ
- 再帰は高ペナルティ

**改善方法**:
- Guard Clause（ガード節）でネスト解消
- 複雑なロジックの別関数化
- 状態マシンやルールエンジンの活用

**Devin指示**: 認知的複雑度が15を超える場合、ネスト削減とロジック分解を最優先せよ

---

#### **ネストの深さ制限**
**基本思想**: 深いネストは追跡困難

**定量基準**:
- **理想**: ネスト2階層以内
- **推奨上限**: 3階層
- **絶対上限**: 4階層（超える場合は必ずリファクタ）

**改善方法**:
```python
# ❌ Bad: 深すぎるネスト（4階層）
def process_data(data):
    if data is not None:
        if data.is_valid():
            for item in data.items:
                if item.needs_processing():
                    # 処理...

# ✅ Good: Early Return で平坦化（2階層）
def process_data(data):
    if data is None or not data.is_valid():
        return
    
    for item in data.items:
        if not item.needs_processing():
            continue
        # 処理...
```

**Devin指示**: ネストが3階層を超える場合、Early Return または関数分割を適用せよ

---

#### **パラメータ数の制限**
**基本思想**: 多すぎるパラメータは使用ミス・理解困難の原因

**定量基準**:
- **理想**: 3個以内
- **推奨上限**: 5個
- **絶対上限**: 7個（超える場合は必ずリファクタ）

**改善方法**:
- パラメータオブジェクト（Parameter Object）の導入
- ビルダーパターン
- 設定オブジェクトの使用

```typescript
// ❌ Bad: パラメータが多すぎる
function createUser(
  name: string, email: string, age: number, 
  address: string, phone: string, role: string
) { }

// ✅ Good: パラメータオブジェクト
interface UserParams {
  name: string;
  email: string;
  age: number;
  address: string;
  phone: string;
  role: string;
}
function createUser(params: UserParams) { }
```

**Devin指示**: パラメータが5個を超える場合、パラメータオブジェクトへのリファクタを実施せよ

---

#### **依存関係の制限（カップリング）**
**基本思想**: 多すぎる依存は変更の影響範囲拡大

**定量基準**:
- **理想**: 1クラスあたり5依存以内
- **推奨上限**: 10依存
- **絶対上限**: 15依存（超える場合は設計見直し）

**測定対象**:
- import/require されるモジュール数
- インジェクトされる依存の数
- 直接参照するクラス数

**改善方法**:
- Facade パターンで依存を集約
- 依存性注入（DI）の活用
- インターフェース分離

**Devin指示**: クラスの依存が10を超える場合、Facade パターンまたはインターフェース分離を検討せよ

---

#### **コード重複率の基準**
**基本思想**: DRY原則の定量的管理

**定量基準**:
- **理想**: 重複率3%以内
- **許容上限**: 5%
- **改善必須**: 10%超（技術的負債として記録）

**測定方法**:
- 6行以上の連続した同一コードをカウント
- SonarQubeなどのツール活用

**許容される重複**:
- テストコード（Given-When-Then パターンの類似）
- 設定ファイル（環境別の類似設定）
- ドメイン固有の類似ロジック（ただし将来的な共通化を検討）

**Devin指示**: 同じコードブロックが3箇所以上に存在する場合、共通関数への抽出を実施せよ

---

#### **リファクタリングトリガー条件**
**基本思想**: 技術的負債を放置せず、適切なタイミングで改善

**即座にリファクタすべき条件**（優先度：高）:
1. 循環的複雑度 15超
2. 関数の行数 100超
3. クラスの行数 1000超
4. ネスト 4階層超
5. パラメータ数 7個超
6. 同一コードの3箇所以上の重複

**計画的リファクタすべき条件**（優先度：中）:
1. 循環的複雑度 10超
2. 関数の行数 50超
3. クラスの行数 400超
4. 依存関係 10超
5. コード重複率 5%超

**継続監視すべき条件**（優先度：低）:
1. 循環的複雑度 5超
2. テストカバレッジ 80%未満
3. コメント不足の複雑ロジック

**リファクタリング実施判断**:
- 上記基準に該当 + （機能追加 or バグ修正の必要性）
- スプリント開始時に技術的負債チケットとして計画
- コードレビューで指摘された場合

**Devin指示**: 上記トリガー条件に該当する場合、リファクタリングタスクを生成し、優先度を明示せよ

---

## 2. 命名原則

### 2.1 基本哲学

#### **自己文書化**
**基本思想**: 名前を見ただけで目的・役割が理解できる

**判断基準**:
- 名前から型・用途・スコープが推測可能
- ビジネス用語・ドメイン用語をそのまま使用
- 技術的詳細より業務的意味を重視

#### **一貫性**
**基本思想**: プロジェクト全体で統一されたパターン

**判断基準**:
- 同じ概念には同じ単語を使用
- 似た機能には似た命名パターンを適用
- チーム内での用語統一

#### **検索可能性**
**基本思想**: IDE・エディタで容易に検索・発見できる

**判断基準**:
- 一意性のある名前を使用
- 略語より完全形を優先（ただし一般的略語は例外）
- typoしにくい単語を選択

### 2.2 命名基準

#### **変数・関数名**
- **動詞＋名詞**の組み合わせで意図を明確化
- **bool値**には`is`、`has`、`can`、`should`を接頭辞として使用
- **配列・リスト**には複数形を使用
- **一時変数**でも意味のある名前を付与

#### **クラス・型名**
- **名詞**を使用し、責任を表現
- **抽象クラス・インターフェース**には目的を明確に表現
- **例外クラス**には`Error`、`Exception`を接尾辞として使用

#### **定数・設定値**
- **大文字＋アンダースコア**（言語規約に従う）
- **用途・単位**を名前に含める
- **マジックナンバー**は必ず名前付き定数に置換

**Devin指示**: 略語・省略形より完全形を優先し、ビジネス用語をそのまま使用せよ

---

## 3. エラーハンドリング原則

### 3.1 基本思想

#### **フェイルファスト**
**基本思想**: 問題を早期発見・早期対応

**判断基準**:
- 不正な状態・データを検出したら即座に例外発生
- 処理継続より安全な停止を優先
- 部分的成功より全体の整合性を重視

#### **ユーザビリティ**
**基本思想**: エンドユーザーに分かりやすいメッセージ

**判断基準**:
- 技術的詳細をユーザーに露出しない
- 具体的な解決方法を提示
- 多言語対応を考慮したメッセージ設計

#### **運用性**
**基本思想**: システム管理者・開発者が問題を特定できる

**判断基準**:
- 詳細なログ情報を記録
- スタックトレース・関連データを保持
- 外部システム・サービスとの連携状況を記録

### 3.2 対応レベル

#### **Level 1: 予期可能エラー**
- **対応方法**: 事前チェック・バリデーションで回避
- **例**: 入力値チェック、リソース存在確認、権限チェック
- **ログレベル**: INFO または WARNING

#### **Level 2: 予期不可能エラー（回復可能）**
- **対応方法**: 適切な例外処理で対応・リトライ
- **例**: ネットワーク障害、一時的なリソース不足
- **ログレベル**: ERROR（回復後はWARNING）

#### **Level 3: システム障害（回復不可能）**
- **対応方法**: ログ記録＋アラート通知＋安全な停止
- **例**: データベース接続断、重要な設定ファイル欠損
- **ログレベル**: FATAL または CRITICAL

**Devin指示**: エラーレベルに応じた適切な処理を実装し、詳細なログ出力を含めよ

---

## 4. セキュリティ基本原則

### 4.1 基本思想

#### **ゼロトラスト**
**基本思想**: すべての入力を信頼しない

**判断基準**:
- 外部からの入力は必ず検証・サニタイゼーション
- 内部システム間の通信も認証・認可を実装
- 最小権限の原則を厳格に適用

#### **深層防御**
**基本思想**: 複数の防御レイヤーで保護

**判断基準**:
- 単一の防御メカニズムに依存しない
- ネットワーク・アプリケーション・データの各レイヤーでセキュリティ対策
- 攻撃検知・ログ監視・インシデント対応を組み合わせ

#### **機密性・完全性・可用性（CIA）**
**基本思想**: 情報セキュリティの3要素を確保

**判断基準**:
- **機密性**: アクセス制御・暗号化で未認可アクセスを防止
- **完全性**: データ改ざん検知・バージョン管理で完全性を保証
- **可用性**: 冗長化・バックアップでサービス継続性を確保

### 4.2 実装指針

#### **入力検証**
- **ホワイトリスト方式**を優先（ブラックリストは補完的使用）
- **型・範囲・フォーマット**を厳密にチェック
- **SQLインジェクション・XSS**対策を必須実装

#### **認証・認可**
- **多要素認証**の実装を推奨
- **最小権限の原則**を厳格に適用
- **セッション管理**を適切に実装（タイムアウト・無効化）

#### **機密情報の取り扱い**
- **環境変数・外部設定ファイル**で管理
- **ソースコードに機密情報を埋め込まない**
- **暗号化・ハッシュ化**を適切に実装

**Devin指示**: すべての外部入力を疑い、適切な検証・サニタイゼーションを実装せよ

---

## 5. コメント・ドキュメンテーション原則

### 5.1 基本哲学

#### **コードがWHAT、コメントがWHY**
**基本思想**: コードは「何をするか」、コメントは「なぜそうするか」を説明

**判断基準**:
- コードから読み取れる内容はコメントしない
- ビジネス要件・制約・背景をコメントで説明
- 設計判断・トレードオフの理由を記録

#### **未来の自分・チームメンバーへの配慮**
**基本思想**: 6ヶ月後の理解を想定

**判断基準**:
- 複雑なアルゴリズム・ビジネスロジックには必ずコメント
- 外部システム・API との連携部分は詳細に説明
- 一時的な回避策・技術的負債は明確に表示

### 5.2 コメント種別

#### **関数・メソッドコメント**
- **目的・責任**の説明
- **パラメータ・戻り値**の仕様
- **例外・エラー条件**の説明
- **使用例・注意事項**

#### **クラス・モジュールコメント**
- **設計意図・責任範囲**
- **依存関係・制約条件**
- **ライフサイクル・使用パターン**

#### **インラインコメント**
- **複雑な計算ロジック**の説明
- **ビジネスルール・制約**の背景
- **パフォーマンス・最適化**の理由
- **TODO・FIXME・HACK**の明確な表示

**Devin指示**: 複雑なロジック・ビジネス要件には必ずコメントを付与し、WHYを重視せよ

### 5.3 ドキュメンテーション必須レベル

#### **Level 1: 必須（違反は品質ゲート不合格）**

1. **ファイルヘッダー**
   - すべてのソースファイルに記載必須
   - ファイルの目的・責任を明記
   
2. **パブリッククラス/インターフェース**
   - すべてのパブリッククラスに記載必須
   - クラスの責任・使用方法を明記
   
3. **パブリックAPI（メソッド/関数）**
   - 外部から呼び出される全APIに記載必須
   - パラメータ・戻り値・例外を明記

#### **Level 2: 強く推奨（レビューで指摘対象）**

1. **複雑なロジック**
   - 循環的複雑度10以上の関数
   - ビジネスルールや制約の説明
   - アルゴリズムの意図説明
   
2. **非自明な実装**
   - パフォーマンス最適化の理由
   - 技術的制約・回避策
   - バグ修正の背景（チケット番号）

#### **Level 3: 任意（自己文書化優先）**

1. **単純な処理**
   - 変数名・関数名から明白な処理
   - 標準的なデザインパターン適用箇所
   - 自己説明的なコード

---

#### **判断基準: コメントを書くべきか？**

**YESの場合（コメント必須）**:
- [ ] ファイル/クラス/モジュールの定義
- [ ] パブリックAPIの定義
- [ ] 6ヶ月後の自分が「なぜこうしたか」を忘れる可能性
- [ ] コードレビュアーが「なぜ？」と質問しそう
- [ ] ビジネスルール・仕様の制約を反映している
- [ ] バグ修正・パフォーマンス最適化の理由

**NOの場合（コメント不要）**:
- [ ] コードを読めば明白（`getUserById()` など）
- [ ] 標準的なデザインパターン適用
- [ ] 単純なゲッター/セッター
- [ ] 自己説明的な変数名・関数名

**Devin指示**: すべてのファイル・クラス・パブリックAPIにドキュメントを必ず付与せよ。内部実装のコメントは、複雑度10以上またはビジネスロジックの場合のみ記載せよ。

**📚 詳細なコメント規約**: 
- **[00-inline-comment-standards.md](00-inline-comment-standards.md)** - インラインコメントの共通原則（日本語必須、WHY原則、複雑度基準）
- **[00-test-comment-standards.md](00-test-comment-standards.md)** - テストコメントの共通原則（Given-When-Then、4要素）
- 言語別実装例: [python/](python/) | [java/](java/) | [typescript/](typescript/) | [sql/](sql/) | [css/](css/)

### 5.4 ファイル/クラスレベルドキュメンテーション標準

#### **基本構造（全言語共通の考え方）**

```
ファイル/クラスのドキュメント:
  ├─ 概要（What）: このファイル/クラスが何を表現しているか
  ├─ 責任（Responsibility）: 単一責任原則における責任
  ├─ 使用例（Usage）: 典型的な使用パターン（任意）
  ├─ 注意事項（Notes）: 制約・前提条件（あれば）
  └─ 作成/更新情報: 作成日、最終更新、作成者（任意）
```

#### **必須記載項目**
- ✅ **概要**: 1-3文でファイル/クラスの目的を説明
- ✅ **責任**: このファイル/クラスが「何をする」のか

#### **推奨記載項目**
- 📝 **使用例**: 複雑なAPIの場合
- 📝 **注意事項**: スレッドセーフでない、副作用がある等
- 📝 **関連**: 密接に関連するクラス・モジュール

#### **不要な記載**
- ❌ コードから明白な情報の繰り返し
- ❌ 変更履歴（Gitで管理）
- ❌ 作成者情報（Gitで管理）

#### **言語別ドキュメンテーション形式**

**TypeScript/JavaScript**: JSDoc形式
```typescript
/**
 * ユーザー認証サービス
 * 
 * ユーザーのログイン・ログアウト・トークン検証を担当する。
 * JWTベースの認証を実装し、リフレッシュトークンをサポート。
 * 
 * @module services/auth
 */
```

**Python**: Google Style Docstring
```python
"""
ユーザー認証モジュール

ユーザーのログイン・ログアウト・トークン検証機能を提供する。
JWTベースの認証を実装し、リフレッシュトークンをサポート。
"""
```

**Java**: Javadoc
```java
/**
 * ユーザー認証パッケージ
 * 
 * <p>ユーザーのログイン・ログアウト・トークン検証機能を提供する。
 * JWTベースの認証を実装し、リフレッシュトークンをサポート。</p>
 * 
 * @since 1.0
 */
package com.example.auth;
```

**SQL**: ヘッダーコメント
```sql
-- ============================================================================
-- View: user_activity_summary
-- 
-- 説明: ユーザーごとのアクティビティサマリを集計するビュー
--       最終ログイン日時、総ログイン回数、アクティブ日数を提供
-- 
-- 依存: users, login_logs
-- ============================================================================
```

**CSS/SCSS**: ブロックコメント
```scss
/**
 * ユーザープロフィールコンポーネント
 * 
 * ユーザーのアバター、名前、ステータスを表示する再利用可能コンポーネント。
 * モバイル・タブレット・デスクトップのレスポンシブ対応。
 */
```

**Devin指示**: すべてのファイル・クラスに、言語に応じた標準形式でドキュメンテーションコメントを付与せよ。概要と責任は必須、使用例と注意事項は複雑なAPIの場合に追加せよ。

---

## 6. テスト基本原則

### 6.1 基本思想

#### **テストピラミッド**
**基本思想**: 単体テスト（多数）→ 統合テスト（中程度）→ E2Eテスト（少数）

**判断基準**:
- **単体テスト**: 70-80%のカバレッジを目標
- **統合テスト**: モジュール間の連携を重点的にテスト
- **E2Eテスト**: 重要なユーザージャーニーを選択的にテスト

#### **テスタビリティ**
**基本思想**: テストしやすい設計がよい設計

**判断基準**:
- 依存性注入でモック・スタブを使用可能
- 副作用のない純粋関数を優先
- 外部依存を抽象化・分離

### 6.2 テスト設計原則

#### **AAA パターン**
- **Arrange**: テストデータ・環境の準備
- **Act**: テスト対象の実行
- **Assert**: 結果の検証

#### **FIRST 原則**
- **Fast**: 高速な実行
- **Independent**: テスト間の独立性
- **Repeatable**: 繰り返し実行可能
- **Self-validating**: 自動判定（成功・失敗）
- **Timely**: 実装と同時期に作成

#### **テストケース設計**
- **正常系・異常系・境界値**を必ずテスト
- **ビジネスロジック**は100%カバレッジを目標
- **エッジケース・コーナーケース**を積極的にテスト

**Devin指示**: テスト容易性を考慮した設計とし、AAA・FIRSTパターンに従ったテストコードを作成せよ

---

## 7. パフォーマンス考慮事項

### 7.1 基本思想

#### **測定ベース最適化**
**基本思想**: 推測ではなく実測に基づく最適化

**判断基準**:
- パフォーマンスボトルネックを特定してから最適化
- プロファイリングツールで定量的に評価
- 最適化前後での性能比較を必ず実施

#### **適切な抽象化レベル**
**基本思想**: パフォーマンスと可読性のバランス

**判断基準**:
- 可読性を犠牲にする最適化は慎重に判断
- 重要な処理のみ低レベル最適化を適用
- 一般的な処理は高レベル抽象化を優先

### 7.2 最適化指針

#### **アルゴリズム・データ構造**
- **計算量（時間・空間）**を意識した選択
- **適切なデータ構造**の選択（配列・ハッシュ・ツリー等）
- **キャッシュ効率**を考慮したアクセスパターン

#### **リソース管理**
- **メモリリーク**の防止
- **接続・ファイルハンドル**の適切なクローズ
- **大量データ処理**でのストリーミング処理

#### **外部システム連携**
- **バッチ処理・並列処理**の活用
- **接続プール・キャッシュ**の適切な使用
- **タイムアウト・リトライ**の実装

**Devin指示**: 可読性を優先しつつ、明らかなパフォーマンス問題は積極的に最適化せよ

---

## 8. 判断基準・優先順位

### 8.1 原則間の優先順位

**最高優先**: セキュリティ・データ整合性
- 機能性・パフォーマンスより安全性を優先
- 機密情報保護・脆弱性対策は妥協不可

**高優先**: 可読性・保守性
- 短期的な開発効率より長期的な保守性を重視
- 複雑な最適化より単純で理解しやすい実装

**中優先**: パフォーマンス・効率性
- ユーザー体験に大きく影響する場合は高優先に昇格
- 可読性と両立可能な範囲で最適化

**低優先**: 技術的完璧性・新技術採用
- ビジネス価値に直結しない技術的探求は控えめに
- 実績のある技術を優先、新技術は慎重に評価

### 8.2 例外・特殊ケース

#### **リアルタイム・高頻度処理**
- パフォーマンスが最高優先に昇格
- 可読性との適切なバランスを考慮

#### **プロトタイプ・概念検証**
- 速度・柔軟性を最優先
- 品質基準を一時的に緩和（明確な期限付き）

#### **レガシーシステム統合**
- 既存システムとの整合性を重視
- 段階的な品質改善アプローチを採用

**Devin指示**: セキュリティ・可読性を基本とし、特殊要件がある場合のみ例外的判断を行え

---

## 9. Devin向け実行ガイドライン

### 9.1 基本実行フロー

1. **要件理解**: ビジネス要件・技術制約を正確に把握
2. **原則適用**: 本ドキュメントの原則に基づいて設計判断
3. **言語規約参照**: 該当言語の具体的実装規約を確認
4. **実装実行**: 原則・規約に従ってコード生成
5. **品質確認**: 生成コードが原則に適合しているかチェック

### 9.2 判断迷い時の対応

1. **本ドキュメントに立ち戻る**: 基本原則から判断
2. **優先順位を適用**: セキュリティ > 可読性 > パフォーマンス
3. **シンプルな解決策を選択**: 複雑さより単純さを優先
4. **一貫性を保持**: 既存コードとの整合性を重視

### 9.3 品質チェックポイント

#### **設計品質**
- [ ] SOLID原則に準拠しているか
- [ ] 適切な抽象化レベルか
- [ ] 責任範囲が明確か
- [ ] メトリクスが基準内か（複雑度、行数等）

#### **実装品質**
- [ ] 命名規則に従っているか
- [ ] エラーハンドリングが適切か
- [ ] セキュリティ要件を満たしているか

#### **保守性**
- [ ] 可読性が高いか
- [ ] ファイル/クラス/パブリックAPIにドキュメントがあるか
- [ ] テスタビリティが確保されているか
- [ ] 保守性メトリクスが基準内か

**Devin最終指示**: この原則を常に参照し、判断に迷った場合は保守性・安全性を優先した選択を行え。すべてのファイル・クラス・パブリックAPIにドキュメンテーションコメントを必ず付与せよ。内部実装は、複雑度10以上、ビジネスルールの反映、技術的制約の回避といった「なぜそうしたか」が不明瞭な場合のみコメントを記載せよ。

---

## 改訂履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|----------|--------|
| 1.0.0 | 2024-10-09 | 初版作成 | システム |
| 1.1.0 | 2025-10-23 | 保守性メトリクス追加、ドキュメンテーション必須化 | システム |

---

**注意**: このドキュメントは全言語共通の原則です。具体的な実装方法は各言語別規約ファイルを参照してください。
