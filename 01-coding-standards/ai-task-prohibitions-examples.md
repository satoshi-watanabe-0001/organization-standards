---
title: "AI開発タスク禁止事項 - 具体例ガイド"
version: "1.0.0"
date: "2025-11-19"
status: "提案"
author: "AI Autonomous Development Analysis"
---

# AI開発タスク禁止事項 - 具体例ガイド

## 📋 このドキュメントについて

### 目的
禁止事項の**具体的な例**と**OK/NG判定の境界線**を明示することで、AIエージェントが自律的に正しい判断を行えるようにする。

### 対象
- 自律型AIエージェント（Devin、Cursor等）
- AI支援開発ツール
- 人間の開発者（参考情報として）

---

## 🔴 Phase 0: 要件分析・企画 - 禁止事項の具体例

### 禁止事項1: 要件確認不足

**禁止内容**: PBIを十分に理解せずにタスク分解を進めてはいけない

#### ❌ NG例
```yaml
状況:
  PBI: "ユーザー管理機能を追加する"
  
NG行動:
  - PBIを読まずに、一般的なユーザー管理機能の実装を開始
  - "ユーザー管理"の定義を確認せずにタスク分解
  - 非機能要件（パフォーマンス、セキュリティ）を無視

結果:
  - 要件と異なる機能を実装してしまう
  - 手戻りが発生
  - ステークホルダーの期待と乖離
```

#### ✅ OK例
```yaml
状況:
  PBI: "ユーザー管理機能を追加する"

OK行動:
  1. PBIの詳細を確認
     - 対象ユーザー: 管理者のみ？ 一般ユーザーも？
     - CRUD操作: どこまで必要？
     - 認証方式: 既存システムと統合？独立？
  
  2. 受入基準をチェック
     - "管理者がユーザーを作成・編集・削除できる"
     - "パスワードは8文字以上、暗号化保存"
     - "APIレスポンスは200ms以内"
  
  3. 不明点を明確化
     - パスワードリセット機能は必要か？ → 確認リクエスト
     - メール通知は必要か？ → Phase 1で実装しないと仮定
  
  4. 上記を踏まえてタスク分解

結果:
  - 要件に合致した実装
  - 手戻り最小化
```

#### 境界線
```
【判定基準】
✅ OK: PBIの全項目を読み、不明点をリスト化した
❌ NG: PBIのタイトルだけ見てタスク分解を開始

✅ OK: 不明点を「重要度」で分類し、必要に応じて確認リクエスト
❌ NG: 不明点があるのに推測で進める

✅ OK: 受入基準を全てタスクに反映
❌ NG: 受入基準の一部を見落とす
```

---

### 禁止事項2: 勝手な要件追加

**禁止内容**: PBIに記載のない機能を独断で追加してはいけない

#### ❌ NG例
```yaml
PBI:
  "ユーザー一覧表示機能を追加"
  
NG行動:
  「一覧表示だけでは不便だから、以下も追加しよう」
  - ユーザー検索機能（記載なし）
  - ユーザーエクスポート機能（記載なし）
  - ユーザーインポート機能（記載なし）
  - ユーザー統計ダッシュボード（記載なし）

結果:
  - スコープクリープ
  - 開発期間の超過
  - テスト工数の増加
  - 承認されていない機能の実装
```

#### ✅ OK例
```yaml
PBI:
  "ユーザー一覧表示機能を追加"

OK行動:
  1. PBIに記載された範囲のみ実装
     - ユーザー一覧表示
     - ページネーション（PBIに記載）
     - ソート機能（PBIに記載）
  
  2. 追加機能の提案は別途記録
     記録先: `future-enhancements.md`
     内容:
     - 検索機能があると便利（次のスプリントで検討）
     - エクスポート機能の需要がありそう（要確認）
  
  3. PO/テックリードに提案（実装前に）

結果:
  - 承認された範囲のみ実装
  - スケジュール通り
  - 追加機能は適切なプロセスで検討
```

#### 境界線
```
【判定基準】
✅ OK: PBIに明記された機能のみ実装
❌ NG: "便利だから"という理由で機能を追加

✅ OK: 追加機能の提案を文書化し、承認を得てから実装
❌ NG: 口頭や思いつきで機能を追加

✅ OK: 必須機能と推奨機能を区別（PBIの記載に従う）
❌ NG: 推奨機能を勝手に必須と解釈
```

---

### 禁止事項3: スコープ拡大

**禁止内容**: 必要最小限の実装範囲を超えて勝手に機能を拡張してはいけない

#### ❌ NG例
```yaml
PBI:
  "ログイン機能を実装（メール+パスワード）"

NG行動:
  「ついでに他の認証方式も実装しよう」
  - Google OAuth対応（記載なし）
  - Facebook OAuth対応（記載なし）
  - 二要素認証（記載なし）
  - パスワードリセット機能（記載なし）
  - アカウントロック機能（記載なし）

理由:
  「セキュリティ的に必要だと思ったから」
  「将来必要になるから先にやっておく」
  
結果:
  - 開発期間3日 → 2週間に膨張
  - テスト範囲が拡大
  - レビュー負荷増加
```

#### ✅ OK例
```yaml
PBI:
  "ログイン機能を実装（メール+パスワード）"

OK行動:
  1. PBIに記載された範囲のみ実装
     - メール+パスワードによるログイン
     - JWT発行
     - 基本的なバリデーション
  
  2. セキュリティ要件は制約条件文書を確認
     - パスワードハッシュ化: bcrypt（組織標準）
     - JWTの有効期限: 24時間（組織標準）
     - レート制限: 100req/min（組織標準）
  
  3. 追加のセキュリティ機能は別PBIとして提案
     提案内容:
     - PBI: "二要素認証の実装"（優先度: 中）
     - PBI: "パスワードリセット機能"（優先度: 高）

結果:
  - PBI通りに3日で完了
  - 追加機能は適切に計画
```

#### 境界線
```
【判定基準】
✅ OK: PBIの範囲を守り、最小限の実装
❌ NG: "ついでに"で範囲を拡大

✅ OK: セキュリティ要件は組織標準に従う
❌ NG: 独自判断で"より安全"な実装を追加

✅ OK: 追加機能は別PBIとして提案
❌ NG: "将来必要"という理由で先行実装

【例外ケース】
✅ OK: 組織のセキュリティ標準に準拠するための実装
       例: パスワードハッシュ化（標準で必須）
❌ NG: 標準以上のセキュリティ機能を独断追加
       例: 顔認証、指紋認証（標準に記載なし）
```

---

## 🔴 Phase 1: プロジェクト初期化 - 禁止事項の具体例

### 禁止事項1: 組織標準違反

**禁止内容**: 組織のディレクトリ構造、命名規則を無視してはいけない

#### ❌ NG例
```yaml
組織標準:
  ディレクトリ構造: "src/controllers/, src/services/, src/repositories/"
  命名規則: "camelCase for files, PascalCase for classes"

NG行動:
  実装したディレクトリ構造:
  - src/
    ├── Controllers/  ❌ (Cが大文字)
    ├── Services/     ❌ (Sが大文字)
    ├── dao/          ❌ (repositoriesではなくdao)
    └── utilities/    ❌ (utilsではなくutilities)
  
  ファイル命名:
  - UserController.ts  ❌ (user-controller.ts が標準)
  - user_service.ts    ❌ (snake_case)

理由:
  「前のプロジェクトでこうしていたから」
  「自分の好みの構造の方が良いと思った」

結果:
  - コードレビューで差し戻し
  - リファクタリング工数が発生
  - チーム内の統一感が失われる
```

#### ✅ OK例
```yaml
組織標準を確認:
  参照ドキュメント:
  - 02-architecture-standards/project-structure.md
  - 01-coding-standards/typescript.md

OK行動:
  標準に準拠したディレクトリ構造:
  - src/
    ├── controllers/   ✅
    ├── services/      ✅
    ├── repositories/  ✅
    └── utils/         ✅
  
  ファイル命名:
  - user-controller.ts   ✅ (camelCase)
  - user-service.ts      ✅ (camelCase)
  - user-repository.ts   ✅ (camelCase)
  
  クラス命名:
  - class UserController  ✅ (PascalCase)
  - class UserService     ✅ (PascalCase)

結果:
  - レビュー時の指摘なし
  - 他の開発者が直感的に理解
  - メンテナンス性向上
```

#### 境界線
```
【判定基準】
✅ OK: 組織標準ドキュメントを参照し、準拠
❌ NG: 自分の好みや過去の経験で独自構造を作成

✅ OK: 標準に記載のない部分は、既存プロジェクトを参考にする
❌ NG: 標準を読まずに、独自の命名規則を適用

【例外ケース】
✅ OK: 組織標準に明らかな誤りがある場合
       → テックリードに報告し、標準の更新を提案
❌ NG: "標準より良い方法を見つけた"と独断で変更
```

---

### 禁止事項2: 不適切な技術選定

**禁止内容**: 組織承認外のフレームワークやライブラリを独断で選定してはいけない

#### ❌ NG例
```yaml
承認済み技術リスト:
  ORM: "Prisma, TypeORM"
  Web Framework: "Express.js, NestJS"

NG行動:
  「新しいORMを見つけたから使ってみる」
  - 選定: Drizzle ORM ❌ (承認リストにない)
  - 選定: Fastify ❌ (承認リストにない)
  
  理由:
  「Prismaより高速らしい」
  「最近話題になっている」
  「個人的に使ってみたかった」

結果:
  - 組織内にナレッジがない
  - サポートが受けられない
  - 本番運用時のリスク
  - チーム全体の学習コストが発生
```

#### ✅ OK例
```yaml
承認済み技術リストを確認:
  参照: 05-technology-stack/approved-technologies.md

OK行動:
  1. 承認リストから選定
     - ORM: Prisma ✅
     - Web Framework: Express.js ✅
  
  2. 新技術を使いたい場合
     Step 1: 技術評価レポートを作成
     - パフォーマンス比較
     - 学習コスト評価
     - コミュニティサポート状況
     - ライセンス確認
     
     Step 2: テックリードに提案
     - 評価レポートを添付
     - PoC実施の許可を得る
     
     Step 3: PoC実施後、承認を待つ
     
     Step 4: 承認されたら使用開始

結果:
  - 組織標準に準拠
  - チームのサポートが得られる
  - 運用リスクの最小化
```

#### 境界線
```
【判定基準】
✅ OK: 承認済み技術リストから選定
❌ NG: リストにない技術を独断で使用

✅ OK: 新技術の提案プロセスを経て、承認後に使用
❌ NG: "後で承認取ればいい"と先に実装

✅ OK: 技術選定の理由を文書化（ADR作成）
❌ NG: "なんとなく"で選定

【例外ケース】
✅ OK: 緊急のセキュリティ脆弱性対応で代替ライブラリが必要
       → 即座にテックリードに報告し、承認を得る
❌ NG: "承認リストのライブラリが古い"と独断で変更
```

---

## 🔴 Phase 2.1: 事前設計 - 禁止事項の具体例

### 禁止事項1: 過剰詳細設計

**禁止内容**: 実装前に全詳細を記述してはいけない（完全版はPhase 2.2で作成）

#### ❌ NG例
```yaml
Phase 2.1での作成物:
  設計書: 80ページ ❌
  内容:
  - 全クラスの詳細設計（メソッド単位）
  - 全データベーステーブルの詳細定義
  - 全API仕様の完全版
  - エラーハンドリングの全パターン
  - ユニットテストの全ケース設計
  - パフォーマンスチューニングの詳細

所要時間: 2週間 ❌

理由:
  「実装前に完璧な設計を作りたい」
  「後で変更が発生しないように」

結果:
  - 実装開始が遅延
  - 実装時に設計と乖離
  - 手戻りで設計書が無駄に
  - Phase 2.2で二重作業
```

#### ✅ OK例
```yaml
Phase 2.1での作成物:
  ADR: 5ページ ✅
  内容:
  - 重要な技術決定のみ（3-5個）
  - 決定の理由と代替案
  
  API契約書: 3ページ ✅
  内容:
  - エンドポイント一覧
  - 基本的なリクエスト/レスポンス形式
  - 認証方式
  
  制約条件文書: 2ページ ✅
  内容:
  - セキュリティ制約
  - パフォーマンス制約
  - 技術制約

所要時間: 1-2日 ✅

理由:
  「実装をブロックしない最小限の設計」
  「詳細はPhase 2.2で実装を基に作成」

結果:
  - 実装が即座に開始可能
  - 実装と設計の乖離なし
  - Phase 2.2で実装ベースの詳細設計
```

#### 境界線
```
【判定基準】
✅ OK: 実装の方向性を定める設計（10ページ以内）
❌ NG: 実装の詳細まで記述（30ページ以上）

✅ OK: 重要な技術決定のみADRに記録（3-5個）
❌ NG: すべての決定事項を記録（10個以上）

✅ OK: API契約書はエンドポイント一覧レベル
❌ NG: API契約書にエラーケース全パターンを記載

【80%ルール】
✅ OK: 80%の完成度で次へ進む
❌ NG: 100%完璧を目指して時間をかける

【時間制限】
✅ OK: Phase 2.1は最大2日
❌ NG: 3日以上かける
```

---

### 禁止事項2: 実装の先行

**禁止内容**: API設計が固まる前に実装を始めてはいけない

#### ❌ NG例
```yaml
状況:
  Phase 2.1でAPI設計中

NG行動:
  「API設計が終わっていないけど、実装を始めよう」
  
  実装開始:
  - UserControllerを実装
  - エンドポイント: POST /users （仮決定）
  
  その後、API設計で:
  - エンドポイント: POST /api/v1/users に変更 ❌
  - リクエスト形式が変更 ❌
  
結果:
  - 実装したコードが無駄に
  - 手戻りが発生
  - テストコードも書き直し
```

#### ✅ OK例
```yaml
状況:
  Phase 2.1でAPI設計中

OK行動:
  1. API契約書を作成
     - エンドポイント: POST /api/v1/users
     - リクエスト形式: { email, password, name }
     - レスポンス形式: { id, email, name, createdAt }
  
  2. ステークホルダーレビュー
     - フロントエンドチームと合意
     - テックリードの承認
  
  3. API設計確定後、Phase 3で実装開始

結果:
  - API設計が確定している
  - 手戻りなし
  - フロントエンドとの整合性確保
```

#### 境界線
```
【判定基準】
✅ OK: Phase 2.1完了 → Phase 3で実装開始
❌ NG: Phase 2.1中に実装を先行

✅ OK: API契約書が承認されてから実装
❌ NG: API設計が仮決定の段階で実装

【例外ケース】
✅ OK: PoC (Proof of Concept) 目的で実装して検証
       → Phase 2.1の一部として実施
       → 検証後、コードは破棄し、Phase 3で正式実装
❌ NG: PoCのコードをそのまま本実装に流用
```

---

## 🔴 Phase 3: 実装 - 禁止事項の具体例

### 禁止事項1: 設計無視

**禁止内容**: API設計書やアーキテクチャ設計を無視して独自実装してはいけない

#### ❌ NG例
```yaml
API設計書:
  エンドポイント: POST /api/v1/users
  リクエスト:
    {
      "email": "string",
      "password": "string",
      "name": "string"
    }
  レスポンス: 201 Created
    {
      "id": "uuid",
      "email": "string",
      "name": "string",
      "createdAt": "datetime"
    }

NG実装:
  エンドポイント: POST /user/create ❌ (設計と異なる)
  リクエスト:
    {
      "email": "string",
      "pass": "string",     ❌ (passwordではなくpass)
      "username": "string"  ❌ (nameではなくusername)
    }
  レスポンス: 200 OK ❌ (201 Createdではない)

理由:
  「こっちの方がRESTfulだと思った」
  「短い名前の方が良い」

結果:
  - フロントエンドとの統合失敗
  - APIドキュメントと実装が乖離
  - レビューで差し戻し
```

#### ✅ OK例
```yaml
API設計書を参照:
  参照: docs/api/openapi-spec.yaml

OK実装:
  エンドポイント: POST /api/v1/users ✅
  リクエスト:
    {
      "email": "string",
      "password": "string",
      "name": "string"
    }
  レスポンス: 201 Created ✅
    {
      "id": "uuid",
      "email": "string",
      "name": "string",
      "createdAt": "datetime"
    }

実装:
```typescript
router.post('/api/v1/users', async (req, res) => {
  const { email, password, name } = req.body;
  
  const user = await userService.createUser({ email, password, name });
  
  res.status(201).json({
    id: user.id,
    email: user.email,
    name: user.name,
    createdAt: user.createdAt
  });
});
```

結果:
  - 設計書と完全一致
  - フロントエンドとの統合成功
  - レビューで承認
```

#### 境界線
```
【判定基準】
✅ OK: API設計書の仕様を100%実装
❌ NG: API設計書と異なる実装

✅ OK: 設計書に誤りを発見 → テックリードに報告し、設計書を修正してから実装
❌ NG: 設計書に誤りを発見 → 独断で"正しい"実装に変更

✅ OK: 設計書に記載のない詳細は、組織標準に従う
❌ NG: 設計書に記載のない詳細を、独自判断で実装
```

---

### 禁止事項2: テスト省略

**禁止内容**: 実装コードに対応するテストコードを書かずに進めてはいけない

#### ❌ NG例
```yaml
実装状況:
  - UserService.ts ✅ 実装完了
  - UserController.ts ✅ 実装完了
  - UserRepository.ts ✅ 実装完了

テスト状況:
  - UserService.test.ts ❌ 未作成
  - UserController.test.ts ❌ 未作成
  - UserRepository.test.ts ❌ 未作成

理由:
  「後でまとめてテストを書く」
  「時間がないから実装優先」
  「動作確認はPostmanでやったから大丈夫」

結果:
  - バグが本番で発見される
  - リファクタリング時の安全性がない
  - コードレビューで差し戻し
  - テストカバレッジ要件（80%）を満たさない
```

#### ✅ OK例
```yaml
実装とテストを並行:
  Day 1:
  - UserRepository.ts ✅ 実装
  - UserRepository.test.ts ✅ テスト作成
  
  Day 2:
  - UserService.ts ✅ 実装
  - UserService.test.ts ✅ テスト作成
  
  Day 3:
  - UserController.ts ✅ 実装
  - UserController.test.ts ✅ テスト作成

テストカバレッジ:
  - Statements: 87% ✅
  - Branches: 82% ✅
  - Functions: 90% ✅
  - Lines: 86% ✅

結果:
  - バグを早期発見
  - 安全にリファクタリング可能
  - レビューで承認
  - 組織標準（80%以上）を満たす
```

#### 境界線
```
【判定基準】
✅ OK: 実装とテストを並行して作成
❌ NG: 実装のみ進めて、テストを後回し

✅ OK: コミット前にテストを実行し、全てパス
❌ NG: テストが失敗しているのにコミット

✅ OK: カバレッジ80%以上を維持
❌ NG: カバレッジを確認せずにPR作成

【例外ケース】
✅ OK: PoC段階ではテストを簡略化
       → ただし、正式実装時は必須
❌ NG: "実験的コード"という理由で本実装のテストを省略
```

---

## 🔴 全フェーズ共通 - 禁止事項の具体例

### 禁止事項1: CI/CD設定の無断変更

**禁止内容**: 明示的な指示がない限り、CI/CD設定ファイルを変更してはいけない

#### ❌ NG例
```yaml
状況:
  テストが失敗している

NG行動:
  「テストが邪魔だからCIで無効化しよう」
  
  変更: .github/workflows/ci.yml
  ```yaml
  - name: Run tests
    run: npm test
    continue-on-error: true  ❌ 追加（失敗しても続行）
  ```
  
  または:
  ```yaml
  # - name: Run tests  ❌ コメントアウト
  #   run: npm test
  ```

理由:
  「開発速度を上げたい」
  「テストの修正は後でやる」

結果:
  - バグが本番に混入
  - 品質ゲートが機能しない
  - チーム全体の品質低下
```

#### ✅ OK例
```yaml
状況:
  テストが失敗している

OK行動:
  1. 失敗の原因を特定
     - テストコードのバグ
     - 実装コードのバグ
  
  2. 適切に修正
     - テストコードを修正
     - または実装コードを修正
  
  3. テストが全てパスすることを確認
  
  4. CIが正常に通ることを確認

結果:
  - 品質が維持される
  - バグが早期発見される
```

#### 境界線
```
【判定基準】
✅ OK: CI/CD設定は変更しない
❌ NG: テストを無効化、スキップ、緩和

【例外ケース（事前承認必須）】
✅ OK: 新しいテストステップの追加（テックリード承認済み）
✅ OK: CI環境のNode.jsバージョンアップ（承認済み）
❌ NG: "一時的に"という理由でテストを無効化
```

---

### 禁止事項2: 本番環境への直接変更

**禁止内容**: 本番データベース、本番サーバー、本番設定ファイルを直接変更してはいけない

#### ❌ NG例
```yaml
状況:
  本番環境でバグ発見

NG行動:
  「すぐ直さないと」
  
  SSH接続: production-server
  直接編集: /app/config/database.yml ❌
  直接実行: UPDATE users SET role='admin' WHERE id=123; ❌
  直接修正: src/controllers/user-controller.ts ❌
  再起動: pm2 restart app ❌

理由:
  「緊急対応だから」
  「1行だけだから大丈夫」

結果:
  - 変更履歴が残らない
  - コードリポジトリと本番が乖離
  - レビューを経ていない変更
  - ロールバック不可能
  - 他の環境に反映されない
```

#### ✅ OK例
```yaml
状況:
  本番環境でバグ発見

OK行動（緊急度: 高）:
  1. Hotfixブランチを作成
     git checkout -b hotfix/fix-user-role-bug
  
  2. ローカルで修正
     - コードを修正
     - テストを追加
     - ローカルで動作確認
  
  3. 迅速レビュー
     - PR作成
     - テックリードの緊急レビュー（15分）
  
  4. ステージング環境で確認
     - 修正が正しく動作
  
  5. 本番デプロイ（標準プロセス）
     - CI/CDパイプライン経由
     - デプロイメント記録
  
  所要時間: 30分-1時間

OK行動（緊急度: 中）:
  1. 通常のブランチ作成
  2. 修正 + テスト
  3. PR作成
  4. レビュー待ち
  5. 承認後、デプロイ

結果:
  - 変更履歴が残る
  - レビューを経た変更
  - ロールバック可能
  - 他の環境に反映可能
```

#### 境界線
```
【判定基準】
✅ OK: 開発 → ステージング → 本番の順でデプロイ
❌ NG: 本番環境に直接SSH接続して修正

✅ OK: 緊急時もCI/CDパイプライン経由
❌ NG: "緊急だから"という理由で手動変更

【緊急対応の定義】
✅ OK: サービス停止中 → Hotfixプロセス（迅速レビュー）
❌ NG: バグがある → 通常プロセス

【絶対禁止】
❌ NG: 本番データベースに直接クエリ実行
❌ NG: 本番サーバーでコードを直接編集
❌ NG: 本番環境の設定ファイルを直接変更
```

---

## 📚 まとめ: 判断フローチャート

```
【行動を起こす前のチェックリスト】

1. この行動は組織標準に記載されているか？
   YES → 標準に従う
   NO → 2へ

2. この行動はPBI/要件に記載されているか？
   YES → 実施可能
   NO → 3へ

3. この行動はテックリード/POの承認を得ているか？
   YES → 実施可能
   NO → 4へ

4. この行動は緊急対応か？
   YES → 承認プロセスを簡略化（事後報告）
   NO → 実施前に承認を得る

【迷ったときの原則】
✅ 確認してから実施
❌ 実施してから報告
```

---

**作成日**: 2025-11-19  
**次回レビュー**: 3ヶ月後  
**オーナー**: Engineering Leadership Team
